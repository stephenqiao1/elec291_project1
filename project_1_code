$NOLIST
$MODLP51RC2
$LIST

$NOLIST
$include(LCD_4bit.inc) ; A library of LCD related functions and utility macros
$LIST

$NOLIST
$include(math32.inc)
$LIST

;These �EQU� must match the wiring between the microcontroller and ADC
CLK  EQU 22118400
BAUD equ 115200
BRG_VAL equ (0x100-(CLK/(16*BAUD)))

TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))

;***Messages To Display*** 

;shortened labels
STemp:  db 'STmp:', 0
STime:  db 'STme:', 0
RTemp:  db 'RTmp:', 0
RTime:  db 'RTme:', 0

;lables for runnning oven
state:     db 'State:' , 0
time:      db 'Tme:' , 0
colon:     db ':',0
temp:      db 'Tmp:'

;labels for changin parameters
ReflowTemp:  db 'Reflow Temperature:', 0
ReflowTime:  db 'Reflow Time:', 0
SoakTime:    db 'Soak Time:', 0
SoakTemp:    db 'Soak Temperature:', 0


;Current State in Oven
Ramp2Soak: db 'Ramp-Soak' , 0
Soak:      db 'Soak' , 0
Ramp2Peak: db 'Ramp-Peak' , 0
Reflow:    db 'Reflow' , 0
Cooling:   db 'Cooling' , 0



;Button Pin Mapping
START_BUTTON    equ P0.6
STIME_BUTTON    equ P0.6
STEMP_BUTTON    equ P0.6
RTIME_BUTTON    equ P0.6
RTEMP_BUTTON    equ P0.6
POWER_BUTTON    equ P0.6

; Reset vector
org 0x0000
    ljmp main

; Timer/Counter 2 overflow interrupt vector
org 0x002B
	ljmp Timer2_ISR


; Place our variables here
DSEG at 0x30 ; Before the state machine!
Count1ms:         ds 2 ; Used to determine when one second has passed
state:            ds 1
Temp_soak:        ds 2
Time_soak:        ds 1
Temp_refl:        ds 2
Time_refl:        ds 1
Run_time_seconds: ds 1
Run_time_minutes: ds 1
State_time:       ds 1
Temp_oven:        ds 2

bseg
one_seconds_flag: dbit 1
mf:               dbit 1

cseg
; These 'equ' must match the hardware wiring
LCD_RS equ P3.2
;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
LCD_E  equ P3.3
LCD_D4 equ P3.4
LCD_D5 equ P3.5
LCD_D6 equ P3.6
LCD_D7 equ P3.7

;***FXNS to CHECK BUTTONS

Display_lower_BCD mac
    push ar0
    mov r0, %0
    lcall ?Display_lower_BCD
    pop ar0
endmac

?Display_lower_BCD:
    push acc
    ; write least significant digit
    mov a, r0
    anl a, #0fh
    orl a, #30h
    lcall ?WriteData
    pop acc
ret


CHECK_STIME:

    jb STIME_BUTTON, CHECK_STIME_END ; if button not pressed, stop checking
	Wait_Milli_Seconds(#50) ; debounce time
	jb STIME_BUTTON, CHECK_STIME_END ; if button not pressed, stop checking
	jnb STIME_BUTTON, $ ; loop while the button is pressed
    
    mov a, Time_soak ;increment STime by 1
    add a, #1
    da a
    mov Time_soak, a
    cjne a, #0x91, CHECK_STIME_END
    mov Time_soak, #0x60
	
CHECK_STIME_END:
ret

CHECK_STEMP:

    jb STEMP_BUTTON, CHECK_STEMP_END ; if button not pressed, stop checking
	Wait_Milli_Seconds(#50) ; debounce time
	jb STEMP_BUTTON, CHECK_STEMP_END ; if button not pressed, stop checking
	jnb STEMP_BUTTON, $ ; loop while the button is pressed
    
    mov a, Temp_soak ;increment STEMP by 5
    add a, #5
    da a
    mov Temp_soak, a
    cjne a, #0x205, CHECK_STEMP_END
    mov Temp_soak, #0x140
	
CHECK_STEMP_END:
ret

CHECK_RTIME:

    jb RTIME_BUTTON, CHECK_RTIME_END ; if button not pressed, stop checking
	Wait_Milli_Seconds(#50) ; debounce time
	jb RTIME_BUTTON, CHECK_RTIME_END ; if button not pressed, stop checking
	jnb RTIME_BUTTON, $ ; loop while the button is pressed
    
    mov a, Time_refl ;increment RTime by 1
    add a, #1
    da a
    mov Time_refl, a
    cjne a, #0x61, CHECK_RTIME_END
    mov Time_refl, #0x30
	
CHECK_RTIME_END:
ret

CHECK_RTEMP:

    jb RTEMP_BUTTON, CHECK_RTEMP_END ; if button not pressed, stop checking
	Wait_Milli_Seconds(#50) ; debounce time
	jb RTEMP_BUTTON, CHECK_RTEMP_END ; if button not pressed, stop checking
	jnb RTEMP_BUTTON, $ ; loop while the button is pressed
    
    mov a, Temp_refl ;increment RTemp by 5
    add a, #5
    da a
    mov Temp_refl, a
    cjne a, #0x255, CHECK_RTEMP_END
    mov Temp_refl, #0x220
	
CHECK_RTEMP_END:
ret

;***Additional FXNS

;off state
OFF_STATE:
    ;**CLEAR SCREEN**
    WriteCommand(#0x01)
    
    jb POWER_BUTTON, $ ; loop while the button is not pressed
	Wait_Milli_Seconds(#50) ; debounce time
	jb POWER_BUTTON, OFF_STATE ; it was a bounce, try again
	jnb POWER_BUTTON, $ ; loop while the button is pressed
ljmp state0
;ret


Check_Time:
    jnb one_seconds_flag, Check_time_done ;If one sec has passes, increment state/run time and detect overflow. Otherwise skip
    clr one_seconds_flag
Check_sec_overflow: 
; Increment the run time counter and state time counter
	mov a, Run_time_seconds
	add a, #0x01
	da a ; Decimal adjust instruction.
    ;check sec overflow
    cjne a, #0x60, Check_time_done
    mov Run_time_seconds, #0x00
    mov a, Run_time_minutes
    add a, #1
    da a
    mov Run_time_minutes, a

Check_time_done:
    mov Run_time_seconds, a
	mov a, State_time
	add a, #0x01
	da a
	mov State_time, a
    ret
;Initial state, Display Parameter Values


;---------------------------------;
; Routine to initialize the ISR   ;
; for timer 2                     ;
;---------------------------------;
Timer2_Init:
	mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
	mov TH2, #high(TIMER2_RELOAD)
	mov TL2, #low(TIMER2_RELOAD)
	; Set the reload value
	mov RCAP2H, #high(TIMER2_RELOAD)
	mov RCAP2L, #low(TIMER2_RELOAD)
	; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
	clr a
	mov Count1ms+0, a
	mov Count1ms+1, a
	; Enable the timer and interrupts
    setb ET2  ; Enable timer 2 interrupt
    setb TR2  ; Enable timer 2
	ret

;---------------------------------;
; ISR for timer 2                 ;
;---------------------------------;
Timer2_ISR:
	clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
	cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
	
	; The two registers used in the ISR must be saved in the stack
	push acc
	push psw
	
	; Increment the 16-bit one mili second counter
	inc Count1ms+0    ; Increment the low 8-bits first
	mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
	jnz Inc_Done
	inc Count1ms+1

Inc_Done:
	; Check if one second has passed
	mov a, Count1ms+0
	cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
	mov a, Count1ms+1
	cjne a, #high(1000), Timer2_ISR_done
	
	; 1000 milliseconds have passed.  Set a flag so the main program knows
	setb one_seconds_flag ; Let the main program know one second had passed
	
	clr a
	mov Count1ms+0, a
	mov Count1ms+1, a
Timer2_ISR_done:
	pop psw
	pop acc
	reti


Power_conversion:
; Algorithm: (distribution of power across the soak time)
; 1. Save soak_time to a register
; 2. Divide the value in the register by 10
; 3. Multiply the value in the register by 2
; 4. Divide the value in the register by the variable num_intervals
; 5. Save the value to a new register
; 6. Subtract soak_time by the value in 5. and save to a different register
; 7. Divide the value in the register by the variable num_intervals to get the wait time in between intervals 


main:

    mov SP, #0x7F
    lcall Timer2_Init
    ; In case you decide to use the pins of P0, configure the port in bidirectional mode:
    mov P0M0, #0
    mov P0M1, #0
    setb EA   ;Enable global enterupt
    lcall LCD_4BIT

    mov Temp_soak, #0x140 ; Soak Tmp Range is 140-200
    mov Time_soak, #0x60  ; Range 60-90 seconds
    mov Temp_refl, #0x220 ; Range 220-245
    mov Time_refl, #0x30  ; Range 30-60 seconds
    mov Run_time_seconds, #0x00 ; time starts at 0:00
    mov Run_time_minutes, #0x00
    mov State_time, #0 ; set state time to 0 


state0: ; idle
;***clear the screen***
    WriteCommand(#0x01)
;***initial parameters displayed***
    
    ;Displays Soak Temp and Time
    Set_Cursor(1, 1)
    Send_Constant_String(#STemp)
    Set_Cursor(1, 6)
    Display_lower_BCD(Temp_soak+1)
    Set_Cursor(1,7)
	Display_BCD(Temp_soak+0)
    
    Set_Cursor(1,10)
    Send_Constant_String(#STime)
    Set_Cursor(1, 15)
	Display_BCD(Time_soak)

    ;Displays Reflow Temp and Time
    Set_Cursor(2,1)
    Send_Constant_String(#RTemp)
    Set_Cursor(2,6)
    Display_lower_BCD(Temp_refl+1)
    Set_Cursor(2,7)
	Display_BCD(Temp_refl+0)
    
    Set_Cursor(2,10)
    Send_Constant_String(#RTime)
    Set_Cursor(2, 15)
	Display_BCD(Time_refl)

    ; check the parameters being pressed
    lcall CHECK_STIME
    lcall CHECK_STEMP
    lcall CHECK_RTIME
    lcall CHECK_RTEMP
    
    jb NEXT_STATE_BUTTON, state0
    Wait_Milli_Seconds(#50) ; debounce time
	jb NEXT_STATE_BUTTON, state0 ; if button not pressed, loop
	jnb NEXT_STATE_BUTTON, $ 
    ljmp state0_done
state0_done:
    mov state, #1
    mov State_time, #0
    sjmp state1_beginning

state1_beginning:
    
    ;***clear the screen and set new display***
    WriteCommand(#0x01)
    
    Set_Cursor(1, 1)
    Send_Constant_String(#time)
    Set_Cursor(1, 5)
	Display_BCD(Run_time_minutes)
    Set_Cursor(1,6)
    Send_Constant_String(#colon)
    Set_Cursor(1,7)
    Display_BCD(Run_time_seconds)
    
    Set_Cursor(1,10)
    Send_Constant_String(#temp)
    Set_Cursor(1,14)
    Display_lower_BCD(Temp_oven+1)
    Set_Cursor(1,15)
    Display_BCD(Temp_oven+0)
    
    Set_Cursor(2,1)
    Send_Constant_String(#state)
    Set_Cursor(2,7)
    Send_Constant_String(#Ramp2Soak); displays current state
    

state1: ; ramp to soak

    lcall Check_Time
    ; check if temp is below 150 
    MOV A, Temp_soak           
    SUBB A, Temp_soak       
    JNC state1_done    ; if greater, jump to state 2
    JZ state1 ; if equal to, go back to state1
    JC state1 ; if less than, go back to state1
state1_done:
    mov state, #2
    ;set State_time = 0
    mov State_time, #0
    sjmp state2_beginning

;OFF_STATE2:
    ;ljmp OFF_STATE

; preheat/soak
state2_beginning: 
    mov State_time, #0x00 ;clear the state time
    ;***clear the screen and set new display***
    WriteCommand(#0x01)
    
    Set_Cursor(1, 1)
    Send_Constant_String(#time)
    Set_Cursor(1, 5)
	Display_BCD(Run_time_minutes)
    Set_Cursor(1,6)
    Send_Constant_String(#colon)
    Set_Cursor(1,7)
    Display_BCD(Run_time_seconds)
    Set_Cursor(1,10)
    
    Send_Constant_String(#temp)
    Set_Cursor(1,14)
    Display_lower_BCD(Temp_oven+1)
    Set_Cursor(1,15)
    Display_BCD(Temp_oven+0)
    Set_Cursor(2,1)
    
    Send_Constant_String(#state)
    Set_Cursor(2,7)
    Send_Constant_String(#Soak); displays current state

state2: 
    ; timer (incrementing state time)
    lcall Check_Time
    
    ; loop back to state2 if run time is less than soak time
    mov a, Time_soak
    subb a, State_time
    cjne a, #0, state2
    
state2_done:
    mov State_time, #0
    ljmp state3_beginning

; ramp to peak
state3_beginning:

    ;***clear the screen and set new display***
    WriteCommand(#0x01)
    Set_Cursor(1, 1)
    Send_Constant_String(#time)
    Set_Cursor(1, 5)
	Display_BCD(Run_time_minutes)
    Set_Cursor(1,6)
    Send_Constant_String(#colon)
    Set_Cursor(1,7)
    Display_BCD(Run_time_seconds)
    Set_Cursor(1,10)
    
    Send_Constant_String(#temp)
    Set_Cursor(1,14)
    Display_lower_BCD(Temp_oven+1)
    Set_Cursor(1,15)
    Display_BCD(Temp_oven+0)
    Set_Cursor(2,1)
    
    Send_Constant_String(#state)
    Set_Cursor(2,7)
    Send_Constant_String(#Ramp2Peak)

state3: 
    lcall Check_Time
    mov a, Temp_oven
    subb a, #220
    JNC state3_done    ; if greater, jump to state 4
    JZ state3 ; if equal to, go back to state3
    JC state3 ; if less than, go back to state3
    
;helllooooooooo
state3_done:
    mov State_time, #0
    ljmp state4_beginning


; reflow 
state4_beginning:
    ;***clear the screen and set new display***
    WriteCommand(#0x01)
    Set_Cursor(1, 1)
    Send_Constant_String(#time)
    Set_Cursor(1, 5)
	Display_BCD(Run_time_minutes)
    Set_Cursor(1,6)
    Send_Constant_String(#colon)
    Set_Cursor(1,7)
    Display_BCD(Run_time_seconds)
    Set_Cursor(1,10)
    
    Send_Constant_String(#temp)
    Set_Cursor(1,14)
    Display_lower_BCD(Temp_oven+1)
    Set_Cursor(1,15)
    Display_BCD(Temp_oven+0)
    Set_Cursor(2,1)
    
    Send_Constant_String(#state)
    Set_Cursor(2,7)
    Send_Constant_String(#Reflow)


state4:
    lcall Check_Time
    mov a, Time_refl
    subb a, State_time
    cjne a, #0, state4

state4_done: 
    mov State_time, #0
    ljmp state5_beginning 


; cooling
state5_beginning:
;***clear the screen and set new display***
    WriteCommand(#0x01)
    Set_Cursor(1, 1)
    Send_Constant_String(#time)
    Set_Cursor(1, 5)
	Display_BCD(Run_time_minutes)
    Set_Cursor(1,6)
    Send_Constant_String(#colon)
    Set_Cursor(1,7)
    Display_BCD(Run_time_seconds)
    Set_Cursor(1,10)
    
    Send_Constant_String(#temp)
    Set_Cursor(1,14)
    Display_lower_BCD(Temp_oven+1)
    Set_Cursor(1,15)
    Display_BCD(Temp_oven+0)
    Set_Cursor(2,1)
    
    Send_Constant_String(#state)
    Set_Cursor(2,7)
    Send_Constant_String(#Cooling)
state5:
    lcall Check_Time
    mov a, Temp_oven
    subb a, #60
    JNC state5    ; if greater, jump back to state 5
    JZ state5 ; if equal to, go back to state5
    JC state5_done ; if less than, go back to state 0

state5_done:
    mov State_time, #0
    ljmp state0_beginning  

 



