                  2   $LIST
0000              4   
0000              5   
0000              6   
0000              7   ;-------------------------------------------------------------------------------------------------------------------------------
0000              8   ;These EQU must match the wiring between the microcontroller and ADC
0000              9   CLK  EQU 22118400
0000             10   TIMER1_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             11   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             12   BAUD equ 115200
0000             13   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000             14   
0000             15   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             16   TIMER2_RELOAD EQU (65536-(CLK/TIMER2_RATE))
0000             17   
0000             18   ;shjfjdfs
0000             19   ;-------------------------------------------------------------------------------------------------------------------------------
0000             20   ;Button Pin Mapping
0000             21   NEXT_STATE_BUTTON  equ P0.5
0000             22   STIME_BUTTON    equ P0.2
0000             23   STEMP_BUTTON    equ P0.3
0000             24   RTIME_BUTTON    equ P0.4
0000             25   RTEMP_BUTTON    equ P0.6
0000             26   
0000             27   POWER_BUTTON    equ P4.5
0000             28   SHIFT_BUTTON    equ p0.4
0000             29   
0000             30   ;Output Pins
0000             31   OVEN_POWER      equ P0.7
0000             32   SPEAKER         equ P2.6
0000             33   
0000             34   PWM_OUTPUT    equ P1.0 ; Attach an LED (with 1k resistor in series) to P1.0
0000             35   
0000             36   FLASH_CE        equ P0.0
0000             37   
0000             38   ;Thermowire Pins
0000             39   CE_ADC    EQU  P1.7
0000             40   MY_MOSI   EQU  P1.6
0000             41   MY_MISO   EQU  P1.5
0000             42   MY_SCLK   EQU  P1.4 
0000             43   
0000             44   ; Commands supported by the SPI flash memory according to the datasheet
0000             45   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             46   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             47   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             48   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             49   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             50   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             51   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             52   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             53   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             54   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             55   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             56   
0000             57   ; These 'equ' must match the hardware wiring
0000             58   LCD_RS equ P3.2
0000             59   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
0000             60   LCD_E  equ P3.3
0000             61   LCD_D4 equ P3.4
0000             62   LCD_D5 equ P3.5
0000             63   LCD_D6 equ P3.6
0000             64   LCD_D7 equ P3.7
0000             65   
0000             66   ;-------------------------------------------------------------------------------------------------------------------------------
0000             67   
0000             68   org 0x0000
0000 020A21      69       ljmp main
0003             70   
0003             71   ; External interrupt 0 vector (not used in this code)
0003             72   org 0x0003
0003 32          73            reti
0004             74   
0004             75   ; Timer/Counter 0 overflow interrupt vector
000B             76   org 0x000B
000B 32          77            reti
000C             78   
000C             79   ; External interrupt 1 vector (not used in this code)
0013             80   org 0x0013
0013 32          81            reti
0014             82   
0014             83   ; Timer/Counter 1 overflow interrupt vector
001B             84   org 0x001B
001B 020970      85            ljmp Timer1_ISR
001E             86   
001E             87   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             88   org 0x0023 
0023 32          89            reti
0024             90            
0024             91   ; Timer/Counter 2 overflow interrupt vector
002B             92   org 0x002B
002B 0209C6      93       ljmp Timer2_ISR
002E             94   ;-------------------------------------------------------------------------------------------------------------------------------
002E             95   ; Place our variables here
0030             96   DSEG at 0x30 ; Before the state machine!
0030             97   Count1ms:         ds 2 ; Used to determine when one second has passed
0032             98   Count5sec:        ds 1
0033             99   States:           ds 1
0034            100   Temp_soak:        ds 1
0035            101   Time_soak:        ds 1
0036            102   Temp_refl:        ds 1
0037            103   Time_refl:        ds 1
0038            104   Run_time_seconds: ds 1
0039            105   Run_time_minutes: ds 1
003A            106   State_time:       ds 1
003B            107   Temp_oven:        ds 1
003C            108   x:                ds 4
0040            109   y:                ds 4
0044            110   bcd:              ds 5
0049            111   Result:           ds 2
004B            112   w:                ds 3
004E            113   pwm_ratio:        ds 2
0050            114   average_count:    ds 1
0051            115   
                117   $LIST
00F0            119   
                546   $LIST
                121   $LIST
0360            123   
                125   $LIST
03E7            127   
0000            128   bseg
0000            129   one_seconds_flag:  dbit 1
0001            130   five_seconds_flag: dbit 1
0002            131   enable_clk:        dbit 1
0003            132   mf:                dbit 1
0004            133   
03E7            134   cseg
03E7            135   
03E7            136   ;-------------------------------------------------------------------------------------------------------------------------------
03E7            137   ;***Messages To Display*** 
03E7            138   
03E7            139   ;shortened labels
03E7 53546D70   140   STemp:  db 'STmp:', 0
     3A00
03ED 53546D3A   141   STime:  db 'STm:', 0
     00
03F2 52546D70   142   RTemp:  db 'RTmp:', 0
     3A00
03F8 52546D3A   143   RTime:  db 'RTm:', 0
     00
03FD            144   
03FD            145   ;lables for runnning oven
03FD 53746174   146   state:     db 'State>' , 0
     653E00
0404 546D653E   147   time:      db 'Tme>' , 0
     00
0409 3A00       148   colon:     db ':', 0
040B 546D703E   149   temp:      db 'Tmp>', 0
     00
0410            150   
0410            151   ;labels for changin parameters
0410 5265666C   152   ReflowTemp:  db 'Reflow Temperature:', 0
     6F772054
     656D7065
     72617475
     72653A00
0424 5265666C   153   ReflowTime:  db 'Reflow Time:', 0
     6F772054
     696D653A
     00
0431 536F616B   154   SoakTime:    db 'Soak Time:', 0
     2054696D
     653A00
043C 536F616B   155   SoakTemp:    db 'Soak Temperature:', 0
     2054656D
     70657261
     74757265
     3A00
044E            156   
044E            157   
044E            158   ;Current State in Oven
044E 52616D70   159   Ramp2Soak: db 'Ramp-Soak' , 0
     2D536F61
     6B00
0458 536F616B   160   Soak:      db 'Soak' , 0
     00
045D 52616D70   161   Ramp2Peak: db 'Ramp-Peak' , 0
     2D506561
     6B00
0467 5265666C   162   Reflow:    db 'Reflow' , 0
     6F7700
046E 436F6F6C   163   Cooling:   db 'Cooling' , 0
     696E6700
0476            164   
0476            165   ;-------------------------------------------------------------------------------------------------------------------------------
0476            166   ;FXNS FOR THERMOWIRE
0476            167   
0476            168   ;initialize SPI 
0476            169   INI_SPI:
0476 D295       170            setb MY_MISO          ; Make MISO an input pin
0478 C294       171            clr MY_SCLK           ; Mode 0,0 default
047A 22         172            ret
047B            173   DO_SPI_G:
047B C0E0       174            push acc
047D 7900       175            mov R1, #0            ; Received byte stored in R1
047F 7A08       176            mov R2, #8            ; Loop counter (8-bits)
0481            177   DO_SPI_G_LOOP:
0481 E8         178            mov a, R0             ; Byte to write is in R0
0482 33         179            rlc a                 ; Carry flag has bit to write
0483 F8         180            mov R0, a
0484 9296       181            mov MY_MOSI, c
0486 D294       182            setb MY_SCLK          ; Transmit
0488 A295       183            mov c, MY_MISO        ; Read received bit
048A E9         184            mov a, R1             ; Save received bit in R1
048B 33         185            rlc a
048C F9         186            mov R1, a
048D C294       187            clr MY_SCLK
048F DAF0       188            djnz R2, DO_SPI_G_LOOP
0491 D0E0       189            pop acc
0493 22         190   ret
0494            191   
0494            192   Send_SPI:
                193   	SPIBIT MAC
                194   	    ; Send/Receive bit %0
                195   		rlc a
                196   		mov MY_MOSI, c
                197   		setb MY_SCLK
                198   		mov c, MY_MISO
                199   		clr MY_SCLK
                200   		mov acc.0, c
                201   	ENDMAC
0494            202            
0494            203                ; Send/Receive bit 7
0494 33         203                    rlc a
0495 9296       203                    mov MY_MOSI, c
0497 D294       203                    setb MY_SCLK
0499 A295       203                    mov c, MY_MISO
049B C294       203                    clr MY_SCLK
049D 92E0       203                    mov acc.0, c
049F            204                ; Send/Receive bit 6
049F 33         204                    rlc a
04A0 9296       204                    mov MY_MOSI, c
04A2 D294       204                    setb MY_SCLK
04A4 A295       204                    mov c, MY_MISO
04A6 C294       204                    clr MY_SCLK
04A8 92E0       204                    mov acc.0, c
04AA            205                ; Send/Receive bit 5
04AA 33         205                    rlc a
04AB 9296       205                    mov MY_MOSI, c
04AD D294       205                    setb MY_SCLK
04AF A295       205                    mov c, MY_MISO
04B1 C294       205                    clr MY_SCLK
04B3 92E0       205                    mov acc.0, c
04B5            206                ; Send/Receive bit 4
04B5 33         206                    rlc a
04B6 9296       206                    mov MY_MOSI, c
04B8 D294       206                    setb MY_SCLK
04BA A295       206                    mov c, MY_MISO
04BC C294       206                    clr MY_SCLK
04BE 92E0       206                    mov acc.0, c
04C0            207                ; Send/Receive bit 3
04C0 33         207                    rlc a
04C1 9296       207                    mov MY_MOSI, c
04C3 D294       207                    setb MY_SCLK
04C5 A295       207                    mov c, MY_MISO
04C7 C294       207                    clr MY_SCLK
04C9 92E0       207                    mov acc.0, c
04CB            208                ; Send/Receive bit 2
04CB 33         208                    rlc a
04CC 9296       208                    mov MY_MOSI, c
04CE D294       208                    setb MY_SCLK
04D0 A295       208                    mov c, MY_MISO
04D2 C294       208                    clr MY_SCLK
04D4 92E0       208                    mov acc.0, c
04D6            209                ; Send/Receive bit 1
04D6 33         209                    rlc a
04D7 9296       209                    mov MY_MOSI, c
04D9 D294       209                    setb MY_SCLK
04DB A295       209                    mov c, MY_MISO
04DD C294       209                    clr MY_SCLK
04DF 92E0       209                    mov acc.0, c
04E1            210                ; Send/Receive bit 0
04E1 33         210                    rlc a
04E2 9296       210                    mov MY_MOSI, c
04E4 D294       210                    setb MY_SCLK
04E6 A295       210                    mov c, MY_MISO
04E8 C294       210                    clr MY_SCLK
04EA 92E0       210                    mov acc.0, c
04EC            211   
04EC 22         212   ret
04ED            213   
                214   Change_8bit_Variable MAC
                215       jb %0, %2
                216       Wait_Milli_Seconds(#50) ; de-bounce
                217       jb %0, %2
                218       jnb %0, $
                219       jb SHIFT_BUTTON, skip%Mb
                220       dec %1
                221       sjmp skip%Ma
                222       skip%Mb:
                223       inc %1
                224       skip%Ma:
                225   ENDMAC
04ED            226   
04ED            227   ;Change_8bit_Variable(MY_VARIABLE_BUTTON, my_variable, loop_c)
04ED            228   ;    Set_Cursor(2, 14)
04ED            229   ;    mov a, my_variable
04ED            230   ;    lcall SendToLCD
04ED            231   ;lcall Save_Configuration
04ED            232   
04ED            233   ;-------------------------------------------------------------------------------------------------------------------------------
04ED            234   ;***FXNS For Serial Port
04ED            235   
04ED            236   ; Configure the serial port and baud rate
04ED            237   InitSerialPort:
04ED            238       ; Since the reset button bounces, we need to wait a bit before
04ED            239       ; sending messages, otherwise we risk displaying gibberish!
04ED 79DE       240       mov R1, #222
04EF 78A6       241       mov R0, #166
04F1 D8FE       242       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
04F3 D9FA       243       djnz R1, $-4 ; 22.51519us*222=4.998ms
04F5            244       ; Now we can proceed with the configuration
04F5 438780     245            orl     PCON,#0x80
04F8 759852     246            mov     SCON,#0x52
04FB 759B00     247            mov     BDRCON,#0x00
04FE 759AF4     248            mov     BRL,#BRG_VAL
0501 759B1E     249            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0504 22         250   ret
0505            251   
0505            252   
0505            253   putchar:
0505 3099FD     254       jnb TI, putchar
0508 C299       255       clr TI
050A F599       256       mov SBUF, a
050C 22         257   ret
050D            258   
050D            259   ;-------------------------------------------------------------------------------------------------------------------------------
050D            260   ;***FXNS to CHECK BUTTONS
050D            261   
050D            262   CHECK_STIME:
050D            263   
050D 208218     264       jb STIME_BUTTON, CHECK_STIME_END
0510 C002       264            push AR2
0512 7A32       264            mov R2, #50
0514 120039     264            lcall ?Wait_Milli_Seconds
0517 D002       264            pop AR2 ; de-bounce
0519 20820C     264       jb STIME_BUTTON, CHECK_STIME_END
051C 3082FD     264       jnb STIME_BUTTON, $
051F 208404     264       jb SHIFT_BUTTON, skip16b
0522 1535       264       dec Time_soak
0524 8002       264       sjmp skip16a
0526            264       skip16b:
0526 0535       264       inc Time_soak
0528            264       skip16a:
0528            265            
0528            266   CHECK_STIME_END:
0528 22         267   ret
0529            268   
0529            269   CHECK_STEMP:
0529 208318     270       jb STEMP_BUTTON, CHECK_STEMP_END
052C C002       270            push AR2
052E 7A32       270            mov R2, #50
0530 120039     270            lcall ?Wait_Milli_Seconds
0533 D002       270            pop AR2 ; de-bounce
0535 20830C     270       jb STEMP_BUTTON, CHECK_STEMP_END
0538 3083FD     270       jnb STEMP_BUTTON, $
053B 208404     270       jb SHIFT_BUTTON, skip18b
053E 1534       270       dec Temp_soak
0540 8002       270       sjmp skip18a
0542            270       skip18b:
0542 0534       270       inc Temp_soak
0544            270       skip18a:
0544            271       ;lcall Save_Configuration
0544            272            
0544            273   CHECK_STEMP_END:
0544 22         274   ret
0545            275   
0545            276   CHECK_RTIME:
0545 208418     277       jb RTIME_BUTTON, CHECK_RTIME_END
0548 C002       277            push AR2
054A 7A32       277            mov R2, #50
054C 120039     277            lcall ?Wait_Milli_Seconds
054F D002       277            pop AR2 ; de-bounce
0551 20840C     277       jb RTIME_BUTTON, CHECK_RTIME_END
0554 3084FD     277       jnb RTIME_BUTTON, $
0557 208404     277       jb SHIFT_BUTTON, skip20b
055A 1537       277       dec Time_refl
055C 8002       277       sjmp skip20a
055E            277       skip20b:
055E 0537       277       inc Time_refl
0560            277       skip20a:
0560            278   CHECK_RTIME_END:
0560 22         279   ret
0561            280   
0561            281   CHECK_RTEMP:
0561 208618     282       jb RTEMP_BUTTON, CHECK_RTEMP_END
0564 C002       282            push AR2
0566 7A32       282            mov R2, #50
0568 120039     282            lcall ?Wait_Milli_Seconds
056B D002       282            pop AR2 ; de-bounce
056D 20860C     282       jb RTEMP_BUTTON, CHECK_RTEMP_END
0570 3086FD     282       jnb RTEMP_BUTTON, $
0573 208404     282       jb SHIFT_BUTTON, skip22b
0576 1536       282       dec Temp_refl
0578 8002       282       sjmp skip22a
057A            282       skip22b:
057A 0536       282       inc Temp_refl
057C            282       skip22a:
057C            283   CHECK_RTEMP_END:
057C 22         284   ret
057D            285   
057D            286   CHECK_POWER:
057D            287   
057D 20C512     288       jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
0580 C002       289            push AR2
0582 7A32       289            mov R2, #50
0584 120039     289            lcall ?Wait_Milli_Seconds
0587 D002       289            pop AR2 ; debounce time
0589 20C506     290            jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
058C 30C5FD     291            jnb POWER_BUTTON, $ ; loop while the button is pressed
058F 12087C     292       lcall OFF_STATE
0592            293   
0592            294   CHECK_POWER_END:
0592 22         295   ret
0593            296   ;**SOUND STUFF---------------------------------------------------------------
0593            297   
0593            298   SOUND_FSM:
0593            299   state_0_sound:
0593            300   ;check if 5 seconds has passed, if yes go to state 1, if no exit function 
0593 300105     301       jnb five_seconds_flag, Sound_ret
0596 C201       302       clr five_seconds_flag
0598 02059C     303       ljmp state_1_sound
059B            304   Sound_ret:
059B 22         305       ret
059C            306   
059C            307   state_1_sound:
059C            308   ; check if temp is greater than 100, if yes go to state 2
059C            309   ; check if temp is less than 100, if yes go to state 4
059C E53B       310       mov a, Temp_oven
059E 9464       311       subb a, #100
05A0 5002       312       jnc state_2_sound
05A2 4026       313       jc state_4_sound
05A4            314   
05A4            315   state_2_sound:
05A4            316   ;divide temp by 100, if it is 1 play sound: "100", if it is 2 play sound: "200"
05A4            317   ; go to state_3_sound
05A4 75F064     318       mov b, #100
05A7 E53B       319       mov a, Temp_oven
05A9 84         320       div ab
05AA 9401       321       subb a, #1
05AC 600A       322       jz play_sound_1
05AE            323   
05AE 75F064     324       mov b, #100
05B1 E53B       325       mov a, Temp_oven
05B3 84         326       div ab
05B4 9402       327       subb a, #2
05B6 6000       328       jz play_sound_1
05B8            329      
05B8            330      play_sound_1: 
05B8 020647     331       ljmp PLAYBACK_TEMP
05BB            332   
05BB 0205BE     333       ljmp state_3_sound
05BE            334   
05BE            335   
05BE            336   state_3_sound:
05BE            337   ; check remainder of temp, if it is 0, go back to state_0_sound
05BE            338   ; if not 0, go to state_4_sound
05BE            339   
05BE 75F064     340       mov b, #100
05C1 E53B       341       mov a, Temp_oven
05C3 84         342       div ab
05C4 E5F0       343       mov a, b
05C6 60CB       344       jz state_0_sound
05C8 7000       345       jnz state_4_sound
05CA            346   
05CA            347   state_4_sound:
05CA            348   ; if T % 100 greater or equal to 20, go to state_5_sound,
05CA 75F064     349       mov b, #100
05CD E53B       350       mov a, Temp_oven
05CF 84         351       div ab
05D0 E5F0       352       mov a, b 
05D2 9414       353       subb a, #20
05D4 5011       354       jnc state_5_sound
05D6 E4         355       clr a
05D7            356   ; if T % 100 is less than 10, go to state_6_sound
05D7 75F064     357       mov b, #100
05DA E53B       358       mov a, Temp_oven
05DC 84         359       div ab
05DD E5F0       360       mov a, b
05DF 940A       361       subb a, #10
05E1 401C       362       jc state_6_sound
05E3 E4         363       clr a
05E4            364   ; if T % 100 is greater than 10 and less than 20, go to state_7_sound
05E4 020605     365       ljmp state_7_sound
05E7            366       
05E7            367   
05E7            368   state_5_sound:
05E7            369   ; play number from 20 to 90 in decades (20, 30, 40, 50, 60, 70, 80, 90), based off remainder from temp divided by 100
05E7            370   ; if (T % 100) % 10 is not equal to 0, go to state_6_sound
05E7            371   ; if (T % 100) % 10 is equal to 0, go to state_8_sound
05E7            372   
05E7 E53B       373       mov a, Temp_oven
05E9 75F064     374       mov b, #100 
05EC 84         375       div ab
05ED E5F0       376       mov a, b
05EF 75F00A     377       mov b, #10
05F2 84         378       div ab
05F3 E5F0       379       mov a, b
05F5 6002       380       jz play_sound
05F7 7006       381       jnz state_6_sound
05F9            382       
05F9            383   
05F9            384       play_sound:
05F9 020647     385           ljmp PLAYBACK_TEMP
05FC 02060B     386           ljmp state_8_sound
05FF            387   
05FF            388   
05FF            389   state_6_sound:
05FF            390   ; play 1 - 9
05FF 020647     391       ljmp PLAYBACK_TEMP
0602            392   ; go to state_8_sound
0602 02060B     393       ljmp state_8_sound
0605            394   
0605            395   
0605            396   state_7_sound:
0605            397   ; play 10 - 19
0605 020647     398       ljmp PLAYBACK_TEMP
0608            399   ; go to state_8_sound 
0608 02060B     400       ljmp state_8_sound
060B            401   
060B            402   state_8_sound:
060B            403   ; go to state_0_sound
060B 020593     404       ljmp state_0_sound
060E            405   
060E            406   
060E            407   INI_PLAYBACK_TEMP:
060E            408       ; ****INITIALIZATION****
060E            409       ; Configure SPI pins and turn off speaker
060E 53CECE     410            anl P2M0, #0b_1100_1110
0611 43CF31     411            orl P2M1, #0b_0011_0001
0614 D295       412            setb MY_MISO  ; Configured as input
0616 D280       413            setb FLASH_CE ; CS=1 for SPI flash memory
0618 C294       414            clr MY_SCLK   ; Rest state of SCLK=0
061A C2A6       415            clr SPEAKER   ; Turn off speaker.
061C            416            
061C            417            ; Configure timer 1
061C 53890F     418            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
061F 438910     419            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
0622 758DFC     420            mov TH1, #high(TIMER1_RELOAD)
0625 758B15     421            mov TL1, #low(TIMER1_RELOAD)
0628            422            ; Set autoreload value
0628 75F5FC     423            mov RH1, #high(TIMER1_RELOAD)
062B 75F315     424            mov RL1, #low(TIMER1_RELOAD)
062E            425   
062E            426            ;Enable the timer and interrupts
062E D2AB       427       setb ET1  ; Enable timer 1 interrupt
0630 D28E       428            setb TR1 ; Timer 1 is only enabled to play stored sound
0632            429   
0632            430            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
0632 75A5A0     431            mov DADI, #0b_1010_0000 ; ACON=1
0635 75A43A     432            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0638 75AD80     433            mov DADH, #0x80 ; Middle of scale
063B 75AC00     434            mov DADL, #0
063E 43A440     435            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
0641            436       check_DAC_init:
0641 E5A4       437            mov a, DADC
0643 20E6FB     438            jb acc.6, check_DAC_init ; Wait for DAC to finish
0646            439            
0646 22         440   ret
0647            441   
0647            442   PLAYBACK_TEMP:
0647            443       ; ***play audio***
0647 C28E       444       clr TR1 ; Stop Timer 1 ISR from playing previous request
0649 D280       445       setb FLASH_CE 
064B C2A6       446       clr SPEAKER ; Turn off speaker
064D            447   
064D C280       448       clr FLASH_CE ; Enable SPI Flash
064F            449       ;mov READ_BYTES, #3
064F 7403       450       mov a, #READ_BYTES
0651 120494     451       lcall Send_SPI
0654            452       ; Set the initial position in memory where to start playing
0654            453       
0654 7402       454       mov a, #0x02 ; change initial position
0656 120494     455       lcall Send_SPI
0659 74D5       456       mov a, #0xd5 ; next memory position
065B 120494     457       lcall Send_SPI 
065E 742D       458       mov a, #0x2d ; next memory position
0660 120494     459       lcall Send_SPI
0663 7402       460       mov a, #0x02 ; request first byte to send to DAC
0665 120494     461       lcall Send_SPI
0668            462   
0668            463       ; How many bytes to play?
0668 754D00     464       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
066B 754C39     465       mov w+1, #0x39 ; Load the middle byte of the number of bytes to play
066E 754B6A     466       mov w+0, #0x6a ; Load the low byte of the number of bytes to play
0671            467    
0671 D2A6       468       setb SPEAKER ;Turn on speaker
0673 D28E       469       setb TR1 ;Start playback by enabling Timer1 
0675 22         470       ret
0676            471       
0676            472   ;-------------------------------------------------------------------------------------------------------------------------------
0676            473   ;***LCD FXNS
0676            474   
                475   Display_lower_BCD mac
                476       push ar0
                477       mov r0, %0
                478       lcall ?Display_lower_BCD
                479       pop ar0
                480   endmac
0676            481   
0676            482   ?Display_lower_BCD:
0676 C0E0       483       push acc
0678            484       ; write least significant digit
0678 E8         485       mov a, r0
0679 540F       486       anl a, #0fh
067B 4430       487       orl a, #30h
067D 12007E     488       lcall ?WriteData
0680 D0E0       489       pop acc
0682 22         490   ret
0683            491   
0683            492   
0683            493   SendToLCD:
0683 75F064     494       mov b, #100
0686 84         495       div ab
0687 4430       496       orl a, #0x30h ; Convert hundreds to ASCII
0689 12007E     497       lcall ?WriteData ; Send to LCD
068C E5F0       498       mov a, b    ; Remainder is in register b
068E 75F00A     499       mov b, #10
0691 84         500       div ab
0692 4430       501       orl a, #0x30h ; Convert tens to ASCII
0694 12007E     502       lcall ?WriteData; Send to LCD
0697 E5F0       503       mov a, b
0699 4430       504       orl a, #0x30h ; Convert units to ASCII
069B 12007E     505       lcall ?WriteData; Send to LCD
069E 22         506   ret
069F            507   
069F            508   Initialize_State_Display:
069F            509   
069F            510       ;***clear the screen and set new display***
069F 7401       511            mov a, #0x01
06A1 120083     511            lcall ?WriteCommand
06A4 C002       512            push AR2
06A6 7A02       512            mov R2, #2
06A8 120039     512            lcall ?Wait_Milli_Seconds
06AB D002       512            pop AR2
06AD            513       
06AD C0E0       514            push acc
06AF 7401       514            mov a, #1
06B1 14         514            dec a
06B2 1200BF     514            lcall ?Set_Cursor_1 ; Select column and row
06B5 D0E0       514            pop acc
06B7 C083       515            push dph
06B9 C082       515            push dpl
06BB C0E0       515            push acc
06BD 900404     515            mov dptr, #time
06C0 1200B2     515            lcall ?Send_Constant_String
06C3 D0E0       515            pop acc
06C5 D082       515            pop dpl
06C7 D083       515            pop dph
06C9            516            
06C9 C0E0       517            push acc
06CB 7406       517            mov a, #6
06CD 14         517            dec a
06CE 1200BF     517            lcall ?Set_Cursor_1 ; Select column and row
06D1 D0E0       517            pop acc
06D3 C083       518            push dph
06D5 C082       518            push dpl
06D7 C0E0       518            push acc
06D9 900409     518            mov dptr, #colon
06DC 1200B2     518            lcall ?Send_Constant_String
06DF D0E0       518            pop acc
06E1 D082       518            pop dpl
06E3 D083       518            pop dph
06E5            519      
06E5 C0E0       520            push acc
06E7 740A       520            mov a, #10
06E9 14         520            dec a
06EA 1200BF     520            lcall ?Set_Cursor_1 ; Select column and row
06ED D0E0       520            pop acc
06EF C083       521            push dph
06F1 C082       521            push dpl
06F3 C0E0       521            push acc
06F5 90040B     521            mov dptr, #temp
06F8 1200B2     521            lcall ?Send_Constant_String
06FB D0E0       521            pop acc
06FD D082       521            pop dpl
06FF D083       521            pop dph
0701            522       
0701 C0E0       523            push acc
0703 7401       523            mov a, #1
0705 14         523            dec a
0706 1200BD     523            lcall ?Set_Cursor_2 ; Select column and row
0709 D0E0       523            pop acc
070B C083       524            push dph
070D C082       524            push dpl
070F C0E0       524            push acc
0711 9003FD     524            mov dptr, #state
0714 1200B2     524            lcall ?Send_Constant_String
0717 D0E0       524            pop acc
0719 D082       524            pop dpl
071B D083       524            pop dph
071D 22         525   ret
071E            526   
071E            527   Update_Display:
071E C0E0       528            push acc
0720 7405       528            mov a, #5
0722 14         528            dec a
0723 1200BF     528            lcall ?Set_Cursor_1 ; Select column and row
0726 D0E0       528            pop acc
0728 C000       529       push ar0
072A A839       529       mov r0, Run_time_minutes
072C 120676     529       lcall ?Display_lower_BCD
072F D000       529       pop ar0
0731 C0E0       530            push acc
0733 7407       530            mov a, #7
0735 14         530            dec a
0736 1200BF     530            lcall ?Set_Cursor_1 ; Select column and row
0739 D0E0       530            pop acc
073B C000       531            push ar0
073D A838       531            mov r0, Run_time_seconds
073F 1200C4     531            lcall ?Display_BCD
0742 D000       531            pop ar0
0744            532       ;Set_Cursor(1,14)
0744            533       ;mov a, Temp_oven
0744            534       ;SendToLCD(Temp_oven)
0744 22         535   ret
0745            536   
0745            537   State0_display:
0745 C0E0       538            push acc
0747 7401       538            mov a, #1
0749 14         538            dec a
074A 1200BF     538            lcall ?Set_Cursor_1 ; Select column and row
074D D0E0       538            pop acc
074F C083       539            push dph
0751 C082       539            push dpl
0753 C0E0       539            push acc
0755 9003E7     539            mov dptr, #STemp
0758 1200B2     539            lcall ?Send_Constant_String
075B D0E0       539            pop acc
075D D082       539            pop dpl
075F D083       539            pop dph
0761 C0E0       540            push acc
0763 7406       540            mov a, #6
0765 14         540            dec a
0766 1200BF     540            lcall ?Set_Cursor_1 ; Select column and row
0769 D0E0       540            pop acc
076B E534       541       mov a, Temp_soak
076D 120683     542       lcall SendToLCD
0770            543       
0770 C0E0       544            push acc
0772 740A       544            mov a, #10
0774 14         544            dec a
0775 1200BF     544            lcall ?Set_Cursor_1 ; Select column and row
0778 D0E0       544            pop acc
077A C083       545            push dph
077C C082       545            push dpl
077E C0E0       545            push acc
0780 9003ED     545            mov dptr, #STime
0783 1200B2     545            lcall ?Send_Constant_String
0786 D0E0       545            pop acc
0788 D082       545            pop dpl
078A D083       545            pop dph
078C C0E0       546            push acc
078E 740E       546            mov a, #14
0790 14         546            dec a
0791 1200BF     546            lcall ?Set_Cursor_1 ; Select column and row
0794 D0E0       546            pop acc
0796 E535       547       mov a, Time_soak
0798 120683     548            lcall SendToLCD
079B            549       ;Display_BCD(Time_soak)
079B            550   
079B            551       ;Displays Reflow Temp and Time
079B C0E0       552            push acc
079D 7401       552            mov a, #1
079F 14         552            dec a
07A0 1200BD     552            lcall ?Set_Cursor_2 ; Select column and row
07A3 D0E0       552            pop acc
07A5 C083       553            push dph
07A7 C082       553            push dpl
07A9 C0E0       553            push acc
07AB 9003F2     553            mov dptr, #RTemp
07AE 1200B2     553            lcall ?Send_Constant_String
07B1 D0E0       553            pop acc
07B3 D082       553            pop dpl
07B5 D083       553            pop dph
07B7 C0E0       554            push acc
07B9 7406       554            mov a, #6
07BB 14         554            dec a
07BC 1200BD     554            lcall ?Set_Cursor_2 ; Select column and row
07BF D0E0       554            pop acc
07C1 E536       555       mov a, Temp_refl
07C3 120683     556       lcall SendToLCD
07C6            557       
07C6 C0E0       558            push acc
07C8 740A       558            mov a, #10
07CA 14         558            dec a
07CB 1200BD     558            lcall ?Set_Cursor_2 ; Select column and row
07CE D0E0       558            pop acc
07D0 C083       559            push dph
07D2 C082       559            push dpl
07D4 C0E0       559            push acc
07D6 9003F8     559            mov dptr, #RTime
07D9 1200B2     559            lcall ?Send_Constant_String
07DC D0E0       559            pop acc
07DE D082       559            pop dpl
07E0 D083       559            pop dph
07E2 C0E0       560            push acc
07E4 740E       560            mov a, #14
07E6 14         560            dec a
07E7 1200BD     560            lcall ?Set_Cursor_2 ; Select column and row
07EA D0E0       560            pop acc
07EC E537       561       mov a, Time_refl
07EE 120683     562            lcall SendToLCD
07F1 22         563   ret
07F2            564   
07F2            565   Display_3_digit_BCD:
07F2 C0E0       566            push acc
07F4 740E       566            mov a, #14
07F6 14         566            dec a
07F7 1200BF     566            lcall ?Set_Cursor_1 ; Select column and row
07FA D0E0       566            pop acc
07FC C000       567       push ar0
07FE A845       567       mov r0, bcd+1
0800 120676     567       lcall ?Display_lower_BCD
0803 D000       567       pop ar0
0805 C000       568            push ar0
0807 A844       568            mov r0, bcd+0
0809 1200C4     568            lcall ?Display_BCD
080C D000       568            pop ar0
080E 22         569   ret
080F            570   
080F            571   
080F            572   ;The following functions store and restore the values--------------------------------------------------------------------------
                573   loadbyte mac
                574       mov a, %0
                575       movx @dptr, a
                576       inc dptr
                577   endmac
080F            578   
080F            579   Save_Configuration:
080F C0A8       580       push IE ; Save the current state of bit EA in the stack
0811 C2AF       581       clr EA ; Disable interrupts
0813 75D108     582       mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
0816 907F80     583       mov dptr, #0x7f80 ; Last page of flash memory
0819            584       ; Save variables
0819 E534       585       mov a, temp_soak
081B F0         585       movx @dptr, a
081C A3         585       inc dptr ; @0x7f80
081D E535       586       mov a, time_soak
081F F0         586       movx @dptr, a
0820 A3         586       inc dptr ; @0x7f81
0821 E536       587       mov a, temp_refl
0823 F0         587       movx @dptr, a
0824 A3         587       inc dptr ; @0x7f82
0825 E537       588       mov a, time_refl
0827 F0         588       movx @dptr, a
0828 A3         588       inc dptr ; @0x7f83
0829 7455       589       mov a, #0x55
082B F0         589       movx @dptr, a
082C A3         589       inc dptr ; First key value @0x7f84
082D 74AA       590       mov a, #0xAA
082F F0         590       movx @dptr, a
0830 A3         590       inc dptr ; Second key value @0x7f85
0831 75D100     591       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0) 
0834 43D240     592       orl EECON, #0b01000000 ; Enable auto-erase on next write sequence  
0837 75D150     593       mov FCON, #0x50 ; Write trigger first byte
083A 75D1A0     594       mov FCON, #0xA0 ; Write trigger second byte
083D            595       ; CPU idles until writing of flash completes.
083D 75D100     596       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
0840 53D2BF     597       anl EECON, #0b10111111 ; Disable auto-erase
0843 D0A8       598       pop IE ; Restore the state of bit EA from the stack
0845 22         599   ret
0846            600   
                601   getbyte mac
                602       clr a
                603       movc a, @a+dptr
                604       mov %0, a
                605       inc dptr
                606   endmac
0846            607   
0846            608   Load_Configuration:
0846 907F84     609       mov dptr, #0x7f84 ; First key value location.
0849 E4         610       clr a
084A 93         610       movc a, @a+dptr
084B F8         610       mov R0, a
084C A3         610       inc dptr ; 0x7f84 should contain 0x55
084D B8551F     611       cjne R0, #0x55, Load_Defaults
0850 E4         612       clr a
0851 93         612       movc a, @a+dptr
0852 F8         612       mov R0, a
0853 A3         612       inc dptr ; 0x7f85 should contain 0xAA
0854 B8AA18     613       cjne R0, #0xAA, Load_Defaults
0857            614   ; Keys are good.  Get stored values.
0857 907F80     615       mov dptr, #0x7f80
085A E4         616       clr a
085B 93         616       movc a, @a+dptr
085C F534       616       mov Temp_soak, a
085E A3         616       inc dptr ; 0x7f80
085F E4         617       clr a
0860 93         617       movc a, @a+dptr
0861 F535       617       mov Time_soak, a
0863 A3         617       inc dptr ; 0x7f81
0864 E4         618       clr a
0865 93         618       movc a, @a+dptr
0866 F536       618       mov Temp_refl, a
0868 A3         618       inc dptr ; 0x7f82
0869 E4         619       clr a
086A 93         619       movc a, @a+dptr
086B F537       619       mov Time_refl, a
086D A3         619       inc dptr ; 0x7f83
086E 22         620   ret
086F            621   
086F            622   Load_Defaults:
086F 753482     623       mov Temp_soak, #130 ; Soak Tmp Range is 130-170
0872 75353C     624       mov Time_soak, #0x3C ; Range 60-90 seconds
0875 7536DC     625       mov Temp_refl, #220 ; Range 220-240
0878 75371E     626       mov Time_refl, #0x1E ; Range 30-45 seconds
087B 22         627       ret 
087C            628   ;-------------------------------------------------------------------------------------------------------------------------------
087C            629   ;off state
087C            630   
087C            631   OFF_STATE:
087C            632       ;**CLEAR SCREEN**
087C 7401       633            mov a, #0x01
087E 120083     633            lcall ?WriteCommand
0881            634       ;**TURN OFF OVEN
0881 C287       635       clr OVEN_POWER
0883            636       ;OFF_STATE1:
0883            637       
0883 20C5FD     638       jb POWER_BUTTON, $ ; loop while the button is not pressed
0886 C002       639            push AR2
0888 7A32       639            mov R2, #50
088A 120039     639            lcall ?Wait_Milli_Seconds
088D D002       639            pop AR2 ; debounce time
088F 20C5EA     640            jb POWER_BUTTON, OFF_STATE ; it was a bounce, try again
0892 30C5FD     641            jnb POWER_BUTTON, $ ; loop while the button is pressed
0895 020A21     642       ljmp main
0898 22         643   ret
0899            644   ;-------------------------------------------------------------------------------------------------------------------------------
0899            645   
0899            646   ;***CHECK TEMPERATURE BY READING VOLTAGE AND CONVERTING
0899            647   Check_Temp:
0899            648       
0899            649       ;jnb one_seconds_flag, Check_Temp_done
0899            650       ;clr one_seconds_flag
0899            651       
0899 C297       652       clr CE_ADC
089B 7801       653            mov R0, #00000001B ; Start bit:1
089D 12047B     654            lcall DO_SPI_G
08A0 7880       655            mov R0, #10000000B ; Single ended, read channel 0
08A2 12047B     656            lcall DO_SPI_G
08A5 E9         657            mov a, R1          ; R1 contains bits 8 and 9
08A6 5403       658            anl a, #00000011B  ; We need only the two least significant bits
08A8 F54A       659            mov Result+1, a    ; Save result high.
08AA 7855       660            mov R0, #55H ; It doesn't matter what we transmit...
08AC 12047B     661            lcall DO_SPI_G
08AF 8949       662            mov Result+0, R1     ; R1 contains bits 0 to 7.  Save result low.
08B1 D297       663            setb CE_ADC
08B3            664   
08B3 C002       665            push AR2
08B5 7A0A       665            mov R2, #10
08B7 120039     665            lcall ?Wait_Milli_Seconds
08BA D002       665            pop AR2
08BC            666       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
08BC AE49       667            mov R6, Result+0
08BE AF4A       668            mov R7, Result+1
08C0 22         669   ret
08C1            670   
08C1            671            
08C1            672       ;mov x+2, #0
08C1            673            ;mov x+3, #0
08C1            674            
08C1            675       
08C1            676           ;Load_x(0)
08C1            677           ;mov a, #50
08C1            678       ;calculate_ave:     
08C1            679           ;mov y+0, result+0
08C1            680                ;mov y+1, result+1
08C1            681                ;mov y+2, #0
08C1            682                ;mov y+3, #0
08C1            683       ;djnz a, calculate_ave
08C1            684   
08C1            685   
08C1            686   
08C1            687   
08C1            688       ;Load_y(22)
08C1            689       ;lcall add32
08C1            690   
08C1            691   ;Check_Temp_done_2:
08C1            692       ;jnb one_seconds_flag, Check_Temp_done
08C1            693       ;mov a, result+1
08C1            694       ;Set_Cursor(1,14)
08C1            695       ;lcall SendToLCD 
08C1            696       ;Set_Cursor(1,14)
08C1            697       ;mov a, x+0
08C1            698       ;lcall SendToLCD
08C1            699       ;mov Temp_oven, a
08C1            700       
08C1            701       ;mov a, States
08C1            702       ;cjne a, #0, Display_Temp_BCD
08C1            703       ;sjmp Send_Temp_Port
08C1            704            
08C1            705       ; The 4-bytes of x have the temperature in binary
08C1            706   
08C1            707       ;mov Temp_oven, x+0 ;save the temperature
08C1            708   
08C1            709   ;Display_Temp_BCD:
08C1            710   ;        lcall hex2bcd ; converts binary in x to BCD in BCD
08C1            711   
08C1            712   ;    lcall Display_3_digit_BCD
08C1            713   
08C1            714   ;Send_Temp_Port:
08C1            715   ;    Send_BCD(bcd+4)
08C1            716   ;    Send_BCD(bcd+3)
08C1            717   ;    Send_BCD(bcd+2)
08C1            718   ;        Send_BCD(bcd+1)
08C1            719   ;    Send_BCD(bcd+0);
08C1            720   ;        mov a, #'\r'
08C1            721   ;        lcall putchar
08C1            722   ;        mov a, #'\n'
08C1            723   ;        lcall putchar
08C1            724   ;Check_Temp_done:
08C1            725   ;ret
08C1            726       
08C1            727   ;***CALCULATES THE TEMPERATURE
08C1            728   Average_Temp:
08C1 753C00     729            mov x+0, #low (0 % 0x10000) 
08C4 753D00     729            mov x+1, #high(0 % 0x10000) 
08C7 753E00     729            mov x+2, #low (0 / 0x10000) 
08CA 753F00     729            mov x+3, #high(0 / 0x10000) 
08CD 7D64       730       mov R5, #100
08CF            731   Ave_loop:
08CF 120899     732       lcall Check_Temp
08D2 754300     733       mov y+3, #0
08D5 754200     734       mov y+2, #0
08D8 8F41       735       mov y+1, R7
08DA 8E40       736       mov y+0, R6
08DC 1201B5     737       lcall add32
08DF 12096B     738       lcall Wait10us
08E2 DDEB       739       djnz R5, Ave_Loop
08E4 754064     740            mov y+0, #low (100 % 0x10000) 
08E7 754100     740            mov y+1, #high(100 % 0x10000) 
08EA 754200     740            mov y+2, #low (100 / 0x10000) 
08ED 754300     740            mov y+3, #high(100 / 0x10000) 
08F0 1202F7     741       lcall div32
08F3            742   
08F3            743       ;**INSERT MATH FUNCTIONS
08F3            744   
08F3 7540EA     745            mov y+0, #low (2026 % 0x10000) 
08F6 754107     745            mov y+1, #high(2026 % 0x10000) 
08F9 754200     745            mov y+2, #low (2026 / 0x10000) 
08FC 754300     745            mov y+3, #high(2026 / 0x10000) 
08FF 12026A     746            lcall mul32
0902 754058     747            mov y+0, #low (7000 % 0x10000) 
0905 75411B     747            mov y+1, #high(7000 % 0x10000) 
0908 754200     747            mov y+2, #low (7000 / 0x10000) 
090B 754300     747            mov y+3, #high(7000 / 0x10000) 
090E 1202F7     748            lcall div32
0911 754016     749            mov y+0, #low (22 % 0x10000) 
0914 754100     749            mov y+1, #high(22 % 0x10000) 
0917 754200     749            mov y+2, #low (22 / 0x10000) 
091A 754300     749            mov y+3, #high(22 / 0x10000) 
091D 1201B5     750       lcall add32
0920 853C3B     751       mov Temp_oven, x+0
0923            752   
0923            753   Display_Temp_BCD:
0923 1200F0     754            lcall hex2bcd ; converts binary in x to BCD in BCD
0926            755   
0926 1207F2     756       lcall Display_3_digit_BCD
0929            757   
0929            758   Send_Temp_Port:
0929            759       ;Send_BCD(bcd+4)
0929            760       ;Send_BCD(bcd+3)
0929            761       ;Send_BCD(bcd+2)
0929 C000       762       push ar0
092B A845       762       mov r0, bcd+1
092D 1200DA     762       lcall ?Send_BCD
0930 D000       762       pop ar0
0932            762   
0932 C000       763       push ar0
0934 A844       763       mov r0, bcd+0
0936 1200DA     763       lcall ?Send_BCD
0939 D000       763       pop ar0
093B            763   
093B 740D       764            mov a, #'\r'
093D 120505     765            lcall putchar
0940 740A       766            mov a, #'\n'
0942 120505     767            lcall putchar
0945            768   Check_Temp_done:
0945 22         769   ret    
0946            770   
0946            771   ;-------------------------------------------------------------------------------------------------------------------------------
0946            772   
0946            773   ;Time wait
0946            774   
0946            775   Wait_One_Second:
0946 C002       776            push AR2
0948 7AFA       776            mov R2, #250
094A 120039     776            lcall ?Wait_Milli_Seconds
094D D002       776            pop AR2
094F C002       777            push AR2
0951 7AFA       777            mov R2, #250
0953 120039     777            lcall ?Wait_Milli_Seconds
0956 D002       777            pop AR2
0958 C002       778            push AR2
095A 7AFA       778            mov R2, #250
095C 120039     778            lcall ?Wait_Milli_Seconds
095F D002       778            pop AR2
0961 C002       779            push AR2
0963 7AFA       779            mov R2, #250
0965 120039     779            lcall ?Wait_Milli_Seconds
0968 D002       779            pop AR2
096A 22         780   ret
096B            781   
096B            782   Wait10us:
096B 784A       783       mov R0, #74
096D D8FE       784       djnz R0, $
096F 22         785   ret
0970            786   ; ==================================================================================================
0970            787   
0970            788   ;-------------------------------------;
0970            789   ; ISR for Timer 1.  Used to playback  ;
0970            790   ; the WAV file stored in the SPI      ;
0970            791   ; flash memory.                       ;
0970            792   ;-------------------------------------;
0970            793   Timer1_ISR:
0970            794            ; The registers used in the ISR must be saved in the stack
0970 C0E0       795            push acc
0972 C0D0       796            push psw
0974            797            
0974            798            ; Check if the play counter is zero.  If so, stop playing sound.
0974 E54B       799            mov a, w+0
0976 454C       800            orl a, w+1
0978 454D       801            orl a, w+2
097A 601E       802            jz stop_playing
097C            803            
097C            804            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
097C 74FF       805            mov a, #0xff
097E 154B       806            dec w+0
0980 B54B07     807            cjne a, w+0, keep_playing
0983 154C       808            dec w+1
0985 B54C02     809            cjne a, w+1, keep_playing
0988 154D       810            dec w+2
098A            811            
098A            812   keep_playing:
098A D2A6       813            setb SPEAKER
098C 120494     814            lcall Send_SPI ; Read the next byte from the SPI Flash...
098F F580       815            mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
0991 2480       816            add a, #0x80
0993 F5AD       817            mov DADH, a ; Output to DAC. DAC output is pin P2.3
0995 43A440     818            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0998 800A       819            sjmp Timer1_ISR_Done
099A            820   
099A            821   stop_playing:
099A C28E       822            clr TR1 ; Stop timer 1
099C            823            ;setb FLASH_CE  ; Disable SPI Flash
099C C2A6       824            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
099E 75AD80     825            mov DADH, #0x80 ; middle of range
09A1 43A440     826            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
09A4            827   
09A4            828   Timer1_ISR_Done:         
09A4 D0D0       829            pop psw
09A6 D0E0       830            pop acc
09A8 32         831            reti
09A9            832   ; ==================================================================================================
09A9            833   
09A9            834   ;---------------------------------;
09A9            835   ; Routine to initialize the ISR   ;
09A9            836   ; for timer 2                     ;
09A9            837   ;---------------------------------;
09A9            838   Timer2_init:
09A9 75C800     839       mov T2CON, #0
09AC 75CDA9     840       mov TH2, #high(TIMER2_RELOAD)
09AF 75CC9A     841       mov TL2, #low(TIMER2_RELOAD)
09B2            842   
09B2 75CBA9     843       mov RCAP2H, #high(TIMER2_RELOAD)
09B5 75CA9A     844       mov RCAP2L, #low(TIMER2_RELOAD)
09B8            845   
09B8 E4         846       clr a
09B9 F530       847       mov Count1ms+0, a
09BB F531       848       mov Count1ms+1, a
09BD F532       849       mov Count5sec , a
09BF D2AD       850       setb ET2
09C1 D2CA       851       setb TR2
09C3 C202       852       clr enable_clk
09C5 22         853       ret
09C6            854   
09C6            855   ;---------------------------------;
09C6            856   ; ISR for timer 2                 ;
09C6            857   ;---------------------------------;
09C6            858   Timer2_ISR:
09C6 C2CF       859       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
09C8 B290       860       cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
09CA            861            
09CA            862            ; The two registers used in the ISR must be saved in the stack
09CA C0E0       863       push acc
09CC C0D0       864       push psw
09CE            865            
09CE            866            ; Increment the 16-bit one mili second counter
09CE 0530       867            inc Count1ms+0    ; Increment the low 8-bits first
09D0 E530       868            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
09D2 7002       869            jnz Inc_Done
09D4 0531       870            inc Count1ms+1
09D6            871   
09D6            872   Inc_Done:
09D6            873   
09D6            874   ;**Oven Power Output-------------------
09D6            875       ; Do the PWM thing
09D6            876            ; Check if Count1ms > pwm_ratio (this is a 16-bit compare)
09D6 C3         877            clr c
09D7 E54E       878            mov a, pwm_ratio+0
09D9 9530       879            subb a, Count1ms+0
09DB E54F       880            mov a, pwm_ratio+1
09DD 9531       881            subb a, Count1ms+1
09DF            882            ; if Count1ms > pwm_ratio  the carry is set.  Just copy the carry to the pwm output pin:
09DF 9290       883            mov PWM_OUTPUT, c
09E1            884   ;**----------------------------------
09E1            885            ; Check if one second has passed
09E1 E530       886            mov a, Count1ms+0
09E3 B4E836     887            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
09E6 E531       888            mov a, Count1ms+1
09E8 B40331     889            cjne a, #high(1000), Timer2_ISR_done
09EB            890            
09EB            891            ; 1000 milliseconds have passed.  Set a flag so the main program knows
09EB D200       892            setb one_seconds_flag ; Let the main program know one second had passed
09ED            893       
09ED 0532       894       inc Count5sec
09EF E532       895       mov a, Count5sec
09F1 B40505     896       cjne a, #5, Set_5sec_flag_done
09F4 D201       897       setb five_seconds_flag
09F6 E4         898       clr a
09F7 F532       899       mov Count5sec, a
09F9            900       
09F9            901   Set_5sec_flag_done:
09F9 E4         902            clr a
09FA F530       903            mov Count1ms+0, a
09FC F531       904            mov Count1ms+1, a
09FE            905   
09FE 30021B     906       jnb enable_clk, Timer2_ISR_done ;if the clk is enabled, increment the second. Otherwise skip
0A01            907   ; Increment the run time counter and state time counter
0A01 E538       908            mov a, Run_time_seconds
0A03 2401       909            add a, #0x01
0A05 D4         910            da a
0A06 F538       911       mov Run_time_seconds, a
0A08            912       ;check sec overflow
0A08 B4600A     913       cjne a, #0x60, Check_sec_overflow_done
0A0B 753800     914       mov Run_time_seconds, #0x00
0A0E E539       915       mov a, Run_time_minutes ;inc min
0A10 2401       916       add a, #1
0A12 D4         917       da a
0A13 F539       918       mov Run_time_minutes, a
0A15            919   Check_sec_overflow_done:
0A15 E53A       920            mov a, State_time
0A17 2401       921            add a, #0x01
0A19 D4         922            da a
0A1A F53A       923            mov State_time, a
0A1C            924   Timer2_ISR_done:
0A1C D0D0       925            pop psw
0A1E D0E0       926            pop acc
0A20 32         927            reti
0A21            928   
0A21            929   
0A21            930   ; ==================================================================================================
0A21            931   
0A21            932   main:
0A21 75817F     933       mov SP, #0x7F
0A24 1209A9     934       lcall Timer2_Init
0A27            935       ;lcall INI_SPI
0A27 120088     936       lcall LCD_4BIT
0A2A 1204ED     937       lcall InitSerialPort
0A2D 12060E     938       lcall INI_PLAYBACK_TEMP
0A30            939       ; In case you decide to use the pins of P0, configure the port in bidirectional mode. Can be ignored
0A30 75E600     940       mov P0M0, #0
0A33 75E700     941       mov P0M1, #0
0A36 D2AF       942       setb EA   ;Enable global enterupt
0A38            943   
0A38 120846     944       lcall Load_Configuration
0A3B            945   
0A3B            946       ;lcall PLAYBACK_TEMP
0A3B            947   
0A3B            948       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0A3B 754E00     949            mov pwm_ratio+0, #low(0)
0A3E 754F00     950            mov pwm_ratio+1, #high(0)
0A41 753300     951       mov States, #0
0A44            952       
0A44            953   state0: ; idle
0A44            954       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0A44 754E00     955            mov pwm_ratio+0, #low(0)
0A47 754F00     956            mov pwm_ratio+1, #high(0)
0A4A            957       ;mov States, #0
0A4A            958   
0A4A            959   ;***initial parameters displayed***
0A4A            960       
0A4A            961       ;Displays Soak Temp and Time
0A4A 120745     962       lcall State0_display
0A4D            963       ;check power on
0A4D 12057D     964       lcall CHECK_POWER
0A50            965       ; check the parameters being pressed
0A50 12050D     966       lcall CHECK_STIME
0A53 120529     967       lcall CHECK_STEMP
0A56 120545     968       lcall CHECK_RTIME
0A59 120561     969       lcall CHECK_RTEMP
0A5C 12080F     970       lcall Save_Configuration
0A5F            971       
0A5F            972       ;lcall Check_Temp
0A5F            973   
0A5F 2085E2     974       jb NEXT_STATE_BUTTON, state0
0A62 C002       975            push AR2
0A64 7A32       975            mov R2, #50
0A66 120039     975            lcall ?Wait_Milli_Seconds
0A69 D002       975            pop AR2 ; debounce time
0A6B 2085D6     976            jb NEXT_STATE_BUTTON, state0 ; if button not pressed, loop
0A6E 3085FD     977            jnb NEXT_STATE_BUTTON, $
0A71            978   state0_done:
0A71 753301     979       mov States, #1
0A74 753A00     980       mov State_time, #0
0A77 D202       981       setb enable_clk
0A79            982      
0A79            983        
0A79            984   
0A79            985   state1_beginning:
0A79            986       
0A79            987       ;Start Run Time
0A79 753800     988       mov Run_time_seconds, #0 ; time starts at 0:00
0A7C 753900     989       mov Run_time_minutes, #0
0A7F            990   
0A7F            991       ;***clear the screen and set new display***
0A7F 12069F     992       lcall Initialize_State_Display
0A82 C0E0       993            push acc
0A84 7407       993            mov a, #7
0A86 14         993            dec a
0A87 1200BD     993            lcall ?Set_Cursor_2 ; Select column and row
0A8A D0E0       993            pop acc
0A8C C083       994            push dph
0A8E C082       994            push dpl
0A90 C0E0       994            push acc
0A92 90044E     994            mov dptr, #Ramp2Soak
0A95 1200B2     994            lcall ?Send_Constant_String
0A98 D0E0       994            pop acc
0A9A D082       994            pop dpl
0A9C D083       994            pop dph; displays current state
0A9E            995   
0A9E            996       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0A9E 754EE8     997            mov pwm_ratio+0, #low(1000)
0AA1 754F03     998            mov pwm_ratio+1, #high(1000)
0AA4            999       
0AA4           1000   
0AA4           1001   state1: ; ramp to soak
0AA4           1002       
0AA4           1003       
0AA4           1004       ;check power on
0AA4 12057D    1005       lcall CHECK_POWER
0AA7           1006       
0AA7           1007       ;Update Time and Temp
0AA7 12071E    1008       lcall Update_Display
0AAA           1009       
0AAA           1010       ;lcall Check_Temp
0AAA           1011   
0AAA 1208C1    1012       lcall Average_Temp
0AAD           1013       
0AAD           1014       ;jnb one_seconds_flag, Check_Temp_done1
0AAD           1015       ;clr one_seconds_flag
0AAD           1016       
0AAD           1017       ;clr CE_ADC
0AAD           1018            ;mov R0, #00000001B ; Start bit:1
0AAD           1019            ;lcall DO_SPI_G
0AAD           1020            ;mov R0, #10000000B ; Single ended, read channel 0
0AAD           1021            ;lcall DO_SPI_G
0AAD           1022            ;mov a, R1          ; R1 contains bits 8 and 9
0AAD           1023            ;anl a, #00000011B  ; We need only the two least significant bits
0AAD           1024            ;mov Result+1, a    ; Save result high.
0AAD           1025            ;mov R0, #55H ; It doesn't matter what we transmit...
0AAD           1026            ;lcall DO_SPI_G
0AAD           1027            ;mov Result+0, R1     ; R1 contains bits 0 to 7.  Save result low.
0AAD           1028            ;setb CE_ADC
0AAD           1029   
0AAD           1030            ;Wait_Milli_Seconds(#10)
0AAD           1031       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
0AAD           1032            ;mov x+0, Result+0
0AAD           1033            ;mov x+1, Result+1
0AAD           1034   
0AAD           1035       ;Load_y(22)
0AAD           1036       ;lcall add32
0AAD           1037   
0AAD           1038   ;Check_Temp_done_2:
0AAD           1039       ;jnb one_seconds_flag, Check_Temp_done
0AAD           1040       ;mov a, result+1
0AAD           1041       ;Set_Cursor(1,14)
0AAD           1042       ;lcall SendToLCD 
0AAD           1043       ;Set_Cursor(1,14)
0AAD           1044       ;mov a, x+0
0AAD           1045       ;lcall SendToLCD
0AAD           1046       ;mov Temp_oven, a
0AAD           1047       
0AAD           1048       ;mov a, States
0AAD           1049       ;cjne a, #0, Display_Temp_BCD
0AAD           1050       ;sjmp Send_Temp_Port
0AAD           1051            
0AAD           1052       ; The 4-bytes of x have the temperature in binary
0AAD           1053   ;Display_Temp_BCD1:
0AAD 1200F0    1054            lcall hex2bcd ; converts binary in x to BCD in BCD
0AB0           1055   
0AB0 1207F2    1056       lcall Display_3_digit_BCD
0AB3           1057   
0AB3 8003      1058       sjmp Send_Temp_Port1
0AB5           1059   
0AB5           1060   state1_1:
0AB5 020AA4    1061       ljmp state1
0AB8           1062   
0AB8           1063   Send_Temp_Port1:
0AB8           1064       ;Send_BCD(bcd+4)
0AB8           1065       ;Send_BCD(bcd+3)
0AB8           1066       ;Send_BCD(bcd+2)
0AB8           1067            ;Send_BCD(bcd+1)
0AB8           1068       ;Send_BCD(bcd+0)
0AB8           1069            ;mov a, #'\r'
0AB8           1070            ;lcall putchar
0AB8           1071            ;mov a, #'\n'
0AB8           1072            ;lcall putchar
0AB8           1073   Check_Temp_done1:
0AB8           1074       
0AB8           1075   
0AB8           1076       ; check if temp is below 150 
0AB8           1077       ;MOV A, Temp_soak           
0AB8           1078       ;SUBB A, Temp_oven
0AB8           1079       ;JNC state1_done    ; if greater, jump to state 2
0AB8           1080       ;JZ state1_done ; if equal to, jump to state 2
0AB8           1081       ;JC state1 ; if less than, go back to state1
0AB8           1082   
0AB8           1083   ;*Checking moving to states with buttons---- 
0AB8           1084   ;*Will remove after proper temperature reading----
0AB8           1085   
0AB8 2085FA    1086       jb NEXT_STATE_BUTTON, state1_1
0ABB C002      1087            push AR2
0ABD 7A32      1087            mov R2, #50
0ABF 120039    1087            lcall ?Wait_Milli_Seconds
0AC2 D002      1087            pop AR2 ; debounce time
0AC4 2085EE    1088            jb NEXT_STATE_BUTTON, state1_1 ; if button not pressed, loop
0AC7 3085FD    1089            jnb NEXT_STATE_BUTTON, $ 
0ACA           1090   
0ACA           1091   state1_done:
0ACA 753302    1092       mov States, #2
0ACD           1093       ;set State_time = 0
0ACD 8000      1094       sjmp state2_beginning
0ACF           1095   
0ACF           1096   ;OFF_STATE2:
0ACF           1097       ;ljmp OFF_STATE
0ACF           1098   
0ACF           1099   ; preheat/soak
0ACF           1100   state2_beginning: 
0ACF 753A00    1101       mov State_time, #0x00 ;clear the state time
0AD2           1102       ;***clear the screen and set new display***
0AD2 12069F    1103       lcall Initialize_State_Display
0AD5 C0E0      1104            push acc
0AD7 7407      1104            mov a, #7
0AD9 14        1104            dec a
0ADA 1200BD    1104            lcall ?Set_Cursor_2 ; Select column and row
0ADD D0E0      1104            pop acc
0ADF C083      1105            push dph
0AE1 C082      1105            push dpl
0AE3 C0E0      1105            push acc
0AE5 900458    1105            mov dptr, #Soak
0AE8 1200B2    1105            lcall ?Send_Constant_String
0AEB D0E0      1105            pop acc
0AED D082      1105            pop dpl
0AEF D083      1105            pop dph ;displays current state
0AF1           1106   
0AF1           1107       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
0AF1 754EC8    1108            mov pwm_ratio+0, #low(200)
0AF4 754F00    1109            mov pwm_ratio+1, #high(000)
0AF7           1110   
0AF7           1111   state2:
0AF7           1112       ;check power on
0AF7 12057D    1113       lcall CHECK_POWER
0AFA           1114       
0AFA           1115       ;Update Time and Temp
0AFA 12071E    1116       lcall Update_Display
0AFD           1117   
0AFD           1118       ;Set_Cursor(1,14)
0AFD           1119       ;mov a, Temp_oven
0AFD           1120       ;lcall SendToLCD
0AFD           1121       
0AFD           1122       ;check temperature
0AFD           1123       ;lcall Average_Temp
0AFD           1124       
0AFD           1125       
0AFD           1126       
0AFD           1127       ; loop back to state2 if run time is less than soak time. If greater than jump to state3 cuz of overflow of time
0AFD           1128        
0AFD           1129       ;mov a, State_time
0AFD           1130       ;subb a, Soak_time
0AFD           1131       ;jnc state2_done
0AFD           1132       ;jc state2
0AFD           1133   
0AFD           1134   
0AFD           1135   ;*Checking moving to states with buttons---- 
0AFD           1136   ;*Will remove after proper temperature reading----
0AFD           1137   
0AFD 2085F7    1138       jb NEXT_STATE_BUTTON, state2
0B00 C002      1139            push AR2
0B02 7A32      1139            mov R2, #50
0B04 120039    1139            lcall ?Wait_Milli_Seconds
0B07 D002      1139            pop AR2 ; debounce time
0B09 2085EB    1140            jb NEXT_STATE_BUTTON, state2 ; if button not pressed, loop
0B0C 3085FD    1141            jnb NEXT_STATE_BUTTON, $ 
0B0F           1142       
0B0F           1143   state2_done:
0B0F 753A00    1144       mov State_time, #0
0B12 020B15    1145       ljmp state3_beginning
0B15           1146   
0B15           1147   ; ramp to peak
0B15           1148   state3_beginning:
0B15 D287      1149       setb OVEN_POWER ;turn power on 100%
0B17           1150   
0B17           1151       ;***clear the screen and set new display***
0B17 12069F    1152       lcall Initialize_State_Display
0B1A C0E0      1153            push acc
0B1C 7407      1153            mov a, #7
0B1E 14        1153            dec a
0B1F 1200BD    1153            lcall ?Set_Cursor_2 ; Select column and row
0B22 D0E0      1153            pop acc
0B24 C083      1154            push dph
0B26 C082      1154            push dpl
0B28 C0E0      1154            push acc
0B2A 90045D    1154            mov dptr, #Ramp2Peak
0B2D 1200B2    1154            lcall ?Send_Constant_String
0B30 D0E0      1154            pop acc
0B32 D082      1154            pop dpl
0B34 D083      1154            pop dph
0B36           1155   
0B36           1156       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0B36 754EE8    1157            mov pwm_ratio+0, #low(1000)
0B39 754F03    1158            mov pwm_ratio+1, #high(1000)
0B3C           1159   
0B3C           1160   state3: 
0B3C           1161       ;check power on
0B3C 12057D    1162       lcall CHECK_POWER
0B3F           1163       
0B3F           1164       
0B3F           1165       ;Update Time and Temp
0B3F 12071E    1166       lcall Update_Display
0B42           1167       
0B42           1168       ;mov a, Temp_oven
0B42           1169       ;subb a, Temp_refl 
0B42           1170       ;JNC state3_done    ; if greater, jump to state 4
0B42           1171       ;JZ state3_done ; if equal to, jump to state 4
0B42           1172       ;JC state3 ; if less than, go back to state3
0B42           1173       
0B42 2085F7    1174       jb NEXT_STATE_BUTTON, state3
0B45 C002      1175            push AR2
0B47 7A32      1175            mov R2, #50
0B49 120039    1175            lcall ?Wait_Milli_Seconds
0B4C D002      1175            pop AR2 ; debounce time
0B4E 2085EB    1176            jb NEXT_STATE_BUTTON, state3 ; if button not pressed, loop
0B51 3085FD    1177            jnb NEXT_STATE_BUTTON, $
0B54           1178   
0B54           1179   state3_done:
0B54 753A00    1180       mov State_time, #0
0B57 020B5A    1181       ljmp state4_beginning
0B5A           1182   
0B5A           1183   
0B5A           1184   ; reflow 
0B5A           1185   state4_beginning:
0B5A           1186       ;***clear the screen and set new display***
0B5A 12069F    1187       lcall Initialize_State_Display
0B5D C0E0      1188            push acc
0B5F 7407      1188            mov a, #7
0B61 14        1188            dec a
0B62 1200BD    1188            lcall ?Set_Cursor_2 ; Select column and row
0B65 D0E0      1188            pop acc
0B67 C083      1189            push dph
0B69 C082      1189            push dpl
0B6B C0E0      1189            push acc
0B6D 900467    1189            mov dptr, #Reflow
0B70 1200B2    1189            lcall ?Send_Constant_String
0B73 D0E0      1189            pop acc
0B75 D082      1189            pop dpl
0B77 D083      1189            pop dph
0B79           1190   
0B79           1191       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
0B79 754EC8    1192            mov pwm_ratio+0, #low(200)
0B7C 754F00    1193            mov pwm_ratio+1, #high(000)
0B7F           1194   
0B7F           1195   
0B7F           1196   state4:
0B7F           1197       ;check power on
0B7F 12057D    1198       lcall CHECK_POWER
0B82           1199       ;Update Time and Temp
0B82 12071E    1200       lcall Update_Display
0B85           1201   
0B85           1202       ;on
0B85           1203       ;setb OVEN_POWER
0B85           1204       ;lcall Wait_One_Second
0B85           1205       ;off
0B85           1206       ;clr OVEN_POWER
0B85           1207       ;mov r5, #0
0B85           1208       ;four_sec_loop2:
0B85           1209           ; loop back to state2 if run time is less than soak time
0B85           1210       ;    mov a, Time_refl
0B85           1211       ;    subb a, State_time
0B85           1212       ;   cjne a, #0, state4
0B85           1213       ;    Set_Cursor(1, 5)
0B85           1214            ;    Display_BCD(Run_time_minutes)
0B85           1215       ;    Set_Cursor(1,7)
0B85           1216       ;    Display_BCD(Run_time_seconds)
0B85           1217       ;    Wait_Milli_Seconds(#250)
0B85           1218   
0B85           1219       ;    inc r5
0B85           1220       ;    cjne r5, #16, four_sec_loop2
0B85           1221           
0B85           1222       
0B85           1223       ; loop back to state2 if run time is less than soak time
0B85           1224       ;mov a, Time_refl
0B85           1225       ;subb a, State_time
0B85           1226       ;cjne a, #0, state4
0B85           1227   
0B85           1228       ;*Checking moving to states with buttons---- 
0B85           1229   ;*Will remove after proper temperature reading----
0B85           1230   
0B85 2085F7    1231       jb NEXT_STATE_BUTTON, state4
0B88 C002      1232            push AR2
0B8A 7A32      1232            mov R2, #50
0B8C 120039    1232            lcall ?Wait_Milli_Seconds
0B8F D002      1232            pop AR2 ; debounce time
0B91 2085EB    1233            jb NEXT_STATE_BUTTON, state4 ; if button not pressed, loop
0B94 3085FD    1234            jnb NEXT_STATE_BUTTON, $ 
0B97           1235   
0B97           1236   state4_done: 
0B97 753A00    1237       mov State_time, #0
0B9A 020B9D    1238       ljmp state5_beginning 
0B9D           1239   
0B9D           1240   
0B9D           1241   ; cooling
0B9D           1242   state5_beginning: ; turn oven off
0B9D C287      1243       clr OVEN_POWER
0B9F           1244   
0B9F           1245   ;***clear the screen and set new display***
0B9F 12069F    1246       lcall Initialize_State_Display
0BA2 C083      1247            push dph
0BA4 C082      1247            push dpl
0BA6 C0E0      1247            push acc
0BA8 90046E    1247            mov dptr, #Cooling
0BAB 1200B2    1247            lcall ?Send_Constant_String
0BAE D0E0      1247            pop acc
0BB0 D082      1247            pop dpl
0BB2 D083      1247            pop dph
0BB4           1248   
0BB4           1249       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0BB4 754E00    1250            mov pwm_ratio+0, #low(0)
0BB7 754F00    1251            mov pwm_ratio+1, #high(0)
0BBA           1252   
0BBA           1253   state5:
0BBA           1254       ;check power on
0BBA 12057D    1255       lcall CHECK_POWER
0BBD           1256       
0BBD           1257       ; update display
0BBD 12071E    1258       lcall Update_Display
0BC0           1259   
0BC0           1260       ;mov a, Temp_oven
0BC0           1261       ;subb a, #60
0BC0           1262       ;JNC state5    ; if greater, jump back to state 5
0BC0           1263       ;JZ state5 ; if equal to, go back to state5
0BC0           1264       ;JC state5_done ; if less than, go back to state 0
0BC0           1265   
0BC0           1266       ;*Checking moving to states with buttons---- 
0BC0           1267   ;*Will remove after proper temperature reading----
0BC0           1268   
0BC0 2085F7    1269       jb NEXT_STATE_BUTTON, state5
0BC3 C002      1270            push AR2
0BC5 7A32      1270            mov R2, #50
0BC7 120039    1270            lcall ?Wait_Milli_Seconds
0BCA D002      1270            pop AR2 ; debounce time
0BCC 2085EB    1271            jb NEXT_STATE_BUTTON, state5 ; if button not pressed, loop
0BCF 3085FD    1272            jnb NEXT_STATE_BUTTON, $ 
0BD2           1273   
0BD2           1274   state5_done:
0BD2 753A00    1275       mov State_time, #0
0BD5 753300    1276       mov States, #0
0BD8 020A21    1277       ljmp main
0BDB           1278   
0BDB           1279   EN
