                  2   $LIST
0000              4   
0000              5   
0000              6   
0000              7   ;-------------------------------------------------------------------------------------------------------------------------------
0000              8   ;These EQU must match the wiring between the microcontroller and ADC
0000              9   CLK  EQU 22118400
0000             10   TIMER1_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             11   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             12   BAUD equ 115200
0000             13   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000             14   
0000             15   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             16   TIMER2_RELOAD EQU (65536-(CLK/TIMER2_RATE))
0000             17   
0000             18   ;shjfjdfs
0000             19   ;-------------------------------------------------------------------------------------------------------------------------------
0000             20   ;Button Pin Mapping
0000             21   NEXT_STATE_BUTTON  equ P0.5
0000             22   STIME_BUTTON    equ P0.2
0000             23   STEMP_BUTTON    equ P0.3
0000             24   RTIME_BUTTON    equ P0.4
0000             25   RTEMP_BUTTON    equ P0.6
0000             26   
0000             27   POWER_BUTTON    equ P4.5
0000             28   SHIFT_BUTTON    equ p0.4
0000             29   
0000             30   ;Output Pins
0000             31   OVEN_POWER      equ P0.7
0000             32   SPEAKER         equ P2.6
0000             33   
0000             34   PWM_OUTPUT    equ P1.0 ; Attach an LED (with 1k resistor in series) to P1.0
0000             35   
0000             36   FLASH_CE        equ P0.0
0000             37   
0000             38   ;Thermowire Pins
0000             39   CE_ADC    EQU  P1.7
0000             40   MY_MOSI   EQU  P1.6
0000             41   MY_MISO   EQU  P1.5
0000             42   MY_SCLK   EQU  P1.4 
0000             43   
0000             44   ; Commands supported by the SPI flash memory according to the datasheet
0000             45   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             46   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             47   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             48   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             49   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             50   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             51   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             52   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             53   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             54   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             55   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             56   
0000             57   ; These 'equ' must match the hardware wiring
0000             58   LCD_RS equ P3.2
0000             59   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
0000             60   LCD_E  equ P3.3
0000             61   LCD_D4 equ P3.4
0000             62   LCD_D5 equ P3.5
0000             63   LCD_D6 equ P3.6
0000             64   LCD_D7 equ P3.7
0000             65   
0000             66   ;-------------------------------------------------------------------------------------------------------------------------------
0000             67   
0000             68   org 0x0000
0000 020A04      69       ljmp main
0003             70   
0003             71   ; External interrupt 0 vector (not used in this code)
0003             72   org 0x0003
0003 32          73            reti
0004             74   
0004             75   ; Timer/Counter 0 overflow interrupt vector
000B             76   org 0x000B
000B 32          77            reti
000C             78   
000C             79   ; External interrupt 1 vector (not used in this code)
0013             80   org 0x0013
0013 32          81            reti
0014             82   
0014             83   ; Timer/Counter 1 overflow interrupt vector
001B             84   org 0x001B
001B 020953      85            ljmp Timer1_ISR
001E             86   
001E             87   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             88   org 0x0023 
0023 32          89            reti
0024             90            
0024             91   ; Timer/Counter 2 overflow interrupt vector
002B             92   org 0x002B
002B 0209A9      93       ljmp Timer2_ISR
002E             94   ;-------------------------------------------------------------------------------------------------------------------------------
002E             95   ; Place our variables here
0030             96   DSEG at 0x30 ; Before the state machine!
0030             97   Count1ms:         ds 2 ; Used to determine when one second has passed
0032             98   Count5sec:        ds 1
0033             99   States:           ds 1
0034            100   Temp_soak:        ds 1
0035            101   Time_soak:        ds 1
0036            102   Temp_refl:        ds 1
0037            103   Time_refl:        ds 1
0038            104   Run_time_seconds: ds 1
0039            105   Run_time_minutes: ds 1
003A            106   State_time:       ds 1
003B            107   Temp_oven:        ds 1
003C            108   x:                ds 4
0040            109   y:                ds 4
0044            110   bcd:              ds 5
0049            111   Result:           ds 2
004B            112   w:                ds 3
004E            113   pwm_ratio:        ds 2
0050            114   average_count:    ds 1
0051            115   
                117   $LIST
00F0            119   
                546   $LIST
                121   $LIST
0360            123   
                125   $LIST
03E7            127   
0000            128   bseg
0000            129   one_seconds_flag:  dbit 1
0001            130   five_seconds_flag: dbit 1
0002            131   enable_clk:        dbit 1
0003            132   mf:                dbit 1
0004            133   
03E7            134   cseg
03E7            135   
03E7            136   ;-------------------------------------------------------------------------------------------------------------------------------
03E7            137   ;***Messages To Display*** 
03E7            138   
03E7            139   ;shortened labels
03E7 53546D70   140   STemp:  db 'STmp:', 0
     3A00
03ED 53546D3A   141   STime:  db 'STm:', 0
     00
03F2 52546D70   142   RTemp:  db 'RTmp:', 0
     3A00
03F8 52546D3A   143   RTime:  db 'RTm:', 0
     00
03FD            144   
03FD            145   ;lables for runnning oven
03FD 53746174   146   state:     db 'State>' , 0
     653E00
0404 546D653E   147   time:      db 'Tme>' , 0
     00
0409 3A00       148   colon:     db ':', 0
040B 546D703E   149   temp:      db 'Tmp>', 0
     00
0410            150   
0410            151   ;labels for changin parameters
0410 5265666C   152   ReflowTemp:  db 'Reflow Temperature:', 0
     6F772054
     656D7065
     72617475
     72653A00
0424 5265666C   153   ReflowTime:  db 'Reflow Time:', 0
     6F772054
     696D653A
     00
0431 536F616B   154   SoakTime:    db 'Soak Time:', 0
     2054696D
     653A00
043C 536F616B   155   SoakTemp:    db 'Soak Temperature:', 0
     2054656D
     70657261
     74757265
     3A00
044E            156   
044E            157   
044E            158   ;Current State in Oven
044E 52616D70   159   Ramp2Soak: db 'Ramp-Soak' , 0
     2D536F61
     6B00
0458 536F616B   160   Soak:      db 'Soak' , 0
     00
045D 52616D70   161   Ramp2Peak: db 'Ramp-Peak' , 0
     2D506561
     6B00
0467 5265666C   162   Reflow:    db 'Reflow' , 0
     6F7700
046E 436F6F6C   163   Cooling:   db 'Cooling' , 0
     696E6700
0476            164   
0476            165   ;-------------------------------------------------------------------------------------------------------------------------------
0476            166   ;FXNS FOR THERMOWIRE
0476            167   
0476            168   ;initialize SPI 
0476            169   INI_SPI:
0476 D295       170            setb MY_MISO          ; Make MISO an input pin
0478 C294       171            clr MY_SCLK           ; Mode 0,0 default
047A 22         172            ret
047B            173   DO_SPI_G:
047B C0E0       174            push acc
047D 7900       175            mov R1, #0            ; Received byte stored in R1
047F 7A08       176            mov R2, #8            ; Loop counter (8-bits)
0481            177   DO_SPI_G_LOOP:
0481 E8         178            mov a, R0             ; Byte to write is in R0
0482 33         179            rlc a                 ; Carry flag has bit to write
0483 F8         180            mov R0, a
0484 9296       181            mov MY_MOSI, c
0486 D294       182            setb MY_SCLK          ; Transmit
0488 A295       183            mov c, MY_MISO        ; Read received bit
048A E9         184            mov a, R1             ; Save received bit in R1
048B 33         185            rlc a
048C F9         186            mov R1, a
048D C294       187            clr MY_SCLK
048F DAF0       188            djnz R2, DO_SPI_G_LOOP
0491 D0E0       189            pop acc
0493 22         190   ret
0494            191   
0494            192   Send_SPI:
                193   	SPIBIT MAC
                194   	    ; Send/Receive bit %0
                195   		rlc a
                196   		mov MY_MOSI, c
                197   		setb MY_SCLK
                198   		mov c, MY_MISO
                199   		clr MY_SCLK
                200   		mov acc.0, c
                201   	ENDMAC
0494            202            
0494            203                ; Send/Receive bit 7
0494 33         203                    rlc a
0495 9296       203                    mov MY_MOSI, c
0497 D294       203                    setb MY_SCLK
0499 A295       203                    mov c, MY_MISO
049B C294       203                    clr MY_SCLK
049D 92E0       203                    mov acc.0, c
049F            204                ; Send/Receive bit 6
049F 33         204                    rlc a
04A0 9296       204                    mov MY_MOSI, c
04A2 D294       204                    setb MY_SCLK
04A4 A295       204                    mov c, MY_MISO
04A6 C294       204                    clr MY_SCLK
04A8 92E0       204                    mov acc.0, c
04AA            205                ; Send/Receive bit 5
04AA 33         205                    rlc a
04AB 9296       205                    mov MY_MOSI, c
04AD D294       205                    setb MY_SCLK
04AF A295       205                    mov c, MY_MISO
04B1 C294       205                    clr MY_SCLK
04B3 92E0       205                    mov acc.0, c
04B5            206                ; Send/Receive bit 4
04B5 33         206                    rlc a
04B6 9296       206                    mov MY_MOSI, c
04B8 D294       206                    setb MY_SCLK
04BA A295       206                    mov c, MY_MISO
04BC C294       206                    clr MY_SCLK
04BE 92E0       206                    mov acc.0, c
04C0            207                ; Send/Receive bit 3
04C0 33         207                    rlc a
04C1 9296       207                    mov MY_MOSI, c
04C3 D294       207                    setb MY_SCLK
04C5 A295       207                    mov c, MY_MISO
04C7 C294       207                    clr MY_SCLK
04C9 92E0       207                    mov acc.0, c
04CB            208                ; Send/Receive bit 2
04CB 33         208                    rlc a
04CC 9296       208                    mov MY_MOSI, c
04CE D294       208                    setb MY_SCLK
04D0 A295       208                    mov c, MY_MISO
04D2 C294       208                    clr MY_SCLK
04D4 92E0       208                    mov acc.0, c
04D6            209                ; Send/Receive bit 1
04D6 33         209                    rlc a
04D7 9296       209                    mov MY_MOSI, c
04D9 D294       209                    setb MY_SCLK
04DB A295       209                    mov c, MY_MISO
04DD C294       209                    clr MY_SCLK
04DF 92E0       209                    mov acc.0, c
04E1            210                ; Send/Receive bit 0
04E1 33         210                    rlc a
04E2 9296       210                    mov MY_MOSI, c
04E4 D294       210                    setb MY_SCLK
04E6 A295       210                    mov c, MY_MISO
04E8 C294       210                    clr MY_SCLK
04EA 92E0       210                    mov acc.0, c
04EC            211   
04EC 22         212   ret
04ED            213   
                214   Change_8bit_Variable MAC
                215       jb %0, %2
                216       Wait_Milli_Seconds(#50) ; de-bounce
                217       jb %0, %2
                218       jnb %0, $
                219       jb SHIFT_BUTTON, skip%Mb
                220       dec %1
                221       sjmp skip%Ma
                222       skip%Mb:
                223       inc %1
                224       skip%Ma:
                225   ENDMAC
04ED            226   
04ED            227   ;Change_8bit_Variable(MY_VARIABLE_BUTTON, my_variable, loop_c)
04ED            228   ;    Set_Cursor(2, 14)
04ED            229   ;    mov a, my_variable
04ED            230   ;    lcall SendToLCD
04ED            231   ;lcall Save_Configuration
04ED            232   
04ED            233   ;-------------------------------------------------------------------------------------------------------------------------------
04ED            234   ;***FXNS For Serial Port
04ED            235   
04ED            236   ; Configure the serial port and baud rate
04ED            237   InitSerialPort:
04ED            238       ; Since the reset button bounces, we need to wait a bit before
04ED            239       ; sending messages, otherwise we risk displaying gibberish!
04ED 79DE       240       mov R1, #222
04EF 78A6       241       mov R0, #166
04F1 D8FE       242       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
04F3 D9FA       243       djnz R1, $-4 ; 22.51519us*222=4.998ms
04F5            244       ; Now we can proceed with the configuration
04F5 438780     245            orl     PCON,#0x80
04F8 759852     246            mov     SCON,#0x52
04FB 759B00     247            mov     BDRCON,#0x00
04FE 759AF4     248            mov     BRL,#BRG_VAL
0501 759B1E     249            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0504 22         250   ret
0505            251   
0505            252   
0505            253   putchar:
0505 3099FD     254       jnb TI, putchar
0508 C299       255       clr TI
050A F599       256       mov SBUF, a
050C 22         257   ret
050D            258   
050D            259   ;-------------------------------------------------------------------------------------------------------------------------------
050D            260   ;***FXNS to CHECK BUTTONS
050D            261   
050D            262   CHECK_STIME:
050D            263   
050D 208218     264       jb STIME_BUTTON, CHECK_STIME_END
0510 C002       264            push AR2
0512 7A32       264            mov R2, #50
0514 120039     264            lcall ?Wait_Milli_Seconds
0517 D002       264            pop AR2 ; de-bounce
0519 20820C     264       jb STIME_BUTTON, CHECK_STIME_END
051C 3082FD     264       jnb STIME_BUTTON, $
051F 208404     264       jb SHIFT_BUTTON, skip16b
0522 1535       264       dec Time_soak
0524 8002       264       sjmp skip16a
0526            264       skip16b:
0526 0535       264       inc Time_soak
0528            264       skip16a:
0528            265            
0528            266   CHECK_STIME_END:
0528 22         267   ret
0529            268   
0529            269   CHECK_STEMP:
0529 208318     270       jb STEMP_BUTTON, CHECK_STEMP_END
052C C002       270            push AR2
052E 7A32       270            mov R2, #50
0530 120039     270            lcall ?Wait_Milli_Seconds
0533 D002       270            pop AR2 ; de-bounce
0535 20830C     270       jb STEMP_BUTTON, CHECK_STEMP_END
0538 3083FD     270       jnb STEMP_BUTTON, $
053B 208404     270       jb SHIFT_BUTTON, skip18b
053E 1534       270       dec Temp_soak
0540 8002       270       sjmp skip18a
0542            270       skip18b:
0542 0534       270       inc Temp_soak
0544            270       skip18a:
0544            271       ;lcall Save_Configuration
0544            272            
0544            273   CHECK_STEMP_END:
0544 22         274   ret
0545            275   
0545            276   CHECK_RTIME:
0545 208418     277       jb RTIME_BUTTON, CHECK_RTIME_END
0548 C002       277            push AR2
054A 7A32       277            mov R2, #50
054C 120039     277            lcall ?Wait_Milli_Seconds
054F D002       277            pop AR2 ; de-bounce
0551 20840C     277       jb RTIME_BUTTON, CHECK_RTIME_END
0554 3084FD     277       jnb RTIME_BUTTON, $
0557 208404     277       jb SHIFT_BUTTON, skip20b
055A 1537       277       dec Time_refl
055C 8002       277       sjmp skip20a
055E            277       skip20b:
055E 0537       277       inc Time_refl
0560            277       skip20a:
0560            278   CHECK_RTIME_END:
0560 22         279   ret
0561            280   
0561            281   CHECK_RTEMP:
0561 208618     282       jb RTEMP_BUTTON, CHECK_RTEMP_END
0564 C002       282            push AR2
0566 7A32       282            mov R2, #50
0568 120039     282            lcall ?Wait_Milli_Seconds
056B D002       282            pop AR2 ; de-bounce
056D 20860C     282       jb RTEMP_BUTTON, CHECK_RTEMP_END
0570 3086FD     282       jnb RTEMP_BUTTON, $
0573 208404     282       jb SHIFT_BUTTON, skip22b
0576 1536       282       dec Temp_refl
0578 8002       282       sjmp skip22a
057A            282       skip22b:
057A 0536       282       inc Temp_refl
057C            282       skip22a:
057C            283   CHECK_RTEMP_END:
057C 22         284   ret
057D            285   
057D            286   CHECK_POWER:
057D            287   
057D 20C512     288       jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
0580 C002       289            push AR2
0582 7A32       289            mov R2, #50
0584 120039     289            lcall ?Wait_Milli_Seconds
0587 D002       289            pop AR2 ; debounce time
0589 20C506     290            jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
058C 30C5FD     291            jnb POWER_BUTTON, $ ; loop while the button is pressed
058F 12087D     292       lcall OFF_STATE
0592            293   
0592            294   CHECK_POWER_END:
0592 22         295   ret
0593            296   ;**SOUND STUFF---------------------------------------------------------------
0593            297   
0593            298   SOUND_FSM:
0593            299   state_0_sound:
0593            300   ;check if 5 seconds has passed, if yes go to state 1, if no exit function 
0593 300105     301       jnb five_seconds_flag, Sound_ret
0596 C201       302       clr five_seconds_flag
0598 02059C     303       ljmp state_1_sound
059B            304   Sound_ret:
059B 22         305       ret
059C            306   
059C            307   state_1_sound:
059C            308   ; check if temp is greater than 100, if yes go to state 2
059C            309   ; check if temp is less than 100, if yes go to state 4
059C E53B       310       mov a, Temp_oven
059E 9464       311       subb a, #100
05A0 5002       312       jnc state_2_sound
05A2 4026       313       jc state_4_sound
05A4            314   
05A4            315   state_2_sound:
05A4            316   ;divide temp by 100, if it is 1 play sound: "100", if it is 2 play sound: "200"
05A4            317   ; go to state_3_sound
05A4 75F064     318       mov b, #100
05A7 E53B       319       mov a, Temp_oven
05A9 84         320       div ab
05AA 9401       321       subb a, #1
05AC 600A       322       jz play_sound_1
05AE            323   
05AE 75F064     324       mov b, #100
05B1 E53B       325       mov a, Temp_oven
05B3 84         326       div ab
05B4 9402       327       subb a, #2
05B6 6000       328       jz play_sound_1
05B8            329      
05B8            330      play_sound_1: 
05B8 02060E     331       ljmp PLAYBACK_TEMP
05BB            332   
05BB 0205BE     333       ljmp state_3_sound
05BE            334   
05BE            335   
05BE            336   state_3_sound:
05BE            337   ; check remainder of temp, if it is 0, go back to state_0_sound
05BE            338   ; if not 0, go to state_4_sound
05BE            339   
05BE 75F064     340       mov b, #100
05C1 E53B       341       mov a, Temp_oven
05C3 84         342       div ab
05C4 E5F0       343       mov a, b
05C6 60CB       344       jz state_0_sound
05C8 7000       345       jnz state_4_sound
05CA            346   
05CA            347   state_4_sound:
05CA            348   ; if T % 100 greater or equal to 20, go to state_5_sound,
05CA 75F064     349       mov b, #100
05CD E53B       350       mov a, Temp_oven
05CF 84         351       div ab
05D0 E5F0       352       mov a, b 
05D2 9414       353       subb a, #20
05D4 5011       354       jnc state_5_sound
05D6 E4         355       clr a
05D7            356   ; if T % 100 is less than 10, go to state_6_sound
05D7 75F064     357       mov b, #100
05DA E53B       358       mov a, Temp_oven
05DC 84         359       div ab
05DD E5F0       360       mov a, b
05DF 940A       361       subb a, #10
05E1 401C       362       jc state_6_sound
05E3 E4         363       clr a
05E4            364   ; if T % 100 is greater than 10 and less than 20, go to state_7_sound
05E4 020605     365       ljmp state_7_sound
05E7            366       
05E7            367   
05E7            368   state_5_sound:
05E7            369   ; play number from 20 to 90 in decades (20, 30, 40, 50, 60, 70, 80, 90), based off remainder from temp divided by 100
05E7            370   ; if (T % 100) % 10 is not equal to 0, go to state_6_sound
05E7            371   ; if (T % 100) % 10 is equal to 0, go to state_8_sound
05E7            372   
05E7 E53B       373       mov a, Temp_oven
05E9 75F064     374       mov b, #100 
05EC 84         375       div ab
05ED E5F0       376       mov a, b
05EF 75F00A     377       mov b, #10
05F2 84         378       div ab
05F3 E5F0       379       mov a, b
05F5 6002       380       jz play_sound
05F7 7006       381       jnz state_6_sound
05F9            382       
05F9            383   
05F9            384       play_sound:
05F9 02060E     385           ljmp PLAYBACK_TEMP
05FC 02060B     386           ljmp state_8_sound
05FF            387   
05FF            388   
05FF            389   state_6_sound:
05FF            390   ; play 1 - 9
05FF 02060E     391       ljmp PLAYBACK_TEMP
0602            392   ; go to state_8_sound
0602 02060B     393       ljmp state_8_sound
0605            394   
0605            395   
0605            396   state_7_sound:
0605            397   ; play 10 - 19
0605 02060E     398       ljmp PLAYBACK_TEMP
0608            399   ; go to state_8_sound 
0608 02060B     400       ljmp state_8_sound
060B            401   
060B            402   state_8_sound:
060B            403   ; go to state_0_sound
060B 020593     404       ljmp state_0_sound
060E            405   
060E            406   
060E            407   PLAYBACK_TEMP:
060E            408       ; ****INITIALIZATION****
060E            409       ; Configure SPI pins and turn off speaker
060E 53CECE     410            anl P2M0, #0b_1100_1110
0611 43CF31     411            orl P2M1, #0b_0011_0001
0614 D295       412            setb MY_MISO  ; Configured as input
0616 D280       413            setb FLASH_CE ; CS=1 for SPI flash memory
0618 C294       414            clr MY_SCLK   ; Rest state of SCLK=0
061A C2A6       415            clr SPEAKER   ; Turn off speaker.
061C            416            
061C            417            ; Configure timer 1
061C 53890F     418            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
061F 438910     419            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
0622 758DFC     420            mov TH1, #high(TIMER1_RELOAD)
0625 758B15     421            mov TL1, #low(TIMER1_RELOAD)
0628            422            ; Set autoreload value
0628 75F5FC     423            mov RH1, #high(TIMER1_RELOAD)
062B 75F315     424            mov RL1, #low(TIMER1_RELOAD)
062E            425   
062E            426            ;Enable the timer and interrupts
062E D2AB       427       setb ET1  ; Enable timer 1 interrupt
0630 D28E       428            setb TR1 ; Timer 1 is only enabled to play stored sound
0632            429   
0632            430            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
0632 75A5A0     431            mov DADI, #0b_1010_0000 ; ACON=1
0635 75A43A     432            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0638 75AD80     433            mov DADH, #0x80 ; Middle of scale
063B 75AC00     434            mov DADL, #0
063E 43A440     435            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
0641            436       check_DAC_init:
0641 E5A4       437            mov a, DADC
0643 20E6FB     438            jb acc.6, check_DAC_init ; Wait for DAC to finish
0646            439            
0646 D2AF       440            setb EA ; Enable interrupts
0648            441   
0648            442       ; ***play audio***
0648 C28E       443       clr TR1 ; Stop Timer 1 ISR from playing previous request
064A D280       444       setb FLASH_CE 
064C C2A6       445       clr SPEAKER ; Turn off speaker
064E            446   
064E C280       447       clr FLASH_CE ; Enable SPI Flash
0650            448       ;mov READ_BYTES, #3
0650 7403       449       mov a, #READ_BYTES
0652 120494     450       lcall Send_SPI
0655            451       ; Set the initial position in memory where to start playing
0655            452       
0655 7402       453       mov a, #0x02 ; change initial position
0657 120494     454       lcall Send_SPI
065A 74D5       455       mov a, #0xd5 ; next memory position
065C 120494     456       lcall Send_SPI 
065F 742D       457       mov a, #0x2d ; next memory position
0661 120494     458       lcall Send_SPI
0664 7402       459       mov a, #0x02 ; request first byte to send to DAC
0666 120494     460       lcall Send_SPI
0669            461   
0669            462       ; How many bytes to play?
0669 754D00     463       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
066C 754C39     464       mov w+1, #0x39 ; Load the middle byte of the number of bytes to play
066F 754B6A     465       mov w+0, #0x6a ; Load the low byte of the number of bytes to play
0672            466    
0672 D2A6       467       setb SPEAKER ;Turn on speaker
0674 D28E       468       setb TR1 ;Start playback by enabling Timer1 
0676 22         469       ret
0677            470       
0677            471   ;-------------------------------------------------------------------------------------------------------------------------------
0677            472   ;***LCD FXNS
0677            473   
                474   Display_lower_BCD mac
                475       push ar0
                476       mov r0, %0
                477       lcall ?Display_lower_BCD
                478       pop ar0
                479   endmac
0677            480   
0677            481   ?Display_lower_BCD:
0677 C0E0       482       push acc
0679            483       ; write least significant digit
0679 E8         484       mov a, r0
067A 540F       485       anl a, #0fh
067C 4430       486       orl a, #30h
067E 12007E     487       lcall ?WriteData
0681 D0E0       488       pop acc
0683 22         489   ret
0684            490   
0684            491   
0684            492   SendToLCD:
0684 75F064     493       mov b, #100
0687 84         494       div ab
0688 4430       495       orl a, #0x30h ; Convert hundreds to ASCII
068A 12007E     496       lcall ?WriteData ; Send to LCD
068D E5F0       497       mov a, b    ; Remainder is in register b
068F 75F00A     498       mov b, #10
0692 84         499       div ab
0693 4430       500       orl a, #0x30h ; Convert tens to ASCII
0695 12007E     501       lcall ?WriteData; Send to LCD
0698 E5F0       502       mov a, b
069A 4430       503       orl a, #0x30h ; Convert units to ASCII
069C 12007E     504       lcall ?WriteData; Send to LCD
069F 22         505   ret
06A0            506   
06A0            507   Initialize_State_Display:
06A0            508   
06A0            509       ;***clear the screen and set new display***
06A0 7401       510            mov a, #0x01
06A2 120083     510            lcall ?WriteCommand
06A5 C002       511            push AR2
06A7 7A02       511            mov R2, #2
06A9 120039     511            lcall ?Wait_Milli_Seconds
06AC D002       511            pop AR2
06AE            512       
06AE C0E0       513            push acc
06B0 7401       513            mov a, #1
06B2 14         513            dec a
06B3 1200BF     513            lcall ?Set_Cursor_1 ; Select column and row
06B6 D0E0       513            pop acc
06B8 C083       514            push dph
06BA C082       514            push dpl
06BC C0E0       514            push acc
06BE 900404     514            mov dptr, #time
06C1 1200B2     514            lcall ?Send_Constant_String
06C4 D0E0       514            pop acc
06C6 D082       514            pop dpl
06C8 D083       514            pop dph
06CA            515            
06CA C0E0       516            push acc
06CC 7406       516            mov a, #6
06CE 14         516            dec a
06CF 1200BF     516            lcall ?Set_Cursor_1 ; Select column and row
06D2 D0E0       516            pop acc
06D4 C083       517            push dph
06D6 C082       517            push dpl
06D8 C0E0       517            push acc
06DA 900409     517            mov dptr, #colon
06DD 1200B2     517            lcall ?Send_Constant_String
06E0 D0E0       517            pop acc
06E2 D082       517            pop dpl
06E4 D083       517            pop dph
06E6            518      
06E6 C0E0       519            push acc
06E8 740A       519            mov a, #10
06EA 14         519            dec a
06EB 1200BF     519            lcall ?Set_Cursor_1 ; Select column and row
06EE D0E0       519            pop acc
06F0 C083       520            push dph
06F2 C082       520            push dpl
06F4 C0E0       520            push acc
06F6 90040B     520            mov dptr, #temp
06F9 1200B2     520            lcall ?Send_Constant_String
06FC D0E0       520            pop acc
06FE D082       520            pop dpl
0700 D083       520            pop dph
0702            521       
0702 C0E0       522            push acc
0704 7401       522            mov a, #1
0706 14         522            dec a
0707 1200BD     522            lcall ?Set_Cursor_2 ; Select column and row
070A D0E0       522            pop acc
070C C083       523            push dph
070E C082       523            push dpl
0710 C0E0       523            push acc
0712 9003FD     523            mov dptr, #state
0715 1200B2     523            lcall ?Send_Constant_String
0718 D0E0       523            pop acc
071A D082       523            pop dpl
071C D083       523            pop dph
071E 22         524   ret
071F            525   
071F            526   Update_Display:
071F C0E0       527            push acc
0721 7405       527            mov a, #5
0723 14         527            dec a
0724 1200BF     527            lcall ?Set_Cursor_1 ; Select column and row
0727 D0E0       527            pop acc
0729 C000       528       push ar0
072B A839       528       mov r0, Run_time_minutes
072D 120677     528       lcall ?Display_lower_BCD
0730 D000       528       pop ar0
0732 C0E0       529            push acc
0734 7407       529            mov a, #7
0736 14         529            dec a
0737 1200BF     529            lcall ?Set_Cursor_1 ; Select column and row
073A D0E0       529            pop acc
073C C000       530            push ar0
073E A838       530            mov r0, Run_time_seconds
0740 1200C4     530            lcall ?Display_BCD
0743 D000       530            pop ar0
0745            531       ;Set_Cursor(1,14)
0745            532       ;mov a, Temp_oven
0745            533       ;SendToLCD(Temp_oven)
0745 22         534   ret
0746            535   
0746            536   State0_display:
0746 C0E0       537            push acc
0748 7401       537            mov a, #1
074A 14         537            dec a
074B 1200BF     537            lcall ?Set_Cursor_1 ; Select column and row
074E D0E0       537            pop acc
0750 C083       538            push dph
0752 C082       538            push dpl
0754 C0E0       538            push acc
0756 9003E7     538            mov dptr, #STemp
0759 1200B2     538            lcall ?Send_Constant_String
075C D0E0       538            pop acc
075E D082       538            pop dpl
0760 D083       538            pop dph
0762 C0E0       539            push acc
0764 7406       539            mov a, #6
0766 14         539            dec a
0767 1200BF     539            lcall ?Set_Cursor_1 ; Select column and row
076A D0E0       539            pop acc
076C E534       540       mov a, Temp_soak
076E 120684     541       lcall SendToLCD
0771            542       
0771 C0E0       543            push acc
0773 740A       543            mov a, #10
0775 14         543            dec a
0776 1200BF     543            lcall ?Set_Cursor_1 ; Select column and row
0779 D0E0       543            pop acc
077B C083       544            push dph
077D C082       544            push dpl
077F C0E0       544            push acc
0781 9003ED     544            mov dptr, #STime
0784 1200B2     544            lcall ?Send_Constant_String
0787 D0E0       544            pop acc
0789 D082       544            pop dpl
078B D083       544            pop dph
078D C0E0       545            push acc
078F 740E       545            mov a, #14
0791 14         545            dec a
0792 1200BF     545            lcall ?Set_Cursor_1 ; Select column and row
0795 D0E0       545            pop acc
0797 E535       546       mov a, Time_soak
0799 120684     547            lcall SendToLCD
079C            548       ;Display_BCD(Time_soak)
079C            549   
079C            550       ;Displays Reflow Temp and Time
079C C0E0       551            push acc
079E 7401       551            mov a, #1
07A0 14         551            dec a
07A1 1200BD     551            lcall ?Set_Cursor_2 ; Select column and row
07A4 D0E0       551            pop acc
07A6 C083       552            push dph
07A8 C082       552            push dpl
07AA C0E0       552            push acc
07AC 9003F2     552            mov dptr, #RTemp
07AF 1200B2     552            lcall ?Send_Constant_String
07B2 D0E0       552            pop acc
07B4 D082       552            pop dpl
07B6 D083       552            pop dph
07B8 C0E0       553            push acc
07BA 7406       553            mov a, #6
07BC 14         553            dec a
07BD 1200BD     553            lcall ?Set_Cursor_2 ; Select column and row
07C0 D0E0       553            pop acc
07C2 E536       554       mov a, Temp_refl
07C4 120684     555       lcall SendToLCD
07C7            556       
07C7 C0E0       557            push acc
07C9 740A       557            mov a, #10
07CB 14         557            dec a
07CC 1200BD     557            lcall ?Set_Cursor_2 ; Select column and row
07CF D0E0       557            pop acc
07D1 C083       558            push dph
07D3 C082       558            push dpl
07D5 C0E0       558            push acc
07D7 9003F8     558            mov dptr, #RTime
07DA 1200B2     558            lcall ?Send_Constant_String
07DD D0E0       558            pop acc
07DF D082       558            pop dpl
07E1 D083       558            pop dph
07E3 C0E0       559            push acc
07E5 740E       559            mov a, #14
07E7 14         559            dec a
07E8 1200BD     559            lcall ?Set_Cursor_2 ; Select column and row
07EB D0E0       559            pop acc
07ED E537       560       mov a, Time_refl
07EF 120684     561            lcall SendToLCD
07F2 22         562   ret
07F3            563   
07F3            564   Display_3_digit_BCD:
07F3 C0E0       565            push acc
07F5 740E       565            mov a, #14
07F7 14         565            dec a
07F8 1200BF     565            lcall ?Set_Cursor_1 ; Select column and row
07FB D0E0       565            pop acc
07FD C000       566       push ar0
07FF A845       566       mov r0, bcd+1
0801 120677     566       lcall ?Display_lower_BCD
0804 D000       566       pop ar0
0806 C000       567            push ar0
0808 A844       567            mov r0, bcd+0
080A 1200C4     567            lcall ?Display_BCD
080D D000       567            pop ar0
080F 22         568   ret
0810            569   
0810            570   
0810            571   ;The following functions store and restore the values--------------------------------------------------------------------------
                572   loadbyte mac
                573       mov a, %0
                574       movx @dptr, a
                575       inc dptr
                576   endmac
0810            577   
0810            578   Save_Configuration:
0810 C0A8       579       push IE ; Save the current state of bit EA in the stack
0812 C2AF       580       clr EA ; Disable interrupts
0814 75D108     581       mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
0817 907F80     582       mov dptr, #0x7f80 ; Last page of flash memory
081A            583       ; Save variables
081A E534       584       mov a, temp_soak
081C F0         584       movx @dptr, a
081D A3         584       inc dptr ; @0x7f80
081E E535       585       mov a, time_soak
0820 F0         585       movx @dptr, a
0821 A3         585       inc dptr ; @0x7f81
0822 E536       586       mov a, temp_refl
0824 F0         586       movx @dptr, a
0825 A3         586       inc dptr ; @0x7f82
0826 E537       587       mov a, time_refl
0828 F0         587       movx @dptr, a
0829 A3         587       inc dptr ; @0x7f83
082A 7455       588       mov a, #0x55
082C F0         588       movx @dptr, a
082D A3         588       inc dptr ; First key value @0x7f84
082E 74AA       589       mov a, #0xAA
0830 F0         589       movx @dptr, a
0831 A3         589       inc dptr ; Second key value @0x7f85
0832 75D100     590       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0) 
0835 43D240     591       orl EECON, #0b01000000 ; Enable auto-erase on next write sequence  
0838 75D150     592       mov FCON, #0x50 ; Write trigger first byte
083B 75D1A0     593       mov FCON, #0xA0 ; Write trigger second byte
083E            594       ; CPU idles until writing of flash completes.
083E 75D100     595       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
0841 53D2BF     596       anl EECON, #0b10111111 ; Disable auto-erase
0844 D0A8       597       pop IE ; Restore the state of bit EA from the stack
0846 22         598   ret
0847            599   
                600   getbyte mac
                601       clr a
                602       movc a, @a+dptr
                603       mov %0, a
                604       inc dptr
                605   endmac
0847            606   
0847            607   Load_Configuration:
0847 907F84     608       mov dptr, #0x7f84 ; First key value location.
084A E4         609       clr a
084B 93         609       movc a, @a+dptr
084C F8         609       mov R0, a
084D A3         609       inc dptr ; 0x7f84 should contain 0x55
084E B8551F     610       cjne R0, #0x55, Load_Defaults
0851 E4         611       clr a
0852 93         611       movc a, @a+dptr
0853 F8         611       mov R0, a
0854 A3         611       inc dptr ; 0x7f85 should contain 0xAA
0855 B8AA18     612       cjne R0, #0xAA, Load_Defaults
0858            613   ; Keys are good.  Get stored values.
0858 907F80     614       mov dptr, #0x7f80
085B E4         615       clr a
085C 93         615       movc a, @a+dptr
085D F534       615       mov Temp_soak, a
085F A3         615       inc dptr ; 0x7f80
0860 E4         616       clr a
0861 93         616       movc a, @a+dptr
0862 F535       616       mov Time_soak, a
0864 A3         616       inc dptr ; 0x7f81
0865 E4         617       clr a
0866 93         617       movc a, @a+dptr
0867 F536       617       mov Temp_refl, a
0869 A3         617       inc dptr ; 0x7f82
086A E4         618       clr a
086B 93         618       movc a, @a+dptr
086C F537       618       mov Time_refl, a
086E A3         618       inc dptr ; 0x7f83
086F 22         619   ret
0870            620   
0870            621   Load_Defaults:
0870 753482     622       mov Temp_soak, #130 ; Soak Tmp Range is 130-170
0873 75353C     623       mov Time_soak, #0x3C ; Range 60-90 seconds
0876 7536DC     624       mov Temp_refl, #220 ; Range 220-240
0879 75371E     625       mov Time_refl, #0x1E ; Range 30-45 seconds
087C 22         626       ret 
087D            627   ;-------------------------------------------------------------------------------------------------------------------------------
087D            628   ;off state
087D            629   
087D            630   OFF_STATE:
087D            631       ;**CLEAR SCREEN**
087D 7401       632            mov a, #0x01
087F 120083     632            lcall ?WriteCommand
0882            633       ;**TURN OFF OVEN
0882 C287       634       clr OVEN_POWER
0884            635       ;OFF_STATE1:
0884            636       
0884 20C5FD     637       jb POWER_BUTTON, $ ; loop while the button is not pressed
0887 C002       638            push AR2
0889 7A32       638            mov R2, #50
088B 120039     638            lcall ?Wait_Milli_Seconds
088E D002       638            pop AR2 ; debounce time
0890 20C5EA     639            jb POWER_BUTTON, OFF_STATE ; it was a bounce, try again
0893 30C5FD     640            jnb POWER_BUTTON, $ ; loop while the button is pressed
0896 020A04     641       ljmp main
0899 22         642   ret
089A            643   ;-------------------------------------------------------------------------------------------------------------------------------
089A            644   
089A            645   ;***CHECK TEMPERATURE BY READING VOLTAGE AND CONVERTING
089A            646   Check_Temp:
089A            647       
089A            648       ;jnb one_seconds_flag, Check_Temp_done
089A            649       ;clr one_seconds_flag
089A            650       
089A C297       651       clr CE_ADC
089C 7801       652            mov R0, #00000001B ; Start bit:1
089E 12047B     653            lcall DO_SPI_G
08A1 7880       654            mov R0, #10000000B ; Single ended, read channel 0
08A3 12047B     655            lcall DO_SPI_G
08A6 E9         656            mov a, R1          ; R1 contains bits 8 and 9
08A7 5403       657            anl a, #00000011B  ; We need only the two least significant bits
08A9 F54A       658            mov Result+1, a    ; Save result high.
08AB 7855       659            mov R0, #55H ; It doesn't matter what we transmit...
08AD 12047B     660            lcall DO_SPI_G
08B0 8949       661            mov Result+0, R1     ; R1 contains bits 0 to 7.  Save result low.
08B2 D297       662            setb CE_ADC
08B4            663   
08B4 C002       664            push AR2
08B6 7A0A       664            mov R2, #10
08B8 120039     664            lcall ?Wait_Milli_Seconds
08BB D002       664            pop AR2
08BD            665       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
08BD AE49       666            mov R6, Result+0
08BF AF4A       667            mov R7, Result+1
08C1 22         668   ret
08C2            669   
08C2            670            
08C2            671       ;mov x+2, #0
08C2            672            ;mov x+3, #0
08C2            673            
08C2            674       
08C2            675           ;Load_x(0)
08C2            676           ;mov a, #50
08C2            677       ;calculate_ave:     
08C2            678           ;mov y+0, result+0
08C2            679                ;mov y+1, result+1
08C2            680                ;mov y+2, #0
08C2            681                ;mov y+3, #0
08C2            682       ;djnz a, calculate_ave
08C2            683   
08C2            684   
08C2            685   
08C2            686   
08C2            687       ;Load_y(22)
08C2            688       ;lcall add32
08C2            689   
08C2            690   ;Check_Temp_done_2:
08C2            691       ;jnb one_seconds_flag, Check_Temp_done
08C2            692       ;mov a, result+1
08C2            693       ;Set_Cursor(1,14)
08C2            694       ;lcall SendToLCD 
08C2            695       ;Set_Cursor(1,14)
08C2            696       ;mov a, x+0
08C2            697       ;lcall SendToLCD
08C2            698       ;mov Temp_oven, a
08C2            699       
08C2            700       ;mov a, States
08C2            701       ;cjne a, #0, Display_Temp_BCD
08C2            702       ;sjmp Send_Temp_Port
08C2            703            
08C2            704       ; The 4-bytes of x have the temperature in binary
08C2            705   
08C2            706       ;mov Temp_oven, x+0 ;save the temperature
08C2            707   
08C2            708   ;Display_Temp_BCD:
08C2            709   ;        lcall hex2bcd ; converts binary in x to BCD in BCD
08C2            710   
08C2            711   ;    lcall Display_3_digit_BCD
08C2            712   
08C2            713   ;Send_Temp_Port:
08C2            714   ;    Send_BCD(bcd+4)
08C2            715   ;    Send_BCD(bcd+3)
08C2            716   ;    Send_BCD(bcd+2)
08C2            717   ;        Send_BCD(bcd+1)
08C2            718   ;    Send_BCD(bcd+0);
08C2            719   ;        mov a, #'\r'
08C2            720   ;        lcall putchar
08C2            721   ;        mov a, #'\n'
08C2            722   ;        lcall putchar
08C2            723   ;Check_Temp_done:
08C2            724   ;ret
08C2            725       
08C2            726   ;***CALCULATES THE TEMPERATURE
08C2            727   Average_Temp:
08C2 753C00     728            mov x+0, #low (0 % 0x10000) 
08C5 753D00     728            mov x+1, #high(0 % 0x10000) 
08C8 753E00     728            mov x+2, #low (0 / 0x10000) 
08CB 753F00     728            mov x+3, #high(0 / 0x10000) 
08CE 7D64       729       mov R5, #100
08D0            730   Ave_loop:
08D0 12089A     731       lcall Check_Temp
08D3 754300     732       mov y+3, #0
08D6 754200     733       mov y+2, #0
08D9 8F41       734       mov y+1, R7
08DB 8E40       735       mov y+0, R6
08DD 1201B5     736       lcall add32
08E0 12094E     737       lcall Wait10us
08E3 DDEB       738       djnz R5, Ave_Loop
08E5 754064     739            mov y+0, #low (100 % 0x10000) 
08E8 754100     739            mov y+1, #high(100 % 0x10000) 
08EB 754200     739            mov y+2, #low (100 / 0x10000) 
08EE 754300     739            mov y+3, #high(100 / 0x10000) 
08F1 1202F7     740       lcall div32
08F4            741   
08F4            742       ;**INSERT MATH FUNCTIONS
08F4            743   
08F4            744       ;load_Y(410)
08F4            745            ;lcall mul32
08F4            746            ; Divide result by 1023
08F4            747            ; Subtract 273 + 5 from result to get temperature while accounting for offset
08F4            748            ;load_Y(278)
08F4            749            ;lcall sub32
08F4            750   
08F4 754016     751            mov y+0, #low (22 % 0x10000) 
08F7 754100     751            mov y+1, #high(22 % 0x10000) 
08FA 754200     751            mov y+2, #low (22 / 0x10000) 
08FD 754300     751            mov y+3, #high(22 / 0x10000) 
0900 1201B5     752       lcall add32
0903            753   
0903 853C3B     754       mov Temp_oven, x+0
0906            755   
0906            756   Display_Temp_BCD:
0906 1200F0     757            lcall hex2bcd ; converts binary in x to BCD in BCD
0909            758   
0909 1207F3     759       lcall Display_3_digit_BCD
090C            760   
090C            761   Send_Temp_Port:
090C            762       ;Send_BCD(bcd+4)
090C            763       ;Send_BCD(bcd+3)
090C            764       ;Send_BCD(bcd+2)
090C C000       765       push ar0
090E A845       765       mov r0, bcd+1
0910 1200DA     765       lcall ?Send_BCD
0913 D000       765       pop ar0
0915            765   
0915 C000       766       push ar0
0917 A844       766       mov r0, bcd+0
0919 1200DA     766       lcall ?Send_BCD
091C D000       766       pop ar0
091E            766   
091E 740D       767            mov a, #'\r'
0920 120505     768            lcall putchar
0923 740A       769            mov a, #'\n'
0925 120505     770            lcall putchar
0928            771   Check_Temp_done:
0928 22         772   ret    
0929            773   
0929            774   ;-------------------------------------------------------------------------------------------------------------------------------
0929            775   
0929            776   ;Time wait
0929            777   
0929            778   Wait_One_Second:
0929 C002       779            push AR2
092B 7AFA       779            mov R2, #250
092D 120039     779            lcall ?Wait_Milli_Seconds
0930 D002       779            pop AR2
0932 C002       780            push AR2
0934 7AFA       780            mov R2, #250
0936 120039     780            lcall ?Wait_Milli_Seconds
0939 D002       780            pop AR2
093B C002       781            push AR2
093D 7AFA       781            mov R2, #250
093F 120039     781            lcall ?Wait_Milli_Seconds
0942 D002       781            pop AR2
0944 C002       782            push AR2
0946 7AFA       782            mov R2, #250
0948 120039     782            lcall ?Wait_Milli_Seconds
094B D002       782            pop AR2
094D 22         783   ret
094E            784   
094E            785   Wait10us:
094E 784A       786       mov R0, #74
0950 D8FE       787       djnz R0, $
0952 22         788   ret
0953            789   ; ==================================================================================================
0953            790   
0953            791   ;-------------------------------------;
0953            792   ; ISR for Timer 1.  Used to playback  ;
0953            793   ; the WAV file stored in the SPI      ;
0953            794   ; flash memory.                       ;
0953            795   ;-------------------------------------;
0953            796   Timer1_ISR:
0953            797            ; The registers used in the ISR must be saved in the stack
0953 C0E0       798            push acc
0955 C0D0       799            push psw
0957            800            
0957            801            ; Check if the play counter is zero.  If so, stop playing sound.
0957 E54B       802            mov a, w+0
0959 454C       803            orl a, w+1
095B 454D       804            orl a, w+2
095D 601E       805            jz stop_playing
095F            806            
095F            807            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
095F 74FF       808            mov a, #0xff
0961 154B       809            dec w+0
0963 B54B07     810            cjne a, w+0, keep_playing
0966 154C       811            dec w+1
0968 B54C02     812            cjne a, w+1, keep_playing
096B 154D       813            dec w+2
096D            814            
096D            815   keep_playing:
096D D2A6       816            setb SPEAKER
096F 120494     817            lcall Send_SPI ; Read the next byte from the SPI Flash...
0972 F580       818            mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
0974 2480       819            add a, #0x80
0976 F5AD       820            mov DADH, a ; Output to DAC. DAC output is pin P2.3
0978 43A440     821            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
097B 800A       822            sjmp Timer1_ISR_Done
097D            823   
097D            824   stop_playing:
097D C28E       825            clr TR1 ; Stop timer 1
097F            826            ;setb FLASH_CE  ; Disable SPI Flash
097F C2A6       827            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
0981 75AD80     828            mov DADH, #0x80 ; middle of range
0984 43A440     829            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0987            830   
0987            831   Timer1_ISR_Done:         
0987 D0D0       832            pop psw
0989 D0E0       833            pop acc
098B 32         834            reti
098C            835   ; ==================================================================================================
098C            836   
098C            837   ;---------------------------------;
098C            838   ; Routine to initialize the ISR   ;
098C            839   ; for timer 2                     ;
098C            840   ;---------------------------------;
098C            841   Timer2_init:
098C 75C800     842       mov T2CON, #0
098F 75CDA9     843       mov TH2, #high(TIMER2_RELOAD)
0992 75CC9A     844       mov TL2, #low(TIMER2_RELOAD)
0995            845   
0995 75CBA9     846       mov RCAP2H, #high(TIMER2_RELOAD)
0998 75CA9A     847       mov RCAP2L, #low(TIMER2_RELOAD)
099B            848   
099B E4         849       clr a
099C F530       850       mov Count1ms+0, a
099E F531       851       mov Count1ms+1, a
09A0 F532       852       mov Count5sec , a
09A2 D2AD       853       setb ET2
09A4 D2CA       854       setb TR2
09A6 C202       855       clr enable_clk
09A8 22         856       ret
09A9            857   
09A9            858   ;---------------------------------;
09A9            859   ; ISR for timer 2                 ;
09A9            860   ;---------------------------------;
09A9            861   Timer2_ISR:
09A9 C2CF       862       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
09AB B290       863       cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
09AD            864            
09AD            865            ; The two registers used in the ISR must be saved in the stack
09AD C0E0       866       push acc
09AF C0D0       867       push psw
09B1            868            
09B1            869            ; Increment the 16-bit one mili second counter
09B1 0530       870            inc Count1ms+0    ; Increment the low 8-bits first
09B3 E530       871            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
09B5 7002       872            jnz Inc_Done
09B7 0531       873            inc Count1ms+1
09B9            874   
09B9            875   Inc_Done:
09B9            876   
09B9            877   ;**Oven Power Output-------------------
09B9            878       ; Do the PWM thing
09B9            879            ; Check if Count1ms > pwm_ratio (this is a 16-bit compare)
09B9 C3         880            clr c
09BA E54E       881            mov a, pwm_ratio+0
09BC 9530       882            subb a, Count1ms+0
09BE E54F       883            mov a, pwm_ratio+1
09C0 9531       884            subb a, Count1ms+1
09C2            885            ; if Count1ms > pwm_ratio  the carry is set.  Just copy the carry to the pwm output pin:
09C2 9290       886            mov PWM_OUTPUT, c
09C4            887   ;**----------------------------------
09C4            888            ; Check if one second has passed
09C4 E530       889            mov a, Count1ms+0
09C6 B4E836     890            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
09C9 E531       891            mov a, Count1ms+1
09CB B40331     892            cjne a, #high(1000), Timer2_ISR_done
09CE            893            
09CE            894            ; 1000 milliseconds have passed.  Set a flag so the main program knows
09CE D200       895            setb one_seconds_flag ; Let the main program know one second had passed
09D0            896       
09D0 0532       897       inc Count5sec
09D2 E532       898       mov a, Count5sec
09D4 B40505     899       cjne a, #5, Set_5sec_flag_done
09D7 D201       900       setb five_seconds_flag
09D9 E4         901       clr a
09DA F532       902       mov Count5sec, a
09DC            903       
09DC            904   Set_5sec_flag_done:
09DC E4         905            clr a
09DD F530       906            mov Count1ms+0, a
09DF F531       907            mov Count1ms+1, a
09E1            908   
09E1 30021B     909       jnb enable_clk, Timer2_ISR_done ;if the clk is enabled, increment the second. Otherwise skip
09E4            910   ; Increment the run time counter and state time counter
09E4 E538       911            mov a, Run_time_seconds
09E6 2401       912            add a, #0x01
09E8 D4         913            da a
09E9 F538       914       mov Run_time_seconds, a
09EB            915       ;check sec overflow
09EB B4600A     916       cjne a, #0x60, Check_sec_overflow_done
09EE 753800     917       mov Run_time_seconds, #0x00
09F1 E539       918       mov a, Run_time_minutes ;inc min
09F3 2401       919       add a, #1
09F5 D4         920       da a
09F6 F539       921       mov Run_time_minutes, a
09F8            922   Check_sec_overflow_done:
09F8 E53A       923            mov a, State_time
09FA 2401       924            add a, #0x01
09FC D4         925            da a
09FD F53A       926            mov State_time, a
09FF            927   Timer2_ISR_done:
09FF D0D0       928            pop psw
0A01 D0E0       929            pop acc
0A03 32         930            reti
0A04            931   
0A04            932   
0A04            933   ; ==================================================================================================
0A04            934   
0A04            935   main:
0A04 75817F     936       mov SP, #0x7F
0A07 12098C     937       lcall Timer2_Init
0A0A            938       ;lcall INI_SPI
0A0A 120088     939       lcall LCD_4BIT
0A0D 1204ED     940       lcall InitSerialPort
0A10            941       ; In case you decide to use the pins of P0, configure the port in bidirectional mode. Can be ignored
0A10 75E600     942       mov P0M0, #0
0A13 75E700     943       mov P0M1, #0
0A16 D2AF       944       setb EA   ;Enable global enterupt
0A18            945   
0A18 120847     946       lcall Load_Configuration
0A1B            947   
0A1B            948       ;lcall PLAYBACK_TEMP
0A1B            949   
0A1B            950       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0A1B 754E00     951            mov pwm_ratio+0, #low(0)
0A1E 754F00     952            mov pwm_ratio+1, #high(0)
0A21 753300     953       mov States, #0
0A24            954       
0A24            955   state0: ; idle
0A24            956       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0A24 754E00     957            mov pwm_ratio+0, #low(0)
0A27 754F00     958            mov pwm_ratio+1, #high(0)
0A2A            959       ;mov States, #0
0A2A            960   
0A2A            961   ;***initial parameters displayed***
0A2A            962       
0A2A            963       ;Displays Soak Temp and Time
0A2A 120746     964       lcall State0_display
0A2D            965       ;check power on
0A2D 12057D     966       lcall CHECK_POWER
0A30            967       ; check the parameters being pressed
0A30 12050D     968       lcall CHECK_STIME
0A33 120529     969       lcall CHECK_STEMP
0A36 120545     970       lcall CHECK_RTIME
0A39 120561     971       lcall CHECK_RTEMP
0A3C 120810     972       lcall Save_Configuration
0A3F            973       
0A3F            974       ;lcall Check_Temp
0A3F            975   
0A3F 2085E2     976       jb NEXT_STATE_BUTTON, state0
0A42 C002       977            push AR2
0A44 7A32       977            mov R2, #50
0A46 120039     977            lcall ?Wait_Milli_Seconds
0A49 D002       977            pop AR2 ; debounce time
0A4B 2085D6     978            jb NEXT_STATE_BUTTON, state0 ; if button not pressed, loop
0A4E 3085FD     979            jnb NEXT_STATE_BUTTON, $
0A51            980   state0_done:
0A51 753301     981       mov States, #1
0A54 753A00     982       mov State_time, #0
0A57 D202       983       setb enable_clk
0A59            984      
0A59            985        
0A59            986   
0A59            987   state1_beginning:
0A59            988       
0A59            989       ;Start Run Time
0A59 753800     990       mov Run_time_seconds, #0 ; time starts at 0:00
0A5C 753900     991       mov Run_time_minutes, #0
0A5F            992   
0A5F            993       ;***clear the screen and set new display***
0A5F 1206A0     994       lcall Initialize_State_Display
0A62 C0E0       995            push acc
0A64 7407       995            mov a, #7
0A66 14         995            dec a
0A67 1200BD     995            lcall ?Set_Cursor_2 ; Select column and row
0A6A D0E0       995            pop acc
0A6C C083       996            push dph
0A6E C082       996            push dpl
0A70 C0E0       996            push acc
0A72 90044E     996            mov dptr, #Ramp2Soak
0A75 1200B2     996            lcall ?Send_Constant_String
0A78 D0E0       996            pop acc
0A7A D082       996            pop dpl
0A7C D083       996            pop dph; displays current state
0A7E            997   
0A7E            998       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0A7E 754EE8     999            mov pwm_ratio+0, #low(1000)
0A81 754F03    1000            mov pwm_ratio+1, #high(1000)
0A84           1001       
0A84           1002   
0A84           1003   state1: ; ramp to soak
0A84           1004       
0A84           1005       
0A84           1006       ;check power on
0A84 12057D    1007       lcall CHECK_POWER
0A87           1008       
0A87           1009       ;Update Time and Temp
0A87 12071F    1010       lcall Update_Display
0A8A           1011       
0A8A           1012       ;lcall Check_Temp
0A8A           1013   
0A8A 1208C2    1014       lcall Average_Temp
0A8D           1015       
0A8D           1016       ;jnb one_seconds_flag, Check_Temp_done1
0A8D           1017       ;clr one_seconds_flag
0A8D           1018       
0A8D           1019       ;clr CE_ADC
0A8D           1020            ;mov R0, #00000001B ; Start bit:1
0A8D           1021            ;lcall DO_SPI_G
0A8D           1022            ;mov R0, #10000000B ; Single ended, read channel 0
0A8D           1023            ;lcall DO_SPI_G
0A8D           1024            ;mov a, R1          ; R1 contains bits 8 and 9
0A8D           1025            ;anl a, #00000011B  ; We need only the two least significant bits
0A8D           1026            ;mov Result+1, a    ; Save result high.
0A8D           1027            ;mov R0, #55H ; It doesn't matter what we transmit...
0A8D           1028            ;lcall DO_SPI_G
0A8D           1029            ;mov Result+0, R1     ; R1 contains bits 0 to 7.  Save result low.
0A8D           1030            ;setb CE_ADC
0A8D           1031   
0A8D           1032            ;Wait_Milli_Seconds(#10)
0A8D           1033       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
0A8D           1034            ;mov x+0, Result+0
0A8D           1035            ;mov x+1, Result+1
0A8D           1036            
0A8D           1037       
0A8D           1038       ;Load_x(0)
0A8D           1039       ;mov average_count, #50
0A8D           1040   
0A8D           1041       ;calculate_ave:     
0A8D           1042       ;    mov y+0, result+0
0A8D           1043            ;    mov y+1, result+1
0A8D           1044            ;    mov y+2, #0
0A8D           1045            ;    mov y+3, #0
0A8D           1046       ;Wait_Milli_Seconds(#10)
0A8D           1047       ;djnz average_count, calculate_ave
0A8D           1048       ;load_Y(100)
0A8D           1049       ;lcall div32
0A8D           1050   
0A8D           1051       ; Multiply by 410
0A8D           1052            ;load_Y(410)
0A8D           1053            ;lcall mul32
0A8D           1054            ; Divide result by 1023
0A8D           1055            ;load_Y(1023)
0A8D           1056            ;lcall div32
0A8D           1057            ; Subtract 273 + 5 from result to get temperature while accounting for offset
0A8D           1058            ;load_Y(273)
0A8D           1059            ;lcall sub32
0A8D           1060   
0A8D           1061   
0A8D           1062   
0A8D           1063   
0A8D           1064       ;Load_y(22)
0A8D           1065       ;lcall add32
0A8D           1066   
0A8D           1067   ;Check_Temp_done_2:
0A8D           1068       ;jnb one_seconds_flag, Check_Temp_done
0A8D           1069       ;mov a, result+1
0A8D           1070       ;Set_Cursor(1,14)
0A8D           1071       ;lcall SendToLCD 
0A8D           1072       ;Set_Cursor(1,14)
0A8D           1073       ;mov a, x+0
0A8D           1074       ;lcall SendToLCD
0A8D           1075       ;mov Temp_oven, a
0A8D           1076       
0A8D           1077       ;mov a, States
0A8D           1078       ;cjne a, #0, Display_Temp_BCD
0A8D           1079       ;sjmp Send_Temp_Port
0A8D           1080            
0A8D           1081       ; The 4-bytes of x have the temperature in binary
0A8D           1082   ;Display_Temp_BCD1:
0A8D 1200F0    1083            lcall hex2bcd ; converts binary in x to BCD in BCD
0A90           1084   
0A90 1207F3    1085       lcall Display_3_digit_BCD
0A93           1086   
0A93 8003      1087       sjmp Send_Temp_Port1
0A95           1088   
0A95           1089   state1_1:
0A95 020A84    1090       ljmp state1
0A98           1091   
0A98           1092   Send_Temp_Port1:
0A98           1093       ;Send_BCD(bcd+4)
0A98           1094       ;Send_BCD(bcd+3)
0A98           1095       ;Send_BCD(bcd+2)
0A98           1096            ;Send_BCD(bcd+1)
0A98           1097       ;Send_BCD(bcd+0)
0A98           1098            ;mov a, #'\r'
0A98           1099            ;lcall putchar
0A98           1100            ;mov a, #'\n'
0A98           1101            ;lcall putchar
0A98           1102   Check_Temp_done1:
0A98           1103       
0A98           1104   
0A98           1105       ; check if temp is below 150 
0A98           1106       ;MOV A, Temp_soak           
0A98           1107       ;SUBB A, Temp_oven
0A98           1108       ;JNC state1_done    ; if greater, jump to state 2
0A98           1109       ;JZ state1_done ; if equal to, jump to state 2
0A98           1110       ;JC state1 ; if less than, go back to state1
0A98           1111   
0A98           1112   ;*Checking moving to states with buttons---- 
0A98           1113   ;*Will remove after proper temperature reading----
0A98           1114   
0A98 2085FA    1115       jb NEXT_STATE_BUTTON, state1_1
0A9B C002      1116            push AR2
0A9D 7A32      1116            mov R2, #50
0A9F 120039    1116            lcall ?Wait_Milli_Seconds
0AA2 D002      1116            pop AR2 ; debounce time
0AA4 2085EE    1117            jb NEXT_STATE_BUTTON, state1_1 ; if button not pressed, loop
0AA7 3085FD    1118            jnb NEXT_STATE_BUTTON, $ 
0AAA           1119   
0AAA           1120   state1_done:
0AAA 753302    1121       mov States, #2
0AAD           1122       ;set State_time = 0
0AAD 8000      1123       sjmp state2_beginning
0AAF           1124   
0AAF           1125   ;OFF_STATE2:
0AAF           1126       ;ljmp OFF_STATE
0AAF           1127   
0AAF           1128   ; preheat/soak
0AAF           1129   state2_beginning: 
0AAF 753A00    1130       mov State_time, #0x00 ;clear the state time
0AB2           1131       ;***clear the screen and set new display***
0AB2 1206A0    1132       lcall Initialize_State_Display
0AB5 C0E0      1133            push acc
0AB7 7407      1133            mov a, #7
0AB9 14        1133            dec a
0ABA 1200BD    1133            lcall ?Set_Cursor_2 ; Select column and row
0ABD D0E0      1133            pop acc
0ABF C083      1134            push dph
0AC1 C082      1134            push dpl
0AC3 C0E0      1134            push acc
0AC5 900458    1134            mov dptr, #Soak
0AC8 1200B2    1134            lcall ?Send_Constant_String
0ACB D0E0      1134            pop acc
0ACD D082      1134            pop dpl
0ACF D083      1134            pop dph ;displays current state
0AD1           1135   
0AD1           1136       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
0AD1 754EC8    1137            mov pwm_ratio+0, #low(200)
0AD4 754F00    1138            mov pwm_ratio+1, #high(000)
0AD7           1139   
0AD7           1140   state2:
0AD7           1141       ;check power on
0AD7 12057D    1142       lcall CHECK_POWER
0ADA           1143       
0ADA           1144       ;Update Time and Temp
0ADA 12071F    1145       lcall Update_Display
0ADD           1146   
0ADD           1147       ;Set_Cursor(1,14)
0ADD           1148       ;mov a, Temp_oven
0ADD           1149       ;lcall SendToLCD
0ADD           1150       
0ADD           1151       ;check temperature
0ADD           1152       ;lcall Average_Temp
0ADD           1153       
0ADD           1154       
0ADD           1155       
0ADD           1156       ; loop back to state2 if run time is less than soak time. If greater than jump to state3 cuz of overflow of time
0ADD           1157        
0ADD           1158       ;mov a, State_time
0ADD           1159       ;subb a, Soak_time
0ADD           1160       ;jnc state2_done
0ADD           1161       ;jc state2
0ADD           1162   
0ADD           1163   
0ADD           1164   ;*Checking moving to states with buttons---- 
0ADD           1165   ;*Will remove after proper temperature reading----
0ADD           1166   
0ADD 2085F7    1167       jb NEXT_STATE_BUTTON, state2
0AE0 C002      1168            push AR2
0AE2 7A32      1168            mov R2, #50
0AE4 120039    1168            lcall ?Wait_Milli_Seconds
0AE7 D002      1168            pop AR2 ; debounce time
0AE9 2085EB    1169            jb NEXT_STATE_BUTTON, state2 ; if button not pressed, loop
0AEC 3085FD    1170            jnb NEXT_STATE_BUTTON, $ 
0AEF           1171       
0AEF           1172   state2_done:
0AEF 753A00    1173       mov State_time, #0
0AF2 020AF5    1174       ljmp state3_beginning
0AF5           1175   
0AF5           1176   ; ramp to peak
0AF5           1177   state3_beginning:
0AF5 D287      1178       setb OVEN_POWER ;turn power on 100%
0AF7           1179   
0AF7           1180       ;***clear the screen and set new display***
0AF7 1206A0    1181       lcall Initialize_State_Display
0AFA C0E0      1182            push acc
0AFC 7407      1182            mov a, #7
0AFE 14        1182            dec a
0AFF 1200BD    1182            lcall ?Set_Cursor_2 ; Select column and row
0B02 D0E0      1182            pop acc
0B04 C083      1183            push dph
0B06 C082      1183            push dpl
0B08 C0E0      1183            push acc
0B0A 90045D    1183            mov dptr, #Ramp2Peak
0B0D 1200B2    1183            lcall ?Send_Constant_String
0B10 D0E0      1183            pop acc
0B12 D082      1183            pop dpl
0B14 D083      1183            pop dph
0B16           1184   
0B16           1185       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0B16 754EE8    1186            mov pwm_ratio+0, #low(1000)
0B19 754F03    1187            mov pwm_ratio+1, #high(1000)
0B1C           1188   
0B1C           1189   state3: 
0B1C           1190       ;check power on
0B1C 12057D    1191       lcall CHECK_POWER
0B1F           1192       
0B1F           1193       
0B1F           1194       ;Update Time and Temp
0B1F 12071F    1195       lcall Update_Display
0B22           1196       
0B22           1197       ;mov a, Temp_oven
0B22           1198       ;subb a, Temp_refl 
0B22           1199       ;JNC state3_done    ; if greater, jump to state 4
0B22           1200       ;JZ state3_done ; if equal to, jump to state 4
0B22           1201       ;JC state3 ; if less than, go back to state3
0B22           1202       
0B22 2085F7    1203       jb NEXT_STATE_BUTTON, state3
0B25 C002      1204            push AR2
0B27 7A32      1204            mov R2, #50
0B29 120039    1204            lcall ?Wait_Milli_Seconds
0B2C D002      1204            pop AR2 ; debounce time
0B2E 2085EB    1205            jb NEXT_STATE_BUTTON, state3 ; if button not pressed, loop
0B31 3085FD    1206            jnb NEXT_STATE_BUTTON, $
0B34           1207   
0B34           1208   state3_done:
0B34 753A00    1209       mov State_time, #0
0B37 020B3A    1210       ljmp state4_beginning
0B3A           1211   
0B3A           1212   
0B3A           1213   ; reflow 
0B3A           1214   state4_beginning:
0B3A           1215       ;***clear the screen and set new display***
0B3A 1206A0    1216       lcall Initialize_State_Display
0B3D C0E0      1217            push acc
0B3F 7407      1217            mov a, #7
0B41 14        1217            dec a
0B42 1200BD    1217            lcall ?Set_Cursor_2 ; Select column and row
0B45 D0E0      1217            pop acc
0B47 C083      1218            push dph
0B49 C082      1218            push dpl
0B4B C0E0      1218            push acc
0B4D 900467    1218            mov dptr, #Reflow
0B50 1200B2    1218            lcall ?Send_Constant_String
0B53 D0E0      1218            pop acc
0B55 D082      1218            pop dpl
0B57 D083      1218            pop dph
0B59           1219   
0B59           1220       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
0B59 754EC8    1221            mov pwm_ratio+0, #low(200)
0B5C 754F00    1222            mov pwm_ratio+1, #high(000)
0B5F           1223   
0B5F           1224   
0B5F           1225   state4:
0B5F           1226       ;check power on
0B5F 12057D    1227       lcall CHECK_POWER
0B62           1228       ;Update Time and Temp
0B62 12071F    1229       lcall Update_Display
0B65           1230   
0B65           1231       ;on
0B65           1232       ;setb OVEN_POWER
0B65           1233       ;lcall Wait_One_Second
0B65           1234       ;off
0B65           1235       ;clr OVEN_POWER
0B65           1236       ;mov r5, #0
0B65           1237       ;four_sec_loop2:
0B65           1238           ; loop back to state2 if run time is less than soak time
0B65           1239       ;    mov a, Time_refl
0B65           1240       ;    subb a, State_time
0B65           1241       ;   cjne a, #0, state4
0B65           1242       ;    Set_Cursor(1, 5)
0B65           1243            ;    Display_BCD(Run_time_minutes)
0B65           1244       ;    Set_Cursor(1,7)
0B65           1245       ;    Display_BCD(Run_time_seconds)
0B65           1246       ;    Wait_Milli_Seconds(#250)
0B65           1247   
0B65           1248       ;    inc r5
0B65           1249       ;    cjne r5, #16, four_sec_loop2
0B65           1250           
0B65           1251       
0B65           1252       ; loop back to state2 if run time is less than soak time
0B65           1253       ;mov a, Time_refl
0B65           1254       ;subb a, State_time
0B65           1255       ;cjne a, #0, state4
0B65           1256   
0B65           1257       ;*Checking moving to states with buttons---- 
0B65           1258   ;*Will remove after proper temperature reading----
0B65           1259   
0B65 2085F7    1260       jb NEXT_STATE_BUTTON, state4
0B68 C002      1261            push AR2
0B6A 7A32      1261            mov R2, #50
0B6C 120039    1261            lcall ?Wait_Milli_Seconds
0B6F D002      1261            pop AR2 ; debounce time
0B71 2085EB    1262            jb NEXT_STATE_BUTTON, state4 ; if button not pressed, loop
0B74 3085FD    1263            jnb NEXT_STATE_BUTTON, $ 
0B77           1264   
0B77           1265   state4_done: 
0B77 753A00    1266       mov State_time, #0
0B7A 020B7D    1267       ljmp state5_beginning 
0B7D           1268   
0B7D           1269   
0B7D           1270   ; cooling
0B7D           1271   state5_beginning: ; turn oven off
0B7D C287      1272       clr OVEN_POWER
0B7F           1273   
0B7F           1274   ;***clear the screen and set new display***
0B7F 1206A0    1275       lcall Initialize_State_Display
0B82 C083      1276            push dph
0B84 C082      1276            push dpl
0B86 C0E0      1276            push acc
0B88 90046E    1276            mov dptr, #Cooling
0B8B 1200B2    1276            lcall ?Send_Constant_String
0B8E D0E0      1276            pop acc
0B90 D082      1276            pop dpl
0B92 D083      1276            pop dph
0B94           1277   
0B94           1278       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0B94 754E00    1279            mov pwm_ratio+0, #low(0)
0B97 754F00    1280            mov pwm_ratio+1, #high(0)
0B9A           1281   
0B9A           1282   state5:
0B9A           1283       ;check power on
0B9A 12057D    1284       lcall CHECK_POWER
0B9D           1285       
0B9D           1286       ; update display
0B9D 12071F    1287       lcall Update_Display
0BA0           1288   
0BA0           1289       ;mov a, Temp_oven
0BA0           1290       ;subb a, #60
0BA0           1291       ;JNC state5    ; if greater, jump back to state 5
0BA0           1292       ;JZ state5 ; if equal to, go back to state5
0BA0           1293       ;JC state5_done ; if less than, go back to state 0
0BA0           1294   
0BA0           1295       ;*Checking moving to states with buttons---- 
0BA0           1296   ;*Will remove after proper temperature reading----
0BA0           1297   
0BA0 2085F7    1298       jb NEXT_STATE_BUTTON, state5
0BA3 C002      1299            push AR2
0BA5 7A32      1299            mov R2, #50
0BA7 120039    1299            lcall ?Wait_Milli_Seconds
0BAA D002      1299            pop AR2 ; debounce time
0BAC 2085EB    1300            jb NEXT_STATE_BUTTON, state5 ; if button not pressed, loop
0BAF 3085FD    1301            jnb NEXT_STATE_BUTTON, $ 
0BB2           1302   
0BB2           1303   state5_done:
0BB2 753A00    1304       mov State_time, #0
0BB5 753300    1305       mov States, #0
0BB8 020A04    1306       ljmp main
0BBB           1307   
0BBB           1308   EN
