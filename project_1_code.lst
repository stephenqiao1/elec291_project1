                  2   $LIST
0000              4   
0000              5   
0000              6   ;-------------------------------------------------------------------------------------------------------------------------------
0000              7   ;These EQU must match the wiring between the microcontroller and ADC
0000              8   CLK  EQU 22118400
0000              9   TIMER1_RATE    EQU 25000 ;22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             10   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             11   BAUD equ 115200
0000             12   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000             13   
0000             14   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             15   TIMER2_RELOAD EQU (65536-(CLK/TIMER2_RATE))
0000             16   
0000             17   ;shjfjdfs
0000             18   ;-------------------------------------------------------------------------------------------------------------------------------
0000             19   ;Button Pin Mapping
0000             20   NEXT_STATE_BUTTON  equ P0.5
0000             21   STIME_BUTTON    equ P0.2
0000             22   STEMP_BUTTON    equ P0.3
0000             23   RTIME_BUTTON    equ P0.4
0000             24   RTEMP_BUTTON    equ P0.6
0000             25   
0000             26   POWER_BUTTON    equ P4.5
0000             27   SHIFT_BUTTON    equ p0.1
0000             28   
0000             29   ;Output Pins
0000             30   OVEN_POWER      equ P0.7
0000             31   SPEAKER         equ P2.6
0000             32   
0000             33   PWM_OUTPUT    equ P1.0 ; Attach an LED (with 1k resistor in series) to P1.0
0000             34   
0000             35   
0000             36   ;FLASH pins
0000             37   MY_MOSI_SOUND EQU P2.4
0000             38   MY_MISO_SOUND EQU P2.1
0000             39   MY_SCLK_SOUND EQU P2.0
0000             40   FLASH_CE      EQU P2.5
0000             41   
0000             42   ;Thermowire Pins
0000             43   CE_ADC    EQU  P1.7
0000             44   MY_MOSI   EQU  P1.6
0000             45   MY_MISO   EQU  P1.5
0000             46   MY_SCLK   EQU  P1.4 
0000             47   
0000             48   ; Commands supported by the SPI flash memory according to the datasheet
0000             49   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             50   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             51   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             52   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             53   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             54   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             55   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             56   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             57   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             58   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             59   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             60   
0000             61   ; These 'equ' must match the hardware wiring
0000             62   LCD_RS equ P3.2
0000             63   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
0000             64   LCD_E  equ P3.3
0000             65   LCD_D4 equ P3.4
0000             66   LCD_D5 equ P3.5
0000             67   LCD_D6 equ P3.6
0000             68   LCD_D7 equ P3.7
0000             69   
0000             70   ;-------------------------------------------------------------------------------------------------------------------------------
0000             71   
0000             72   org 0x0000
0000 0210FA      73       ljmp main
0003             74   
0003             75   ; External interrupt 0 vector (not used in this code)
0003             76   org 0x0003
0003 32          77            reti
0004             78   
0004             79   ; Timer/Counter 0 overflow interrupt vector
000B             80   org 0x000B
000B 32          81            reti
000C             82   
000C             83   ; External interrupt 1 vector (not used in this code)
0013             84   org 0x0013
0013 32          85            reti
0014             86   
0014             87   ; Timer/Counter 1 overflow interrupt vector
001B             88   org 0x001B
001B 02104E      89            ljmp Timer1_ISR
001E             90   
001E             91   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             92   org 0x0023 
0023 32          93            reti
0024             94            
0024             95   ; Timer/Counter 2 overflow interrupt vector
002B             96   org 0x002B
002B 0210A4      97       ljmp Timer2_ISR
002E             98   ;-------------------------------------------------------------------------------------------------------------------------------
002E             99   ; Place our variables here
0030            100   DSEG at 0x30 ; Before the state machine!
0030            101   Count1ms:         ds 2 ; Used to determine when one second has passed
0032            102   Count5sec:        ds 1
0033            103   States:           ds 1
0034            104   Temp_soak:        ds 1
0035            105   Time_soak:        ds 1
0036            106   Temp_refl:        ds 1
0037            107   Time_refl:        ds 1
0038            108   Run_time_seconds: ds 1
0039            109   Run_time_minutes: ds 1
003A            110   State_time:       ds 1
003B            111   Temp_oven:        ds 1
003C            112   KTemp_oven:       ds 1
003D            113   x:                ds 4
0041            114   y:                ds 4
0045            115   bcd:              ds 5
004A            116   Result:           ds 2
004C            117   w:                ds 3
004F            118   pwm_ratio:        ds 2
0051            119   average_count:    ds 1
0052            120   K_or_C:           ds 1
0053            121   
                123   $LIST
00F0            125   
                546   $LIST
                127   $LIST
0360            129   
0360            130   ;$NOLIST
0360            131   ;$INCLUDE(sound_for_project1_index.asm)
0360            132   ;$LIST
0360            133   
0000            134   bseg
0000            135   one_seconds_flag:  dbit 1
0001            136   five_seconds_flag: dbit 1
0002            137   enable_clk:        dbit 1
0003            138   mf:                dbit 1
0004            139   ;sound_flag: dbit 1
0004            140   
0360            141   cseg
0360            142   
0360            143   ;-------------------------------------------------------------------------------------------------------------------------------
0360            144   ;***Messages To Display*** 
0360            145   
0360            146   ;shortened labels
0360 53546D70   147   STemp:  db 'STmp:', 0
     3A00
0366 53546D3A   148   STime:  db 'STm:', 0
     00
036B 52546D70   149   RTemp:  db 'RTmp:', 0
     3A00
0371 52546D3A   150   RTime:  db 'RTm:', 0
     00
0376            151   
0376            152   ;lables for runnning oven
0376 53746174   153   state:     db 'State>' , 0
     653E00
037D 546D653E   154   time:      db 'Tme>' , 0
     00
0382 3A00       155   colon:     db ':', 0
0384 546D703E   156   temp:      db 'Tmp>', 0
     00
0389            157   
0389            158   ;labels for changin parameters
0389 5265666C   159   ReflowTemp:  db 'Reflow Temperature:', 0
     6F772054
     656D7065
     72617475
     72653A00
039D 5265666C   160   ReflowTime:  db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03AA 536F616B   161   SoakTime:    db 'Soak Time:', 0
     2054696D
     653A00
03B5 536F616B   162   SoakTemp:    db 'Soak Temperature:', 0
     2054656D
     70657261
     74757265
     3A00
03C7            163   
03C7            164   
03C7            165   ;Current State in Oven
03C7 52616D70   166   Ramp2Soak: db 'Ramp-Soak' , 0
     2D536F61
     6B00
03D1 536F616B   167   Soak:      db 'Soak' , 0
     00
03D6 52616D70   168   Ramp2Peak: db 'Ramp-Peak' , 0
     2D506561
     6B00
03E0 5265666C   169   Reflow:    db 'Reflow' , 0
     6F7700
03E7 436F6F6C   170   Cooling:   db 'Cooling' , 0
     696E6700
03EF            171   
03EF            172   ;-------------------------------------------------------------------------------------------------------------------------------
03EF            173   ;FXNS FOR THERMOWIRE
03EF            174   
03EF            175   ;initialize SPI 
03EF            176   INI_SPI:
03EF D295       177            setb MY_MISO          ; Make MISO an input pin
03F1 C294       178            clr MY_SCLK           ; Mode 0,0 default
03F3 22         179            ret
03F4            180   DO_SPI_G:
03F4 C0E0       181            push acc
03F6 7900       182            mov R1, #0            ; Received byte stored in R1
03F8 7A08       183            mov R2, #8            ; Loop counter (8-bits)
03FA            184   DO_SPI_G_LOOP:
03FA E8         185            mov a, R0             ; Byte to write is in R0
03FB 33         186            rlc a                 ; Carry flag has bit to write
03FC F8         187            mov R0, a
03FD 9296       188            mov MY_MOSI, c
03FF D294       189            setb MY_SCLK          ; Transmit
0401 A295       190            mov c, MY_MISO        ; Read received bit
0403 E9         191            mov a, R1             ; Save received bit in R1
0404 33         192            rlc a
0405 F9         193            mov R1, a
0406 C294       194            clr MY_SCLK
0408 DAF0       195            djnz R2, DO_SPI_G_LOOP
040A D0E0       196            pop acc
040C 22         197   ret
040D            198   
040D            199   Send_SPI:
                200   	SPIBIT MAC
                201   	    ; Send/Receive bit %0
                202   		rlc a
                203   		mov MY_MOSI_SOUND, c
                204   		setb MY_SCLK_SOUND
                205   		mov c, MY_MISO_SOUND
                206   		clr MY_SCLK_SOUND
                207   		mov acc.0, c
                208   	ENDMAC
040D            209            
040D            210                ; Send/Receive bit 7
040D 33         210                    rlc a
040E 92A4       210                    mov MY_MOSI_SOUND, c
0410 D2A0       210                    setb MY_SCLK_SOUND
0412 A2A1       210                    mov c, MY_MISO_SOUND
0414 C2A0       210                    clr MY_SCLK_SOUND
0416 92E0       210                    mov acc.0, c
0418            211                ; Send/Receive bit 6
0418 33         211                    rlc a
0419 92A4       211                    mov MY_MOSI_SOUND, c
041B D2A0       211                    setb MY_SCLK_SOUND
041D A2A1       211                    mov c, MY_MISO_SOUND
041F C2A0       211                    clr MY_SCLK_SOUND
0421 92E0       211                    mov acc.0, c
0423            212                ; Send/Receive bit 5
0423 33         212                    rlc a
0424 92A4       212                    mov MY_MOSI_SOUND, c
0426 D2A0       212                    setb MY_SCLK_SOUND
0428 A2A1       212                    mov c, MY_MISO_SOUND
042A C2A0       212                    clr MY_SCLK_SOUND
042C 92E0       212                    mov acc.0, c
042E            213                ; Send/Receive bit 4
042E 33         213                    rlc a
042F 92A4       213                    mov MY_MOSI_SOUND, c
0431 D2A0       213                    setb MY_SCLK_SOUND
0433 A2A1       213                    mov c, MY_MISO_SOUND
0435 C2A0       213                    clr MY_SCLK_SOUND
0437 92E0       213                    mov acc.0, c
0439            214                ; Send/Receive bit 3
0439 33         214                    rlc a
043A 92A4       214                    mov MY_MOSI_SOUND, c
043C D2A0       214                    setb MY_SCLK_SOUND
043E A2A1       214                    mov c, MY_MISO_SOUND
0440 C2A0       214                    clr MY_SCLK_SOUND
0442 92E0       214                    mov acc.0, c
0444            215                ; Send/Receive bit 2
0444 33         215                    rlc a
0445 92A4       215                    mov MY_MOSI_SOUND, c
0447 D2A0       215                    setb MY_SCLK_SOUND
0449 A2A1       215                    mov c, MY_MISO_SOUND
044B C2A0       215                    clr MY_SCLK_SOUND
044D 92E0       215                    mov acc.0, c
044F            216                ; Send/Receive bit 1
044F 33         216                    rlc a
0450 92A4       216                    mov MY_MOSI_SOUND, c
0452 D2A0       216                    setb MY_SCLK_SOUND
0454 A2A1       216                    mov c, MY_MISO_SOUND
0456 C2A0       216                    clr MY_SCLK_SOUND
0458 92E0       216                    mov acc.0, c
045A            217                ; Send/Receive bit 0
045A 33         217                    rlc a
045B 92A4       217                    mov MY_MOSI_SOUND, c
045D D2A0       217                    setb MY_SCLK_SOUND
045F A2A1       217                    mov c, MY_MISO_SOUND
0461 C2A0       217                    clr MY_SCLK_SOUND
0463 92E0       217                    mov acc.0, c
0465            218   
0465 22         219   ret
0466            220   
                221   Change_8bit_Variable MAC
                222       jb %0, %2
                223       Wait_Milli_Seconds(#50) ; de-bounce
                224       jb %0, %2
                225       jnb %0, $
                226       jb SHIFT_BUTTON, skip%Mb
                227       dec %1
                228       sjmp skip%Ma
                229       skip%Mb:
                230       inc %1
                231       skip%Ma:
                232   ENDMAC
0466            233   
0466            234   ;Change_8bit_Variable(MY_VARIABLE_BUTTON, my_variable, loop_c)
0466            235   ;    Set_Cursor(2, 14)
0466            236   ;    mov a, my_variable
0466            237   ;    lcall SendToLCD
0466            238   ;lcall Save_Configuration
0466            239   
0466            240   ;-------------------------------------------------------------------------------------------------------------------------------
0466            241   ;***FXNS For Serial Port
0466            242   
0466            243   ; Configure the serial port and baud rate
0466            244   InitSerialPort:
0466            245       ; Since the reset button bounces, we need to wait a bit before
0466            246       ; sending messages, otherwise we risk displaying gibberish!
0466 79DE       247       mov R1, #222
0468 78A6       248       mov R0, #166
046A D8FE       249       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
046C D9FA       250       djnz R1, $-4 ; 22.51519us*222=4.998ms
046E            251       ; Now we can proceed with the configuration
046E 438780     252            orl     PCON,#0x80
0471 759852     253            mov     SCON,#0x52
0474 759B00     254            mov     BDRCON,#0x00
0477 759AF4     255            mov     BRL,#BRG_VAL
047A 759B1E     256            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
047D 22         257   ret
047E            258   
047E            259   
047E            260   putchar:
047E 3099FD     261       jnb TI, putchar
0481 C299       262       clr TI
0483 F599       263       mov SBUF, a
0485 22         264   ret
0486            265   
0486            266   ;-------------------------------------------------------------------------------------------------------------------------------
0486            267   ;***FXNS to CHECK BUTTONS
0486            268   
0486            269   CHECK_STIME:
0486            270   
0486 208218     271       jb STIME_BUTTON, CHECK_STIME_END
0489 C002       271            push AR2
048B 7A32       271            mov R2, #50
048D 120039     271            lcall ?Wait_Milli_Seconds
0490 D002       271            pop AR2 ; de-bounce
0492 20820C     271       jb STIME_BUTTON, CHECK_STIME_END
0495 3082FD     271       jnb STIME_BUTTON, $
0498 208104     271       jb SHIFT_BUTTON, skip16b
049B 1535       271       dec Time_soak
049D 8002       271       sjmp skip16a
049F            271       skip16b:
049F 0535       271       inc Time_soak
04A1            271       skip16a:
04A1            272            
04A1            273   CHECK_STIME_END:
04A1 22         274   ret
04A2            275   
04A2            276   CHECK_STEMP:
04A2 208318     277       jb STEMP_BUTTON, CHECK_STEMP_END
04A5 C002       277            push AR2
04A7 7A32       277            mov R2, #50
04A9 120039     277            lcall ?Wait_Milli_Seconds
04AC D002       277            pop AR2 ; de-bounce
04AE 20830C     277       jb STEMP_BUTTON, CHECK_STEMP_END
04B1 3083FD     277       jnb STEMP_BUTTON, $
04B4 208104     277       jb SHIFT_BUTTON, skip18b
04B7 1534       277       dec Temp_soak
04B9 8002       277       sjmp skip18a
04BB            277       skip18b:
04BB 0534       277       inc Temp_soak
04BD            277       skip18a:
04BD            278       ;lcall Save_Configuration
04BD            279            
04BD            280   CHECK_STEMP_END:
04BD 22         281   ret
04BE            282   
04BE            283   CHECK_RTIME:
04BE 208418     284       jb RTIME_BUTTON, CHECK_RTIME_END
04C1 C002       284            push AR2
04C3 7A32       284            mov R2, #50
04C5 120039     284            lcall ?Wait_Milli_Seconds
04C8 D002       284            pop AR2 ; de-bounce
04CA 20840C     284       jb RTIME_BUTTON, CHECK_RTIME_END
04CD 3084FD     284       jnb RTIME_BUTTON, $
04D0 208104     284       jb SHIFT_BUTTON, skip20b
04D3 1537       284       dec Time_refl
04D5 8002       284       sjmp skip20a
04D7            284       skip20b:
04D7 0537       284       inc Time_refl
04D9            284       skip20a:
04D9            285   CHECK_RTIME_END:
04D9 22         286   ret
04DA            287   
04DA            288   CHECK_RTEMP:
04DA 208618     289       jb RTEMP_BUTTON, CHECK_RTEMP_END
04DD C002       289            push AR2
04DF 7A32       289            mov R2, #50
04E1 120039     289            lcall ?Wait_Milli_Seconds
04E4 D002       289            pop AR2 ; de-bounce
04E6 20860C     289       jb RTEMP_BUTTON, CHECK_RTEMP_END
04E9 3086FD     289       jnb RTEMP_BUTTON, $
04EC 208104     289       jb SHIFT_BUTTON, skip22b
04EF 1536       289       dec Temp_refl
04F1 8002       289       sjmp skip22a
04F3            289       skip22b:
04F3 0536       289       inc Temp_refl
04F5            289       skip22a:
04F5            290   CHECK_RTEMP_END:
04F5 22         291   ret
04F6            292   
04F6            293   CHECK_POWER:
04F6            294   
04F6 20C518     295       jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
04F9 C002       296            push AR2
04FB 7A32       296            mov R2, #50
04FD 120039     296            lcall ?Wait_Milli_Seconds
0500 D002       296            pop AR2 ; debounce time
0502 20C50C     297            jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
0505 30C5FD     298            jnb POWER_BUTTON, $ ; loop while the button is pressed
0508 754F00     299       mov pwm_ratio+0, #low(0)
050B 755000     300            mov pwm_ratio+1, #high(0)
050E 120F49     301       lcall OFF_STATE
0511            302   
0511            303   CHECK_POWER_END:
0511 22         304   ret
0512            305   
0512            306   CHECK_K_OR_C:
0512            307   
0512 20860F     308       jb RTEMP_BUTTON, CHECK_K_OR_C_END ; if button not pressed, stop checking
0515 C002       309            push AR2
0517 7A32       309            mov R2, #50
0519 120039     309            lcall ?Wait_Milli_Seconds
051C D002       309            pop AR2 ; debounce time
051E 208603     310            jb RTEMP_BUTTON, CHECK_K_OR_C_END ; if button not pressed, stop checking
0521 3086FD     311            jnb RTEMP_BUTTON, $ ; loop while the button is pressed
0524            312       
0524            313       ;mov a, K_or_C
0524            314       ;anl a,
0524            315       ;anl a, #00000001B  ; We need only the two least significant bits
0524            316   
0524            317   
0524            318   CHECK_K_OR_C_END:
0524 22         319   ret
0525            320   
0525            321   ; Playback MACRO for sound --------------------------------------------------
0525            322   
                323   PLAYBACK_TEMP MAC
                324       ; ***play audio***
                325       ;cjne sound_flag, #0, $
                326       
                327       lcall Wait_Half_Second
                328       clr TR1 ; Stop Timer 1 ISR from playing previous request
                329       setb FLASH_CE
                330       ;setb sound_flag ; sound starts
                331       clr SPEAKER ; Turn off speaker
                332       clr FLASH_CE ; Enable SPI Flash
                333       mov a, #READ_BYTES
                334       lcall Send_SPI
                335       ; Set the initial position in memory where to start playing
                336       
                337       mov a, %0 ; change initial position
                338       lcall Send_SPI
                339       mov a, %1 ; next memory position
                340       lcall Send_SPI
                341       mov a, %2 ; next memory position
                342       lcall Send_SPI
                343       mov a, %0 ; request first byte to send to DAC
                344       lcall Send_SPI
                345       
                346       ; How many bytes to play?
                347       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
                348       mov w+1, %3 ; Load the middle byte of the number of bytes to play
                349       mov w+0, %4 ; Load the low byte of the number of bytes to play
                350       
                351       
                352       setb SPEAKER ;Turn on speaker
                353       setb TR1 ;Start playback by enabling Timer1
                354       ;clr sound_flag ; sound ends
                355   ENDMAC
0525            356   
0525            357   
0525            358   
0525            359   ;**SOUND STUFF---------------------------------------------------------------
0525            360   
0525            361   SOUND_FSM:
0525            362   state_0_sound:
0525            363   ;check if 5 seconds has passed, if yes go to state 1, if no exit function 
0525 300104     364       jnb five_seconds_flag, Sound_ret
0528 C201       365       clr five_seconds_flag
052A 8001       366       sjmp state_1_sound
052C            367   Sound_ret:
052C 22         368       ret
052D            369   
052D            370   state_1_sound:
052D            371   ; check if temp is greater than or equal to 100, if yes go to state 2
052D            372   ; check if temp is less than 100, if yes go to state 4
052D E53B       373       mov a, Temp_oven
052F 9464       374       subb a, #100
0531 5002       375       jnc state_2_sound_hop
0533 4002       376       jc state_4_sound_hop
0535            377   
0535            378       state_2_sound_hop:
0535 8003       379           sjmp state_2_sound
0537            380   
0537            381       state_4_sound_hop:
0537 020633     382           ljmp state_4_sound
053A            383   
053A            384   state_2_sound:
053A            385   ;divide temp by 100, if it is 1 play sound: "100", if it is 2 play sound: "200"
053A            386   ; go to state_3_sound
053A 75F064     387       mov b, #100
053D E53B       388       mov a, Temp_oven
053F 84         389       div ab
0540 9401       390       subb a, #1
0542 600A       391       jz play_sound_100
0544            392   
0544 75F064     393       mov b, #100
0547 E53B       394       mov a, Temp_oven
0549 84         395       div ab
054A 9402       396       subb a, #2
054C 6065       397       jz play_sound_200
054E            398      
054E            399       play_sound_100: 
054E            400       ; ***play audio***
054E            400       ;cjne sound_flag, #0, $
054E            400       
054E 121036     400       lcall Wait_Half_Second
0551 C28E       400       clr TR1 ; Stop Timer 1 ISR from playing previous request
0553 D2A5       400       setb FLASH_CE
0555            400       ;setb sound_flag ; sound starts
0555 C2A6       400       clr SPEAKER ; Turn off speaker
0557 C2A5       400       clr FLASH_CE ; Enable SPI Flash
0559 7403       400       mov a, #READ_BYTES
055B 12040D     400       lcall Send_SPI
055E            400       ; Set the initial position in memory where to start playing
055E            400       
055E 7401       400       mov a, #0x01 ; change initial position
0560 12040D     400       lcall Send_SPI
0563 7493       400       mov a, #0x93 ; next memory position
0565 12040D     400       lcall Send_SPI
0568 7484       400       mov a, #0x84 ; next memory position
056A 12040D     400       lcall Send_SPI
056D 7401       400       mov a, #0x01 ; request first byte to send to DAC
056F 12040D     400       lcall Send_SPI
0572            400       
0572            400       ; How many bytes to play?
0572 754E00     400       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0575 754D36     400       mov w+1, #0x36 ; Load the middle byte of the number of bytes to play
0578 754CB0     400       mov w+0, #0xb0 ; Load the low byte of the number of bytes to play
057B            400       
057B            400       
057B D2A6       400       setb SPEAKER ;Turn on speaker
057D D28E       400       setb TR1 ;Start playback by enabling Timer1
057F            400       ;clr sound_flag ; sound ends ;one
057F            401       ; ***play audio***
057F            401       ;cjne sound_flag, #0, $
057F            401       
057F 121036     401       lcall Wait_Half_Second
0582 C28E       401       clr TR1 ; Stop Timer 1 ISR from playing previous request
0584 D2A5       401       setb FLASH_CE
0586            401       ;setb sound_flag ; sound starts
0586 C2A6       401       clr SPEAKER ; Turn off speaker
0588 C2A5       401       clr FLASH_CE ; Enable SPI Flash
058A 7403       401       mov a, #READ_BYTES
058C 12040D     401       lcall Send_SPI
058F            401       ; Set the initial position in memory where to start playing
058F            401       
058F 7405       401       mov a, #0x05 ; change initial position
0591 12040D     401       lcall Send_SPI
0594 7409       401       mov a, #0x09 ; next memory position
0596 12040D     401       lcall Send_SPI
0599 7410       401       mov a, #0x10 ; next memory position
059B 12040D     401       lcall Send_SPI
059E 7405       401       mov a, #0x05 ; request first byte to send to DAC
05A0 12040D     401       lcall Send_SPI
05A3            401       
05A3            401       ; How many bytes to play?
05A3 754E00     401       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
05A6 754D27     401       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
05A9 754C10     401       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
05AC            401       
05AC            401       
05AC D2A6       401       setb SPEAKER ;Turn on speaker
05AE D28E       401       setb TR1 ;Start playback by enabling Timer1
05B0            401       ;clr sound_flag ; sound ends ;hundred
05B0 020618     402           ljmp state_3_sound
05B3            403   
05B3            404       play_sound_200:
05B3            405       ; ***play audio***
05B3            405       ;cjne sound_flag, #0, $
05B3            405       
05B3 121036     405       lcall Wait_Half_Second
05B6 C28E       405       clr TR1 ; Stop Timer 1 ISR from playing previous request
05B8 D2A5       405       setb FLASH_CE
05BA            405       ;setb sound_flag ; sound starts
05BA C2A6       405       clr SPEAKER ; Turn off speaker
05BC C2A5       405       clr FLASH_CE ; Enable SPI Flash
05BE 7403       405       mov a, #READ_BYTES
05C0 12040D     405       lcall Send_SPI
05C3            405       ; Set the initial position in memory where to start playing
05C3            405       
05C3 7401       405       mov a, #0x01 ; change initial position
05C5 12040D     405       lcall Send_SPI
05C8 74C7       405       mov a, #0xc7 ; next memory position
05CA 12040D     405       lcall Send_SPI
05CD 7414       405       mov a, #0x14 ; next memory position
05CF 12040D     405       lcall Send_SPI
05D2 7401       405       mov a, #0x01 ; request first byte to send to DAC
05D4 12040D     405       lcall Send_SPI
05D7            405       
05D7            405       ; How many bytes to play?
05D7 754E00     405       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
05DA 754D13     405       mov w+1, #0x13 ; Load the middle byte of the number of bytes to play
05DD 754C88     405       mov w+0, #0x88 ; Load the low byte of the number of bytes to play
05E0            405       
05E0            405       
05E0 D2A6       405       setb SPEAKER ;Turn on speaker
05E2 D28E       405       setb TR1 ;Start playback by enabling Timer1
05E4            405       ;clr sound_flag ; sound ends ;two
05E4            406       ; ***play audio***
05E4            406       ;cjne sound_flag, #0, $
05E4            406       
05E4 121036     406       lcall Wait_Half_Second
05E7 C28E       406       clr TR1 ; Stop Timer 1 ISR from playing previous request
05E9 D2A5       406       setb FLASH_CE
05EB            406       ;setb sound_flag ; sound starts
05EB C2A6       406       clr SPEAKER ; Turn off speaker
05ED C2A5       406       clr FLASH_CE ; Enable SPI Flash
05EF 7403       406       mov a, #READ_BYTES
05F1 12040D     406       lcall Send_SPI
05F4            406       ; Set the initial position in memory where to start playing
05F4            406       
05F4 7405       406       mov a, #0x05 ; change initial position
05F6 12040D     406       lcall Send_SPI
05F9 7409       406       mov a, #0x09 ; next memory position
05FB 12040D     406       lcall Send_SPI
05FE 7410       406       mov a, #0x10 ; next memory position
0600 12040D     406       lcall Send_SPI
0603 7405       406       mov a, #0x05 ; request first byte to send to DAC
0605 12040D     406       lcall Send_SPI
0608            406       
0608            406       ; How many bytes to play?
0608 754E00     406       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
060B 754D27     406       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
060E 754C10     406       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0611            406       
0611            406       
0611 D2A6       406       setb SPEAKER ;Turn on speaker
0613 D28E       406       setb TR1 ;Start playback by enabling Timer1
0615            406       ;clr sound_flag ; sound ends ;hundred
0615 020618     407           ljmp state_3_sound
0618            408   
0618            409   state_3_sound:
0618            410   ; check remainder of temp, if it is 0, exit
0618            411   ; if not 0, go to state_4_sound
0618            412   
0618            413   
0618 75F064     414       mov b, #100
061B E53B       415       mov a, Temp_oven
061D 95F0       416       subb a, b
061F E5F0       417       mov a, b
0621 600D       418       jz state_3_sound_hop
0623            419       
0623 75F0C8     420       mov b, #200
0626 E53B       421       mov a, Temp_oven
0628 95F0       422       subb a, b
062A E5F0       423       mov a, b
062C 6002       424       jz state_3_sound_hop
062E            425   
062E 8003       426       sjmp state_4_sound
0630            427   
0630            428       state_3_sound_hop:
0630 02052C     429           ljmp Sound_ret
0633            430   
0633            431   state_4_sound:
0633            432   ; if T % 100 greater or equal to 20, go to state_5_sound,
0633 75F064     433       mov b, #100
0636 E53B       434       mov a, Temp_oven
0638 84         435       div ab
0639            436       ;mov R0, b
0639 E5F0       437       mov a, b 
063B            438   
063B            439   
063B 9414       440       subb a, #20
063D 5027       441       jnc state_5_sound
063F 6025       442       jz state_5_sound
0641 E4         443       clr a
0642            444   ; if T % 100 is less than 10, go to state_6_sound
0642 75F064     445       mov b, #100
0645 E53B       446       mov a, Temp_oven
0647 84         447       div ab
0648 E5F0       448       mov a, b
064A 940A       449       subb a, #10
064C 4015       450       jc state_6_sound_hop0
064E            451       
064E            452       ;mov a, b
064E            453       
064E            454       ; ubb a, #0
064E            455       ;jc state_6_sound_hop0
064E            456       ;clr a
064E            457   ; if T % 100 is greater than or equal to 10 and less than 20, go to state_7_sound
064E            458   
064E 75F064     459       mov b, #100
0651 E53B       460       mov a, Temp_oven
0653 84         461       div ab
0654 E5F0       462       mov a, b
0656 940A       463       subb a, #10
0658 6000       464       jz and_branch
065A            465   
065A            466       and_branch:
065A E5F0       467           mov a, b
065C 9414       468           subb a, #20
065E 4000       469           jc state_7_sound_hop0
0660            470       
0660            471       state_7_sound_hop0:
0660 020A27     472           ljmp state_7_sound
0663            473   
0663            474       state_6_sound_hop0:
0663 020827     475           ljmp state_6_sound
0666            476       
0666            477   
0666            478   state_5_sound:
0666            479   ; play number from 20 to 90 in decades (20, 30, 40, 50, 60, 70, 80, 90), based off remainder from temp divided by 100
0666            480   ; if (T % 100) % 10 is not equal to 0, go to state_6_sound
0666            481   ; if (T % 100) % 10 is equal to 0, go to state_8_sound
0666            482   
0666            483       play_sound:
0666            484           ;ljmp PLAYBACK_TEMP
0666 E53B       485           mov a, Temp_oven
0668 75F064     486           mov b, #100
066B 84         487           div ab
066C E5F0       488           mov a, b
066E 75F00A     489           mov b, #10
0671 84         490           div ab
0672 B40234     491           cjne a, #2, play_30
0675            492           ;mov    
0675            493   
0675            494           play_20:
0675            495       ; ***play audio***
0675            495       ;cjne sound_flag, #0, $
0675            495       
0675 121036     495       lcall Wait_Half_Second
0678 C28E       495       clr TR1 ; Stop Timer 1 ISR from playing previous request
067A D2A5       495       setb FLASH_CE
067C            495       ;setb sound_flag ; sound starts
067C C2A6       495       clr SPEAKER ; Turn off speaker
067E C2A5       495       clr FLASH_CE ; Enable SPI Flash
0680 7403       495       mov a, #READ_BYTES
0682 12040D     495       lcall Send_SPI
0685            495       ; Set the initial position in memory where to start playing
0685            495       
0685 7403       495       mov a, #0x03 ; change initial position
0687 12040D     495       lcall Send_SPI
068A 74EF       495       mov a, #0xef ; next memory position
068C 12040D     495       lcall Send_SPI
068F 74D0       495       mov a, #0xd0 ; next memory position
0691 12040D     495       lcall Send_SPI
0694 7403       495       mov a, #0x03 ; request first byte to send to DAC
0696 12040D     495       lcall Send_SPI
0699            495       
0699            495       ; How many bytes to play?
0699 754E00     495       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
069C 754D27     495       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
069F 754C10     495       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
06A2            495       
06A2            495       
06A2 D2A6       495       setb SPEAKER ;Turn on speaker
06A4 D28E       495       setb TR1 ;Start playback by enabling Timer1
06A6            495       ;clr sound_flag ; sound ends
06A6            496               ;lcall Wait_One_Second
06A6 020824     497               ljmp state_6_sound_hop1
06A9            498   
06A9            499           play_30:
06A9            500               
06A9 B40334     501               cjne a, #3, play_40   
06AC            502       ; ***play audio***
06AC            502       ;cjne sound_flag, #0, $
06AC            502       
06AC 121036     502       lcall Wait_Half_Second
06AF C28E       502       clr TR1 ; Stop Timer 1 ISR from playing previous request
06B1 D2A5       502       setb FLASH_CE
06B3            502       ;setb sound_flag ; sound starts
06B3 C2A6       502       clr SPEAKER ; Turn off speaker
06B5 C2A5       502       clr FLASH_CE ; Enable SPI Flash
06B7 7403       502       mov a, #READ_BYTES
06B9 12040D     502       lcall Send_SPI
06BC            502       ; Set the initial position in memory where to start playing
06BC            502       
06BC 7404       502       mov a, #0x04 ; change initial position
06BE 12040D     502       lcall Send_SPI
06C1 7416       502       mov a, #0x16 ; next memory position
06C3 12040D     502       lcall Send_SPI
06C6 74E0       502       mov a, #0xe0 ; next memory position
06C8 12040D     502       lcall Send_SPI
06CB 7404       502       mov a, #0x04 ; request first byte to send to DAC
06CD 12040D     502       lcall Send_SPI
06D0            502       
06D0            502       ; How many bytes to play?
06D0 754E00     502       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
06D3 754D23     502       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
06D6 754C28     502       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
06D9            502       
06D9            502       
06D9 D2A6       502       setb SPEAKER ;Turn on speaker
06DB D28E       502       setb TR1 ;Start playback by enabling Timer1
06DD            502       ;clr sound_flag ; sound ends
06DD 020824     503               ljmp state_6_sound_hop1
06E0            504   
06E0            505           play_40:
06E0            506               
06E0 B40434     507               cjne a, #4, play_50  
06E3            508       ; ***play audio***
06E3            508       ;cjne sound_flag, #0, $
06E3            508       
06E3 121036     508       lcall Wait_Half_Second
06E6 C28E       508       clr TR1 ; Stop Timer 1 ISR from playing previous request
06E8 D2A5       508       setb FLASH_CE
06EA            508       ;setb sound_flag ; sound starts
06EA C2A6       508       clr SPEAKER ; Turn off speaker
06EC C2A5       508       clr FLASH_CE ; Enable SPI Flash
06EE 7403       508       mov a, #READ_BYTES
06F0 12040D     508       lcall Send_SPI
06F3            508       ; Set the initial position in memory where to start playing
06F3            508       
06F3 7404       508       mov a, #0x04 ; change initial position
06F5 12040D     508       lcall Send_SPI
06F8 743D       508       mov a, #0x3d ; next memory position
06FA 12040D     508       lcall Send_SPI
06FD 74F0       508       mov a, #0xf0 ; next memory position
06FF 12040D     508       lcall Send_SPI
0702 7404       508       mov a, #0x04 ; request first byte to send to DAC
0704 12040D     508       lcall Send_SPI
0707            508       
0707            508       ; How many bytes to play?
0707 754E00     508       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
070A 754D1F     508       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
070D 754C40     508       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0710            508       
0710            508       
0710 D2A6       508       setb SPEAKER ;Turn on speaker
0712 D28E       508       setb TR1 ;Start playback by enabling Timer1
0714            508       ;clr sound_flag ; sound ends
0714 020824     509               ljmp state_6_sound_hop1
0717            510   
0717            511           play_50:
0717            512              
0717 B40534     513               cjne a, #5, play_60  
071A            514       ; ***play audio***
071A            514       ;cjne sound_flag, #0, $
071A            514       
071A 121036     514       lcall Wait_Half_Second
071D C28E       514       clr TR1 ; Stop Timer 1 ISR from playing previous request
071F D2A5       514       setb FLASH_CE
0721            514       ;setb sound_flag ; sound starts
0721 C2A6       514       clr SPEAKER ; Turn off speaker
0723 C2A5       514       clr FLASH_CE ; Enable SPI Flash
0725 7403       514       mov a, #READ_BYTES
0727 12040D     514       lcall Send_SPI
072A            514       ; Set the initial position in memory where to start playing
072A            514       
072A 7404       514       mov a, #0x04 ; change initial position
072C 12040D     514       lcall Send_SPI
072F 7451       514       mov a, #0x51 ; next memory position
0731 12040D     514       lcall Send_SPI
0734 7478       514       mov a, #0x78 ; next memory position
0736 12040D     514       lcall Send_SPI
0739 7404       514       mov a, #0x04 ; request first byte to send to DAC
073B 12040D     514       lcall Send_SPI
073E            514       
073E            514       ; How many bytes to play?
073E 754E00     514       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0741 754D23     514       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
0744 754C28     514       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0747            514       
0747            514       
0747 D2A6       514       setb SPEAKER ;Turn on speaker
0749 D28E       514       setb TR1 ;Start playback by enabling Timer1
074B            514       ;clr sound_flag ; sound ends
074B 020824     515               ljmp state_6_sound_hop1
074E            516   
074E            517           play_60:
074E            518               
074E B40634     519               cjne a, #6, play_70  
0751            520       ; ***play audio***
0751            520       ;cjne sound_flag, #0, $
0751            520       
0751 121036     520       lcall Wait_Half_Second
0754 C28E       520       clr TR1 ; Stop Timer 1 ISR from playing previous request
0756 D2A5       520       setb FLASH_CE
0758            520       ;setb sound_flag ; sound starts
0758 C2A6       520       clr SPEAKER ; Turn off speaker
075A C2A5       520       clr FLASH_CE ; Enable SPI Flash
075C 7403       520       mov a, #READ_BYTES
075E 12040D     520       lcall Send_SPI
0761            520       ; Set the initial position in memory where to start playing
0761            520       
0761 7404       520       mov a, #0x04 ; change initial position
0763 12040D     520       lcall Send_SPI
0766 7474       520       mov a, #0x74 ; next memory position
0768 12040D     520       lcall Send_SPI
076B 74A0       520       mov a, #0xa0 ; next memory position
076D 12040D     520       lcall Send_SPI
0770 7404       520       mov a, #0x04 ; request first byte to send to DAC
0772 12040D     520       lcall Send_SPI
0775            520       
0775            520       ; How many bytes to play?
0775 754E00     520       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0778 754D27     520       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
077B 754C10     520       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
077E            520       
077E            520       
077E D2A6       520       setb SPEAKER ;Turn on speaker
0780 D28E       520       setb TR1 ;Start playback by enabling Timer1
0782            520       ;clr sound_flag ; sound ends
0782 020824     521               ljmp state_6_sound_hop1
0785            522   
0785            523           play_70:
0785            524              
0785 B40734     525               cjne a, #7, play_80  
0788            526       ; ***play audio***
0788            526       ;cjne sound_flag, #0, $
0788            526       
0788 121036     526       lcall Wait_Half_Second
078B C28E       526       clr TR1 ; Stop Timer 1 ISR from playing previous request
078D D2A5       526       setb FLASH_CE
078F            526       ;setb sound_flag ; sound starts
078F C2A6       526       clr SPEAKER ; Turn off speaker
0791 C2A5       526       clr FLASH_CE ; Enable SPI Flash
0793 7403       526       mov a, #READ_BYTES
0795 12040D     526       lcall Send_SPI
0798            526       ; Set the initial position in memory where to start playing
0798            526       
0798 7404       526       mov a, #0x04 ; change initial position
079A 12040D     526       lcall Send_SPI
079D 749B       526       mov a, #0x9b ; next memory position
079F 12040D     526       lcall Send_SPI
07A2 74B0       526       mov a, #0xb0 ; next memory position
07A4 12040D     526       lcall Send_SPI
07A7 7404       526       mov a, #0x04 ; request first byte to send to DAC
07A9 12040D     526       lcall Send_SPI
07AC            526       
07AC            526       ; How many bytes to play?
07AC 754E00     526       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
07AF 754D32     526       mov w+1, #0x32 ; Load the middle byte of the number of bytes to play
07B2 754CC8     526       mov w+0, #0xc8 ; Load the low byte of the number of bytes to play
07B5            526       
07B5            526       
07B5 D2A6       526       setb SPEAKER ;Turn on speaker
07B7 D28E       526       setb TR1 ;Start playback by enabling Timer1
07B9            526       ;clr sound_flag ; sound ends
07B9 020824     527               ljmp state_6_sound_hop1
07BC            528   
07BC            529           play_80:
07BC            530               
07BC B40834     531               cjne a, #8, play_90  
07BF            532       ; ***play audio***
07BF            532       ;cjne sound_flag, #0, $
07BF            532       
07BF 121036     532       lcall Wait_Half_Second
07C2 C28E       532       clr TR1 ; Stop Timer 1 ISR from playing previous request
07C4 D2A5       532       setb FLASH_CE
07C6            532       ;setb sound_flag ; sound starts
07C6 C2A6       532       clr SPEAKER ; Turn off speaker
07C8 C2A5       532       clr FLASH_CE ; Enable SPI Flash
07CA 7403       532       mov a, #READ_BYTES
07CC 12040D     532       lcall Send_SPI
07CF            532       ; Set the initial position in memory where to start playing
07CF            532       
07CF 7404       532       mov a, #0x04 ; change initial position
07D1 12040D     532       lcall Send_SPI
07D4 74C6       532       mov a, #0xc6 ; next memory position
07D6 12040D     532       lcall Send_SPI
07D9 74A8       532       mov a, #0xa8 ; next memory position
07DB 12040D     532       lcall Send_SPI
07DE 7404       532       mov a, #0x04 ; request first byte to send to DAC
07E0 12040D     532       lcall Send_SPI
07E3            532       
07E3            532       ; How many bytes to play?
07E3 754E00     532       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
07E6 754D23     532       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
07E9 754C28     532       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
07EC            532       
07EC            532       
07EC D2A6       532       setb SPEAKER ;Turn on speaker
07EE D28E       532       setb TR1 ;Start playback by enabling Timer1
07F0            532       ;clr sound_flag ; sound ends
07F0 020824     533               ljmp state_6_sound_hop1
07F3            534   
07F3            535           play_90:
07F3            536       ; ***play audio***
07F3            536       ;cjne sound_flag, #0, $
07F3            536       
07F3 121036     536       lcall Wait_Half_Second
07F6 C28E       536       clr TR1 ; Stop Timer 1 ISR from playing previous request
07F8 D2A5       536       setb FLASH_CE
07FA            536       ;setb sound_flag ; sound starts
07FA C2A6       536       clr SPEAKER ; Turn off speaker
07FC C2A5       536       clr FLASH_CE ; Enable SPI Flash
07FE 7403       536       mov a, #READ_BYTES
0800 12040D     536       lcall Send_SPI
0803            536       ; Set the initial position in memory where to start playing
0803            536       
0803 7404       536       mov a, #0x04 ; change initial position
0805 12040D     536       lcall Send_SPI
0808 74ED       536       mov a, #0xed ; next memory position
080A 12040D     536       lcall Send_SPI
080D 74B8       536       mov a, #0xb8 ; next memory position
080F 12040D     536       lcall Send_SPI
0812 7404       536       mov a, #0x04 ; request first byte to send to DAC
0814 12040D     536       lcall Send_SPI
0817            536       
0817            536       ; How many bytes to play?
0817 754E00     536       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
081A 754D1F     536       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
081D 754C40     536       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0820            536       
0820            536       
0820 D2A6       536       setb SPEAKER ;Turn on speaker
0822 D28E       536       setb TR1 ;Start playback by enabling Timer1
0824            536       ;clr sound_flag ; sound ends
0824            537   
0824            538       ;mov a, Temp_oven
0824            539       ;mov b, #100 
0824            540       ;div ab
0824            541       ;mov a, b
0824            542       ;mov b, #10
0824            543       ;div ab
0824            544       ;mov a, b
0824            545       ;jnz state_6_sound_hop1
0824            546       
0824            547       ;jz play_sound
0824            548       
0824            549       ;lcall Wait_One_Second
0824            550       ;lcall Wait_One_Second
0824            551       ;lcall Wait_One_Second
0824            552   
0824            553   
0824            554       state_6_sound_hop1:
0824 020827     555           ljmp state_6_sound
0827            556           
0827            557       ;state_8_hop0:
0827            558           ;ljmp state_6_sound ;state_8_sound
0827            559   
0827            560   
0827            561   state_6_sound:
0827            562   ; play 1 - 9
0827            563       ;ljmp PLAYBACK_TEMP
0827 75F064     564       mov b, #100
082A E53B       565       mov a, Temp_oven
082C 84         566       div ab
082D E5F0       567       mov a, b
082F 75F00A     568       mov b, #10
0832 84         569       div ab
0833 E5F0       570       mov a, b
0835            571       
0835 B40003     572       cjne a, #0x00, play_1
0838 020A24     573       ljmp state_8_hop1
083B            574   
083B            575       play_1:
083B B40134     576           cjne a, #0x01, play_2
083E            577       ; ***play audio***
083E            577       ;cjne sound_flag, #0, $
083E            577       
083E 121036     577       lcall Wait_Half_Second
0841 C28E       577       clr TR1 ; Stop Timer 1 ISR from playing previous request
0843 D2A5       577       setb FLASH_CE
0845            577       ;setb sound_flag ; sound starts
0845 C2A6       577       clr SPEAKER ; Turn off speaker
0847 C2A5       577       clr FLASH_CE ; Enable SPI Flash
0849 7403       577       mov a, #READ_BYTES
084B 12040D     577       lcall Send_SPI
084E            577       ; Set the initial position in memory where to start playing
084E            577       
084E 7401       577       mov a, #0x01 ; change initial position
0850 12040D     577       lcall Send_SPI
0853 7493       577       mov a, #0x93 ; next memory position
0855 12040D     577       lcall Send_SPI
0858 7484       577       mov a, #0x84 ; next memory position
085A 12040D     577       lcall Send_SPI
085D 7401       577       mov a, #0x01 ; request first byte to send to DAC
085F 12040D     577       lcall Send_SPI
0862            577       
0862            577       ; How many bytes to play?
0862 754E00     577       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0865 754D36     577       mov w+1, #0x36 ; Load the middle byte of the number of bytes to play
0868 754CB0     577       mov w+0, #0xb0 ; Load the low byte of the number of bytes to play
086B            577       
086B            577       
086B D2A6       577       setb SPEAKER ;Turn on speaker
086D D28E       577       setb TR1 ;Start playback by enabling Timer1
086F            577       ;clr sound_flag ; sound ends 
086F 020A24     578           ljmp state_8_hop1
0872            579   
0872            580       play_2:
0872 B40234     581           cjne a, #0x02, play_3
0875            582       ; ***play audio***
0875            582       ;cjne sound_flag, #0, $
0875            582       
0875 121036     582       lcall Wait_Half_Second
0878 C28E       582       clr TR1 ; Stop Timer 1 ISR from playing previous request
087A D2A5       582       setb FLASH_CE
087C            582       ;setb sound_flag ; sound starts
087C C2A6       582       clr SPEAKER ; Turn off speaker
087E C2A5       582       clr FLASH_CE ; Enable SPI Flash
0880 7403       582       mov a, #READ_BYTES
0882 12040D     582       lcall Send_SPI
0885            582       ; Set the initial position in memory where to start playing
0885            582       
0885 7401       582       mov a, #0x01 ; change initial position
0887 12040D     582       lcall Send_SPI
088A 74C7       582       mov a, #0xc7 ; next memory position
088C 12040D     582       lcall Send_SPI
088F 7414       582       mov a, #0x14 ; next memory position
0891 12040D     582       lcall Send_SPI
0894 7401       582       mov a, #0x01 ; request first byte to send to DAC
0896 12040D     582       lcall Send_SPI
0899            582       
0899            582       ; How many bytes to play?
0899 754E00     582       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
089C 754D13     582       mov w+1, #0x13 ; Load the middle byte of the number of bytes to play
089F 754C88     582       mov w+0, #0x88 ; Load the low byte of the number of bytes to play
08A2            582       
08A2            582       
08A2 D2A6       582       setb SPEAKER ;Turn on speaker
08A4 D28E       582       setb TR1 ;Start playback by enabling Timer1
08A6            582       ;clr sound_flag ; sound ends
08A6 020A24     583           ljmp state_8_hop1
08A9            584   
08A9            585       play_3:
08A9 B40334     586           cjne a, #0x03, play_4
08AC            587       ; ***play audio***
08AC            587       ;cjne sound_flag, #0, $
08AC            587       
08AC 121036     587       lcall Wait_Half_Second
08AF C28E       587       clr TR1 ; Stop Timer 1 ISR from playing previous request
08B1 D2A5       587       setb FLASH_CE
08B3            587       ;setb sound_flag ; sound starts
08B3 C2A6       587       clr SPEAKER ; Turn off speaker
08B5 C2A5       587       clr FLASH_CE ; Enable SPI Flash
08B7 7403       587       mov a, #READ_BYTES
08B9 12040D     587       lcall Send_SPI
08BC            587       ; Set the initial position in memory where to start playing
08BC            587       
08BC 7401       587       mov a, #0x01 ; change initial position
08BE 12040D     587       lcall Send_SPI
08C1 74D6       587       mov a, #0xd6 ; next memory position
08C3 12040D     587       lcall Send_SPI
08C6 7468       587       mov a, #0x68 ; next memory position
08C8 12040D     587       lcall Send_SPI
08CB 7401       587       mov a, #0x01 ; request first byte to send to DAC
08CD 12040D     587       lcall Send_SPI
08D0            587       
08D0            587       ; How many bytes to play?
08D0 754E00     587       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
08D3 754D23     587       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
08D6 754C28     587       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
08D9            587       
08D9            587       
08D9 D2A6       587       setb SPEAKER ;Turn on speaker
08DB D28E       587       setb TR1 ;Start playback by enabling Timer1
08DD            587       ;clr sound_flag ; sound ends
08DD 020A24     588           ljmp state_8_hop1
08E0            589   
08E0            590       play_4:
08E0 B40434     591           cjne a, #0x04, play_5
08E3            592       ; ***play audio***
08E3            592       ;cjne sound_flag, #0, $
08E3            592       
08E3 121036     592       lcall Wait_Half_Second
08E6 C28E       592       clr TR1 ; Stop Timer 1 ISR from playing previous request
08E8 D2A5       592       setb FLASH_CE
08EA            592       ;setb sound_flag ; sound starts
08EA C2A6       592       clr SPEAKER ; Turn off speaker
08EC C2A5       592       clr FLASH_CE ; Enable SPI Flash
08EE 7403       592       mov a, #READ_BYTES
08F0 12040D     592       lcall Send_SPI
08F3            592       ; Set the initial position in memory where to start playing
08F3            592       
08F3 7401       592       mov a, #0x01 ; change initial position
08F5 12040D     592       lcall Send_SPI
08F8 74F4       592       mov a, #0xf4 ; next memory position
08FA 12040D     592       lcall Send_SPI
08FD 7400       592       mov a, #0x00 ; next memory position
08FF 12040D     592       lcall Send_SPI
0902 7401       592       mov a, #0x01 ; request first byte to send to DAC
0904 12040D     592       lcall Send_SPI
0907            592       
0907            592       ; How many bytes to play?
0907 754E00     592       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
090A 754D1B     592       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
090D 754C58     592       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
0910            592       
0910            592       
0910 D2A6       592       setb SPEAKER ;Turn on speaker
0912 D28E       592       setb TR1 ;Start playback by enabling Timer1
0914            592       ;clr sound_flag ; sound ends
0914 020A24     593           ljmp state_8_hop1
0917            594   
0917            595       play_5:
0917 B40534     596           cjne a, #0x05, play_6
091A            597       ; ***play audio***
091A            597       ;cjne sound_flag, #0, $
091A            597       
091A 121036     597       lcall Wait_Half_Second
091D C28E       597       clr TR1 ; Stop Timer 1 ISR from playing previous request
091F D2A5       597       setb FLASH_CE
0921            597       ;setb sound_flag ; sound starts
0921 C2A6       597       clr SPEAKER ; Turn off speaker
0923 C2A5       597       clr FLASH_CE ; Enable SPI Flash
0925 7403       597       mov a, #READ_BYTES
0927 12040D     597       lcall Send_SPI
092A            597       ; Set the initial position in memory where to start playing
092A            597       
092A 7402       597       mov a, #0x02 ; change initial position
092C 12040D     597       lcall Send_SPI
092F 7407       597       mov a, #0x07 ; next memory position
0931 12040D     597       lcall Send_SPI
0934 7488       597       mov a, #0x88 ; next memory position
0936 12040D     597       lcall Send_SPI
0939 7402       597       mov a, #0x02 ; request first byte to send to DAC
093B 12040D     597       lcall Send_SPI
093E            597       
093E            597       ; How many bytes to play?
093E 754E00     597       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0941 754D1B     597       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
0944 754C58     597       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
0947            597       
0947            597       
0947 D2A6       597       setb SPEAKER ;Turn on speaker
0949 D28E       597       setb TR1 ;Start playback by enabling Timer1
094B            597       ;clr sound_flag ; sound ends
094B 020A24     598           ljmp state_8_hop1
094E            599   
094E            600       play_6:
094E B40634     601           cjne a, #0x06, play_7
0951            602       ; ***play audio***
0951            602       ;cjne sound_flag, #0, $
0951            602       
0951 121036     602       lcall Wait_Half_Second
0954 C28E       602       clr TR1 ; Stop Timer 1 ISR from playing previous request
0956 D2A5       602       setb FLASH_CE
0958            602       ;setb sound_flag ; sound starts
0958 C2A6       602       clr SPEAKER ; Turn off speaker
095A C2A5       602       clr FLASH_CE ; Enable SPI Flash
095C 7403       602       mov a, #READ_BYTES
095E 12040D     602       lcall Send_SPI
0961            602       ; Set the initial position in memory where to start playing
0961            602       
0961 7402       602       mov a, #0x02 ; change initial position
0963 12040D     602       lcall Send_SPI
0966 7426       602       mov a, #0x26 ; next memory position
0968 12040D     602       lcall Send_SPI
096B 74C8       602       mov a, #0xc8 ; next memory position
096D 12040D     602       lcall Send_SPI
0970 7402       602       mov a, #0x02 ; request first byte to send to DAC
0972 12040D     602       lcall Send_SPI
0975            602       
0975            602       ; How many bytes to play?
0975 754E00     602       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0978 754D1F     602       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
097B 754C40     602       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
097E            602       
097E            602       
097E D2A6       602       setb SPEAKER ;Turn on speaker
0980 D28E       602       setb TR1 ;Start playback by enabling Timer1
0982            602       ;clr sound_flag ; sound ends
0982 020A24     603           ljmp state_8_hop1
0985            604   
0985            605       play_7:
0985 B40734     606           cjne a, #0x07, play_8
0988            607       ; ***play audio***
0988            607       ;cjne sound_flag, #0, $
0988            607       
0988 121036     607       lcall Wait_Half_Second
098B C28E       607       clr TR1 ; Stop Timer 1 ISR from playing previous request
098D D2A5       607       setb FLASH_CE
098F            607       ;setb sound_flag ; sound starts
098F C2A6       607       clr SPEAKER ; Turn off speaker
0991 C2A5       607       clr FLASH_CE ; Enable SPI Flash
0993 7403       607       mov a, #READ_BYTES
0995 12040D     607       lcall Send_SPI
0998            607       ; Set the initial position in memory where to start playing
0998            607       
0998 7402       607       mov a, #0x02 ; change initial position
099A 12040D     607       lcall Send_SPI
099D 7436       607       mov a, #0x36 ; next memory position
099F 12040D     607       lcall Send_SPI
09A2 7468       607       mov a, #0x68 ; next memory position
09A4 12040D     607       lcall Send_SPI
09A7 7402       607       mov a, #0x02 ; request first byte to send to DAC
09A9 12040D     607       lcall Send_SPI
09AC            607       
09AC            607       ; How many bytes to play?
09AC 754E00     607       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
09AF 754D23     607       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
09B2 754C28     607       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
09B5            607       
09B5            607       
09B5 D2A6       607       setb SPEAKER ;Turn on speaker
09B7 D28E       607       setb TR1 ;Start playback by enabling Timer1
09B9            607       ;clr sound_flag ; sound ends
09B9 020A24     608           ljmp state_8_hop1
09BC            609   
09BC            610       play_8:
09BC B40834     611           cjne a, #0x08, play_9
09BF            612       ; ***play audio***
09BF            612       ;cjne sound_flag, #0, $
09BF            612       
09BF 121036     612       lcall Wait_Half_Second
09C2 C28E       612       clr TR1 ; Stop Timer 1 ISR from playing previous request
09C4 D2A5       612       setb FLASH_CE
09C6            612       ;setb sound_flag ; sound starts
09C6 C2A6       612       clr SPEAKER ; Turn off speaker
09C8 C2A5       612       clr FLASH_CE ; Enable SPI Flash
09CA 7403       612       mov a, #READ_BYTES
09CC 12040D     612       lcall Send_SPI
09CF            612       ; Set the initial position in memory where to start playing
09CF            612       
09CF 7402       612       mov a, #0x02 ; change initial position
09D1 12040D     612       lcall Send_SPI
09D4 7457       612       mov a, #0x57 ; next memory position
09D6 12040D     612       lcall Send_SPI
09D9 749C       612       mov a, #0x9c ; next memory position
09DB 12040D     612       lcall Send_SPI
09DE 7402       612       mov a, #0x02 ; request first byte to send to DAC
09E0 12040D     612       lcall Send_SPI
09E3            612       
09E3            612       ; How many bytes to play?
09E3 754E00     612       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
09E6 754D1B     612       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
09E9 754C58     612       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
09EC            612       
09EC            612       
09EC D2A6       612       setb SPEAKER ;Turn on speaker
09EE D28E       612       setb TR1 ;Start playback by enabling Timer1
09F0            612       ;clr sound_flag ; sound ends
09F0 020A24     613           ljmp state_8_hop1
09F3            614   
09F3            615       play_9:
09F3            616       ; ***play audio***
09F3            616       ;cjne sound_flag, #0, $
09F3            616       
09F3 121036     616       lcall Wait_Half_Second
09F6 C28E       616       clr TR1 ; Stop Timer 1 ISR from playing previous request
09F8 D2A5       616       setb FLASH_CE
09FA            616       ;setb sound_flag ; sound starts
09FA C2A6       616       clr SPEAKER ; Turn off speaker
09FC C2A5       616       clr FLASH_CE ; Enable SPI Flash
09FE 7403       616       mov a, #READ_BYTES
0A00 12040D     616       lcall Send_SPI
0A03            616       ; Set the initial position in memory where to start playing
0A03            616       
0A03 7402       616       mov a, #0x02 ; change initial position
0A05 12040D     616       lcall Send_SPI
0A08 7469       616       mov a, #0x69 ; next memory position
0A0A 12040D     616       lcall Send_SPI
0A0D 7430       616       mov a, #0x30 ; next memory position
0A0F 12040D     616       lcall Send_SPI
0A12 7402       616       mov a, #0x02 ; request first byte to send to DAC
0A14 12040D     616       lcall Send_SPI
0A17            616       
0A17            616       ; How many bytes to play?
0A17 754E00     616       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0A1A 754D1F     616       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0A1D 754C40     616       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0A20            616       
0A20            616       
0A20 D2A6       616       setb SPEAKER ;Turn on speaker
0A22 D28E       616       setb TR1 ;Start playback by enabling Timer1
0A24            616       ;clr sound_flag ; sound ends
0A24            617   
0A24            618   state_8_hop1:
0A24            619   ; go to state_8_sound
0A24 020C52     620       ljmp state_8_sound
0A27            621   
0A27            622   
0A27            623   state_7_sound:
0A27            624   ; play 10 - 19
0A27            625       ;ljmp PLAYBACK_TEMP
0A27 75F064     626       mov b, #100
0A2A E53B       627       mov a, Temp_oven
0A2C 84         628       div ab
0A2D E5F0       629       mov a, b
0A2F B40A34     630       cjne a, #0x0a, play_11
0A32            631       
0A32            632       ; ***play audio***
0A32            632       ;cjne sound_flag, #0, $
0A32            632       
0A32 121036     632       lcall Wait_Half_Second
0A35 C28E       632       clr TR1 ; Stop Timer 1 ISR from playing previous request
0A37 D2A5       632       setb FLASH_CE
0A39            632       ;setb sound_flag ; sound starts
0A39 C2A6       632       clr SPEAKER ; Turn off speaker
0A3B C2A5       632       clr FLASH_CE ; Enable SPI Flash
0A3D 7403       632       mov a, #READ_BYTES
0A3F 12040D     632       lcall Send_SPI
0A42            632       ; Set the initial position in memory where to start playing
0A42            632       
0A42 7402       632       mov a, #0x02 ; change initial position
0A44 12040D     632       lcall Send_SPI
0A47 7484       632       mov a, #0x84 ; next memory position
0A49 12040D     632       lcall Send_SPI
0A4C 7488       632       mov a, #0x88 ; next memory position
0A4E 12040D     632       lcall Send_SPI
0A51 7402       632       mov a, #0x02 ; request first byte to send to DAC
0A53 12040D     632       lcall Send_SPI
0A56            632       
0A56            632       ; How many bytes to play?
0A56 754E00     632       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0A59 754D17     632       mov w+1, #0x17 ; Load the middle byte of the number of bytes to play
0A5C 754C70     632       mov w+0, #0x70 ; Load the low byte of the number of bytes to play
0A5F            632       
0A5F            632       
0A5F D2A6       632       setb SPEAKER ;Turn on speaker
0A61 D28E       632       setb TR1 ;Start playback by enabling Timer1
0A63            632       ;clr sound_flag ; sound ends
0A63 020C4F     633       ljmp state_8_hop2
0A66            634   
0A66            635       play_11:
0A66 B40B34     636           cjne a, #0x0b, play_12
0A69            637       ; ***play audio***
0A69            637       ;cjne sound_flag, #0, $
0A69            637       
0A69 121036     637       lcall Wait_Half_Second
0A6C C28E       637       clr TR1 ; Stop Timer 1 ISR from playing previous request
0A6E D2A5       637       setb FLASH_CE
0A70            637       ;setb sound_flag ; sound starts
0A70 C2A6       637       clr SPEAKER ; Turn off speaker
0A72 C2A5       637       clr FLASH_CE ; Enable SPI Flash
0A74 7403       637       mov a, #READ_BYTES
0A76 12040D     637       lcall Send_SPI
0A79            637       ; Set the initial position in memory where to start playing
0A79            637       
0A79 7402       637       mov a, #0x02 ; change initial position
0A7B 12040D     637       lcall Send_SPI
0A7E 749B       637       mov a, #0x9b ; next memory position
0A80 12040D     637       lcall Send_SPI
0A83 74F8       637       mov a, #0xf8 ; next memory position
0A85 12040D     637       lcall Send_SPI
0A88 7402       637       mov a, #0x02 ; request first byte to send to DAC
0A8A 12040D     637       lcall Send_SPI
0A8D            637       
0A8D            637       ; How many bytes to play?
0A8D 754E00     637       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0A90 754D1F     637       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0A93 754C40     637       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0A96            637       
0A96            637       
0A96 D2A6       637       setb SPEAKER ;Turn on speaker
0A98 D28E       637       setb TR1 ;Start playback by enabling Timer1
0A9A            637       ;clr sound_flag ; sound ends
0A9A 020C4F     638           ljmp state_8_hop2
0A9D            639   
0A9D            640       play_12:
0A9D B40C34     641           cjne a, #0x0c, play_13
0AA0            642       ; ***play audio***
0AA0            642       ;cjne sound_flag, #0, $
0AA0            642       
0AA0 121036     642       lcall Wait_Half_Second
0AA3 C28E       642       clr TR1 ; Stop Timer 1 ISR from playing previous request
0AA5 D2A5       642       setb FLASH_CE
0AA7            642       ;setb sound_flag ; sound starts
0AA7 C2A6       642       clr SPEAKER ; Turn off speaker
0AA9 C2A5       642       clr FLASH_CE ; Enable SPI Flash
0AAB 7403       642       mov a, #READ_BYTES
0AAD 12040D     642       lcall Send_SPI
0AB0            642       ; Set the initial position in memory where to start playing
0AB0            642       
0AB0 7402       642       mov a, #0x02 ; change initial position
0AB2 12040D     642       lcall Send_SPI
0AB5 74B7       642       mov a, #0xb7 ; next memory position
0AB7 12040D     642       lcall Send_SPI
0ABA 7450       642       mov a, #0x50 ; next memory position
0ABC 12040D     642       lcall Send_SPI
0ABF 7402       642       mov a, #0x02 ; request first byte to send to DAC
0AC1 12040D     642       lcall Send_SPI
0AC4            642       
0AC4            642       ; How many bytes to play?
0AC4 754E00     642       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0AC7 754D1F     642       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0ACA 754C40     642       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0ACD            642       
0ACD            642       
0ACD D2A6       642       setb SPEAKER ;Turn on speaker
0ACF D28E       642       setb TR1 ;Start playback by enabling Timer1
0AD1            642       ;clr sound_flag ; sound ends
0AD1 020C4F     643           ljmp state_8_hop2
0AD4            644   
0AD4            645       play_13:
0AD4 B40D34     646           cjne a, #0x0d, play_14
0AD7            647       ; ***play audio***
0AD7            647       ;cjne sound_flag, #0, $
0AD7            647       
0AD7 121036     647       lcall Wait_Half_Second
0ADA C28E       647       clr TR1 ; Stop Timer 1 ISR from playing previous request
0ADC D2A5       647       setb FLASH_CE
0ADE            647       ;setb sound_flag ; sound starts
0ADE C2A6       647       clr SPEAKER ; Turn off speaker
0AE0 C2A5       647       clr FLASH_CE ; Enable SPI Flash
0AE2 7403       647       mov a, #READ_BYTES
0AE4 12040D     647       lcall Send_SPI
0AE7            647       ; Set the initial position in memory where to start playing
0AE7            647       
0AE7 7402       647       mov a, #0x02 ; change initial position
0AE9 12040D     647       lcall Send_SPI
0AEC 74CE       647       mov a, #0xce ; next memory position
0AEE 12040D     647       lcall Send_SPI
0AF1 74C0       647       mov a, #0xc0 ; next memory position
0AF3 12040D     647       lcall Send_SPI
0AF6 7402       647       mov a, #0x02 ; request first byte to send to DAC
0AF8 12040D     647       lcall Send_SPI
0AFB            647       
0AFB            647       ; How many bytes to play?
0AFB 754E00     647       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0AFE 754D2E     647       mov w+1, #0x2e ; Load the middle byte of the number of bytes to play
0B01 754CE0     647       mov w+0, #0xe0 ; Load the low byte of the number of bytes to play
0B04            647       
0B04            647       
0B04 D2A6       647       setb SPEAKER ;Turn on speaker
0B06 D28E       647       setb TR1 ;Start playback by enabling Timer1
0B08            647       ;clr sound_flag ; sound ends
0B08 020C4F     648           ljmp state_8_hop2
0B0B            649   
0B0B            650       play_14:
0B0B B40E34     651           cjne a, #0x0e, play_15
0B0E            652       ; ***play audio***
0B0E            652       ;cjne sound_flag, #0, $
0B0E            652       
0B0E 121036     652       lcall Wait_Half_Second
0B11 C28E       652       clr TR1 ; Stop Timer 1 ISR from playing previous request
0B13 D2A5       652       setb FLASH_CE
0B15            652       ;setb sound_flag ; sound starts
0B15 C2A6       652       clr SPEAKER ; Turn off speaker
0B17 C2A5       652       clr FLASH_CE ; Enable SPI Flash
0B19 7403       652       mov a, #READ_BYTES
0B1B 12040D     652       lcall Send_SPI
0B1E            652       ; Set the initial position in memory where to start playing
0B1E            652       
0B1E 7402       652       mov a, #0x02 ; change initial position
0B20 12040D     652       lcall Send_SPI
0B23 74F5       652       mov a, #0xf5 ; next memory position
0B25 12040D     652       lcall Send_SPI
0B28 74D0       652       mov a, #0xd0 ; next memory position
0B2A 12040D     652       lcall Send_SPI
0B2D 7402       652       mov a, #0x02 ; request first byte to send to DAC
0B2F 12040D     652       lcall Send_SPI
0B32            652       
0B32            652       ; How many bytes to play?
0B32 754E00     652       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0B35 754D36     652       mov w+1, #0x36 ; Load the middle byte of the number of bytes to play
0B38 754CB0     652       mov w+0, #0xb0 ; Load the low byte of the number of bytes to play
0B3B            652       
0B3B            652       
0B3B D2A6       652       setb SPEAKER ;Turn on speaker
0B3D D28E       652       setb TR1 ;Start playback by enabling Timer1
0B3F            652       ;clr sound_flag ; sound ends
0B3F 020C4F     653           ljmp state_8_hop2
0B42            654   
0B42            655       play_15:
0B42 B40F34     656           cjne a, #0x0f, play_16
0B45            657       ; ***play audio***
0B45            657       ;cjne sound_flag, #0, $
0B45            657       
0B45 121036     657       lcall Wait_Half_Second
0B48 C28E       657       clr TR1 ; Stop Timer 1 ISR from playing previous request
0B4A D2A5       657       setb FLASH_CE
0B4C            657       ;setb sound_flag ; sound starts
0B4C C2A6       657       clr SPEAKER ; Turn off speaker
0B4E C2A5       657       clr FLASH_CE ; Enable SPI Flash
0B50 7403       657       mov a, #READ_BYTES
0B52 12040D     657       lcall Send_SPI
0B55            657       ; Set the initial position in memory where to start playing
0B55            657       
0B55 7403       657       mov a, #0x03 ; change initial position
0B57 12040D     657       lcall Send_SPI
0B5A 7428       657       mov a, #0x28 ; next memory position
0B5C 12040D     657       lcall Send_SPI
0B5F 7498       657       mov a, #0x98 ; next memory position
0B61 12040D     657       lcall Send_SPI
0B64 7403       657       mov a, #0x03 ; request first byte to send to DAC
0B66 12040D     657       lcall Send_SPI
0B69            657       
0B69            657       ; How many bytes to play?
0B69 754E00     657       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0B6C 754D23     657       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
0B6F 754C28     657       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0B72            657       
0B72            657       
0B72 D2A6       657       setb SPEAKER ;Turn on speaker
0B74 D28E       657       setb TR1 ;Start playback by enabling Timer1
0B76            657       ;clr sound_flag ; sound ends
0B76 020C4F     658           ljmp state_8_hop2
0B79            659   
0B79            660       play_16:
0B79 B41034     661           cjne a, #0x10, play_17
0B7C            662       ; ***play audio***
0B7C            662       ;cjne sound_flag, #0, $
0B7C            662       
0B7C 121036     662       lcall Wait_Half_Second
0B7F C28E       662       clr TR1 ; Stop Timer 1 ISR from playing previous request
0B81 D2A5       662       setb FLASH_CE
0B83            662       ;setb sound_flag ; sound starts
0B83 C2A6       662       clr SPEAKER ; Turn off speaker
0B85 C2A5       662       clr FLASH_CE ; Enable SPI Flash
0B87 7403       662       mov a, #READ_BYTES
0B89 12040D     662       lcall Send_SPI
0B8C            662       ; Set the initial position in memory where to start playing
0B8C            662       
0B8C 7403       662       mov a, #0x03 ; change initial position
0B8E 12040D     662       lcall Send_SPI
0B91 7447       662       mov a, #0x47 ; next memory position
0B93 12040D     662       lcall Send_SPI
0B96 74D8       662       mov a, #0xd8 ; next memory position
0B98 12040D     662       lcall Send_SPI
0B9B 7403       662       mov a, #0x03 ; request first byte to send to DAC
0B9D 12040D     662       lcall Send_SPI
0BA0            662       
0BA0            662       ; How many bytes to play?
0BA0 754E00     662       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0BA3 754D32     662       mov w+1, #0x32 ; Load the middle byte of the number of bytes to play
0BA6 754CC8     662       mov w+0, #0xc8 ; Load the low byte of the number of bytes to play
0BA9            662       
0BA9            662       
0BA9 D2A6       662       setb SPEAKER ;Turn on speaker
0BAB D28E       662       setb TR1 ;Start playback by enabling Timer1
0BAD            662       ;clr sound_flag ; sound ends
0BAD 020C4F     663           ljmp state_8_hop2
0BB0            664   
0BB0            665       play_17:
0BB0 B41134     666           cjne a, #0x11, play_18
0BB3            667       ; ***play audio***
0BB3            667       ;cjne sound_flag, #0, $
0BB3            667       
0BB3 121036     667       lcall Wait_Half_Second
0BB6 C28E       667       clr TR1 ; Stop Timer 1 ISR from playing previous request
0BB8 D2A5       667       setb FLASH_CE
0BBA            667       ;setb sound_flag ; sound starts
0BBA C2A6       667       clr SPEAKER ; Turn off speaker
0BBC C2A5       667       clr FLASH_CE ; Enable SPI Flash
0BBE 7403       667       mov a, #READ_BYTES
0BC0 12040D     667       lcall Send_SPI
0BC3            667       ; Set the initial position in memory where to start playing
0BC3            667       
0BC3 7403       667       mov a, #0x03 ; change initial position
0BC5 12040D     667       lcall Send_SPI
0BC8 7476       667       mov a, #0x76 ; next memory position
0BCA 12040D     667       lcall Send_SPI
0BCD 74B8       667       mov a, #0xb8 ; next memory position
0BCF 12040D     667       lcall Send_SPI
0BD2 7403       667       mov a, #0x03 ; request first byte to send to DAC
0BD4 12040D     667       lcall Send_SPI
0BD7            667       
0BD7            667       ; How many bytes to play?
0BD7 754E00     667       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0BDA 754D2E     667       mov w+1, #0x2e ; Load the middle byte of the number of bytes to play
0BDD 754C20     667       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
0BE0            667       
0BE0            667       
0BE0 D2A6       667       setb SPEAKER ;Turn on speaker
0BE2 D28E       667       setb TR1 ;Start playback by enabling Timer1
0BE4            667       ;clr sound_flag ; sound ends
0BE4 020C4F     668           ljmp state_8_hop2
0BE7            669   
0BE7            670       play_18:
0BE7 B41234     671           cjne a, #0x12, play_19
0BEA            672       ; ***play audio***
0BEA            672       ;cjne sound_flag, #0, $
0BEA            672       
0BEA 121036     672       lcall Wait_Half_Second
0BED C28E       672       clr TR1 ; Stop Timer 1 ISR from playing previous request
0BEF D2A5       672       setb FLASH_CE
0BF1            672       ;setb sound_flag ; sound starts
0BF1 C2A6       672       clr SPEAKER ; Turn off speaker
0BF3 C2A5       672       clr FLASH_CE ; Enable SPI Flash
0BF5 7403       672       mov a, #READ_BYTES
0BF7 12040D     672       lcall Send_SPI
0BFA            672       ; Set the initial position in memory where to start playing
0BFA            672       
0BFA 7403       672       mov a, #0x03 ; change initial position
0BFC 12040D     672       lcall Send_SPI
0BFF 74A1       672       mov a, #0xa1 ; next memory position
0C01 12040D     672       lcall Send_SPI
0C04 74B0       672       mov a, #0xb0 ; next memory position
0C06 12040D     672       lcall Send_SPI
0C09 7403       672       mov a, #0x03 ; request first byte to send to DAC
0C0B 12040D     672       lcall Send_SPI
0C0E            672       
0C0E            672       ; How many bytes to play?
0C0E 754E00     672       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0C11 754D27     672       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0C14 754C10     672       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0C17            672       
0C17            672       
0C17 D2A6       672       setb SPEAKER ;Turn on speaker
0C19 D28E       672       setb TR1 ;Start playback by enabling Timer1
0C1B            672       ;clr sound_flag ; sound ends
0C1B 020C4F     673           ljmp state_8_hop2
0C1E            674   
0C1E            675       play_19:
0C1E            676       ; ***play audio***
0C1E            676       ;cjne sound_flag, #0, $
0C1E            676       
0C1E 121036     676       lcall Wait_Half_Second
0C21 C28E       676       clr TR1 ; Stop Timer 1 ISR from playing previous request
0C23 D2A5       676       setb FLASH_CE
0C25            676       ;setb sound_flag ; sound starts
0C25 C2A6       676       clr SPEAKER ; Turn off speaker
0C27 C2A5       676       clr FLASH_CE ; Enable SPI Flash
0C29 7403       676       mov a, #READ_BYTES
0C2B 12040D     676       lcall Send_SPI
0C2E            676       ; Set the initial position in memory where to start playing
0C2E            676       
0C2E 7403       676       mov a, #0x03 ; change initial position
0C30 12040D     676       lcall Send_SPI
0C33 74C8       676       mov a, #0xc8 ; next memory position
0C35 12040D     676       lcall Send_SPI
0C38 74C0       676       mov a, #0xc0 ; next memory position
0C3A 12040D     676       lcall Send_SPI
0C3D 7403       676       mov a, #0x03 ; request first byte to send to DAC
0C3F 12040D     676       lcall Send_SPI
0C42            676       
0C42            676       ; How many bytes to play?
0C42 754E00     676       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0C45 754D27     676       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0C48 754C10     676       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0C4B            676       
0C4B            676       
0C4B D2A6       676       setb SPEAKER ;Turn on speaker
0C4D D28E       676       setb TR1 ;Start playback by enabling Timer1
0C4F            676       ;clr sound_flag ; sound ends
0C4F            677   
0C4F            678       state_8_hop2:
0C4F            679       ; go to state_8_sound
0C4F 020C52     680           ljmp state_8_sound
0C52            681   
0C52            682   state_8_sound:
0C52            683   ; go to state_0_sound
0C52 02052C     684       ljmp Sound_ret
0C55            685   
0C55            686   
0C55            687   
0C55            688   
0C55            689   INI_PLAYBACK_TEMP:
0C55            690       ; ****INITIALIZATION****
0C55            691       ; Configure SPI pins and turn off speaker
0C55            692            ;anl P2M0, #0b_1100_1110
0C55 43CE90     693       orl P2M0, #0b_1001_0000
0C58            694       ;orl P2M0, #0b_0011_0001
0C58            695            ;orl P2M1, #0b_0011_0001
0C58 43CF90     696       orl P2M1, #0b_1001_0000
0C5B D2A1       697            setb MY_MISO_SOUND  ; Configured as input
0C5D D2A5       698            setb FLASH_CE ; CS=1 for SPI flash memory
0C5F C2A0       699            clr MY_SCLK_SOUND   ; Rest state of SCLK=0
0C61 C2A6       700            clr SPEAKER   ; Turn off speaker.
0C63            701            
0C63            702            ; Configure timer 1
0C63 53890F     703            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
0C66 438910     704            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
0C69 758DFC     705            mov TH1, #high(TIMER1_RELOAD)
0C6C 758B8C     706            mov TL1, #low(TIMER1_RELOAD)
0C6F            707            ; Set autoreload value
0C6F 75F5FC     708            mov RH1, #high(TIMER1_RELOAD)
0C72 75F38C     709            mov RL1, #low(TIMER1_RELOAD)
0C75            710   
0C75            711            ;Enable the timer and interrupts
0C75 D2AB       712       setb ET1  ; Enable timer 1 interrupt
0C77 D28E       713            setb TR1 ; Timer 1 is only enabled to play stored sound
0C79            714   
0C79            715            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
0C79 75A5A0     716            mov DADI, #0b_1010_0000 ; ACON=1
0C7C 75A43A     717            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0C7F 75AD80     718            mov DADH, #0x80 ; Middle of scale
0C82 75AC00     719            mov DADL, #0
0C85 43A440     720            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
0C88            721       check_DAC_init:
0C88 E5A4       722            mov a, DADC
0C8A 20E6FB     723            jb acc.6, check_DAC_init ; Wait for DAC to finish
0C8D            724            
0C8D 22         725   ret
0C8E            726   
0C8E            727       
0C8E            728   ;-------------------------------------------------------------------------------------------------------------------------------
0C8E            729   ;***LCD FXNS
0C8E            730   
                731   Display_lower_BCD mac
                732       push ar0
                733       mov r0, %0
                734       lcall ?Display_lower_BCD
                735       pop ar0
                736   endmac
0C8E            737   
0C8E            738   ?Display_lower_BCD:
0C8E C0E0       739       push acc
0C90            740       ; write least significant digit
0C90 E8         741       mov a, r0
0C91 540F       742       anl a, #0fh
0C93 4430       743       orl a, #30h
0C95 12007E     744       lcall ?WriteData
0C98 D0E0       745       pop acc
0C9A 22         746   ret
0C9B            747   
0C9B            748   
0C9B            749   SendToLCD:
0C9B 75F064     750       mov b, #100
0C9E 84         751       div ab
0C9F 4430       752       orl a, #0x30h ; Convert hundreds to ASCII
0CA1 12007E     753       lcall ?WriteData ; Send to LCD
0CA4 E5F0       754       mov a, b    ; Remainder is in register b
0CA6 75F00A     755       mov b, #10
0CA9 84         756       div ab
0CAA 4430       757       orl a, #0x30h ; Convert tens to ASCII
0CAC 12007E     758       lcall ?WriteData; Send to LCD
0CAF E5F0       759       mov a, b
0CB1 4430       760       orl a, #0x30h ; Convert units to ASCII
0CB3 12007E     761       lcall ?WriteData; Send to LCD
0CB6 22         762   ret
0CB7            763   
0CB7            764   Initialize_State_Display:
0CB7            765   
0CB7            766       ;***clear the screen and set new display***
0CB7 7401       767            mov a, #0x01
0CB9 120083     767            lcall ?WriteCommand
0CBC C002       768            push AR2
0CBE 7A02       768            mov R2, #2
0CC0 120039     768            lcall ?Wait_Milli_Seconds
0CC3 D002       768            pop AR2
0CC5            769       
0CC5 C0E0       770            push acc
0CC7 7401       770            mov a, #1
0CC9 14         770            dec a
0CCA 1200BF     770            lcall ?Set_Cursor_1 ; Select column and row
0CCD D0E0       770            pop acc
0CCF C083       771            push dph
0CD1 C082       771            push dpl
0CD3 C0E0       771            push acc
0CD5 90037D     771            mov dptr, #time
0CD8 1200B2     771            lcall ?Send_Constant_String
0CDB D0E0       771            pop acc
0CDD D082       771            pop dpl
0CDF D083       771            pop dph
0CE1            772            
0CE1 C0E0       773            push acc
0CE3 7406       773            mov a, #6
0CE5 14         773            dec a
0CE6 1200BF     773            lcall ?Set_Cursor_1 ; Select column and row
0CE9 D0E0       773            pop acc
0CEB C083       774            push dph
0CED C082       774            push dpl
0CEF C0E0       774            push acc
0CF1 900382     774            mov dptr, #colon
0CF4 1200B2     774            lcall ?Send_Constant_String
0CF7 D0E0       774            pop acc
0CF9 D082       774            pop dpl
0CFB D083       774            pop dph
0CFD            775      
0CFD C0E0       776            push acc
0CFF 740A       776            mov a, #10
0D01 14         776            dec a
0D02 1200BF     776            lcall ?Set_Cursor_1 ; Select column and row
0D05 D0E0       776            pop acc
0D07 C083       777            push dph
0D09 C082       777            push dpl
0D0B C0E0       777            push acc
0D0D 900384     777            mov dptr, #temp
0D10 1200B2     777            lcall ?Send_Constant_String
0D13 D0E0       777            pop acc
0D15 D082       777            pop dpl
0D17 D083       777            pop dph
0D19            778       
0D19 C0E0       779            push acc
0D1B 7401       779            mov a, #1
0D1D 14         779            dec a
0D1E 1200BD     779            lcall ?Set_Cursor_2 ; Select column and row
0D21 D0E0       779            pop acc
0D23 C083       780            push dph
0D25 C082       780            push dpl
0D27 C0E0       780            push acc
0D29 900376     780            mov dptr, #state
0D2C 1200B2     780            lcall ?Send_Constant_String
0D2F D0E0       780            pop acc
0D31 D082       780            pop dpl
0D33 D083       780            pop dph
0D35 22         781   ret
0D36            782   
0D36            783   Update_Display:
0D36 C0E0       784            push acc
0D38 7405       784            mov a, #5
0D3A 14         784            dec a
0D3B 1200BF     784            lcall ?Set_Cursor_1 ; Select column and row
0D3E D0E0       784            pop acc
0D40 C000       785       push ar0
0D42 A839       785       mov r0, Run_time_minutes
0D44 120C8E     785       lcall ?Display_lower_BCD
0D47 D000       785       pop ar0
0D49 C0E0       786            push acc
0D4B 7407       786            mov a, #7
0D4D 14         786            dec a
0D4E 1200BF     786            lcall ?Set_Cursor_1 ; Select column and row
0D51 D0E0       786            pop acc
0D53 C000       787            push ar0
0D55 A838       787            mov r0, Run_time_seconds
0D57 1200C4     787            lcall ?Display_BCD
0D5A D000       787            pop ar0
0D5C            788       ;Set_Cursor(1,14)
0D5C            789       ;mov a, Temp_oven
0D5C            790       ;SendToLCD(Temp_oven)
0D5C 22         791   ret
0D5D            792   
0D5D            793   State0_display:
0D5D C0E0       794            push acc
0D5F 7401       794            mov a, #1
0D61 14         794            dec a
0D62 1200BF     794            lcall ?Set_Cursor_1 ; Select column and row
0D65 D0E0       794            pop acc
0D67 C083       795            push dph
0D69 C082       795            push dpl
0D6B C0E0       795            push acc
0D6D 900360     795            mov dptr, #STemp
0D70 1200B2     795            lcall ?Send_Constant_String
0D73 D0E0       795            pop acc
0D75 D082       795            pop dpl
0D77 D083       795            pop dph
0D79 C0E0       796            push acc
0D7B 7406       796            mov a, #6
0D7D 14         796            dec a
0D7E 1200BF     796            lcall ?Set_Cursor_1 ; Select column and row
0D81 D0E0       796            pop acc
0D83 E534       797       mov a, Temp_soak
0D85 120C9B     798       lcall SendToLCD
0D88            799       
0D88 C0E0       800            push acc
0D8A 740A       800            mov a, #10
0D8C 14         800            dec a
0D8D 1200BF     800            lcall ?Set_Cursor_1 ; Select column and row
0D90 D0E0       800            pop acc
0D92 C083       801            push dph
0D94 C082       801            push dpl
0D96 C0E0       801            push acc
0D98 900366     801            mov dptr, #STime
0D9B 1200B2     801            lcall ?Send_Constant_String
0D9E D0E0       801            pop acc
0DA0 D082       801            pop dpl
0DA2 D083       801            pop dph
0DA4 C0E0       802            push acc
0DA6 740E       802            mov a, #14
0DA8 14         802            dec a
0DA9 1200BF     802            lcall ?Set_Cursor_1 ; Select column and row
0DAC D0E0       802            pop acc
0DAE E535       803       mov a, Time_soak
0DB0 120C9B     804            lcall SendToLCD
0DB3            805       ;Display_BCD(Time_soak)
0DB3            806   
0DB3            807       ;Displays Reflow Temp and Time
0DB3 C0E0       808            push acc
0DB5 7401       808            mov a, #1
0DB7 14         808            dec a
0DB8 1200BD     808            lcall ?Set_Cursor_2 ; Select column and row
0DBB D0E0       808            pop acc
0DBD C083       809            push dph
0DBF C082       809            push dpl
0DC1 C0E0       809            push acc
0DC3 90036B     809            mov dptr, #RTemp
0DC6 1200B2     809            lcall ?Send_Constant_String
0DC9 D0E0       809            pop acc
0DCB D082       809            pop dpl
0DCD D083       809            pop dph
0DCF C0E0       810            push acc
0DD1 7406       810            mov a, #6
0DD3 14         810            dec a
0DD4 1200BD     810            lcall ?Set_Cursor_2 ; Select column and row
0DD7 D0E0       810            pop acc
0DD9 E536       811       mov a, Temp_refl
0DDB 120C9B     812       lcall SendToLCD
0DDE            813       
0DDE C0E0       814            push acc
0DE0 740A       814            mov a, #10
0DE2 14         814            dec a
0DE3 1200BD     814            lcall ?Set_Cursor_2 ; Select column and row
0DE6 D0E0       814            pop acc
0DE8 C083       815            push dph
0DEA C082       815            push dpl
0DEC C0E0       815            push acc
0DEE 900371     815            mov dptr, #RTime
0DF1 1200B2     815            lcall ?Send_Constant_String
0DF4 D0E0       815            pop acc
0DF6 D082       815            pop dpl
0DF8 D083       815            pop dph
0DFA C0E0       816            push acc
0DFC 740E       816            mov a, #14
0DFE 14         816            dec a
0DFF 1200BD     816            lcall ?Set_Cursor_2 ; Select column and row
0E02 D0E0       816            pop acc
0E04 E537       817       mov a, Time_refl
0E06 120C9B     818            lcall SendToLCD
0E09 22         819   ret
0E0A            820   
0E0A            821   Display_3_digit_BCD:
0E0A C0E0       822            push acc
0E0C 740E       822            mov a, #14
0E0E 14         822            dec a
0E0F 1200BF     822            lcall ?Set_Cursor_1 ; Select column and row
0E12 D0E0       822            pop acc
0E14 C000       823       push ar0
0E16 A846       823       mov r0, bcd+1
0E18 120C8E     823       lcall ?Display_lower_BCD
0E1B D000       823       pop ar0
0E1D C000       824            push ar0
0E1F A845       824            mov r0, bcd+0
0E21 1200C4     824            lcall ?Display_BCD
0E24 D000       824            pop ar0
0E26 22         825   ret
0E27            826   
0E27            827   Animation:
0E27 740F       828            mov a, #0x0f
0E29 120083     828            lcall ?WriteCommand ;display cursor
0E2C            829   
0E2C            830       ;name ; Move cursor to line 1 column 1
0E2C 7480       831            mov a, #0x80
0E2E 120083     831            lcall ?WriteCommand
0E31 7457       832            mov a, #'W'
0E33 12007E     832            lcall ?WriteData
0E36 C002       833            push AR2
0E38 7AFA       833            mov R2, #250
0E3A 120039     833            lcall ?Wait_Milli_Seconds
0E3D D002       833            pop AR2
0E3F 7465       834            mov a, #'e'
0E41 12007E     834            lcall ?WriteData
0E44 C002       835            push AR2
0E46 7AFA       835            mov R2, #250
0E48 120039     835            lcall ?Wait_Milli_Seconds
0E4B D002       835            pop AR2
0E4D 746C       836            mov a, #'l'
0E4F 12007E     836            lcall ?WriteData
0E52 C002       837            push AR2
0E54 7AFA       837            mov R2, #250
0E56 120039     837            lcall ?Wait_Milli_Seconds
0E59 D002       837            pop AR2
0E5B 7463       838            mov a, #'c'
0E5D 12007E     838            lcall ?WriteData
0E60 C002       839            push AR2
0E62 7AFA       839            mov R2, #250
0E64 120039     839            lcall ?Wait_Milli_Seconds
0E67 D002       839            pop AR2
0E69 746F       840            mov a, #'o'
0E6B 12007E     840            lcall ?WriteData
0E6E C002       841            push AR2
0E70 7AFA       841            mov R2, #250
0E72 120039     841            lcall ?Wait_Milli_Seconds
0E75 D002       841            pop AR2
0E77 746D       842            mov a, #'m'
0E79 12007E     842            lcall ?WriteData
0E7C C002       843            push AR2
0E7E 7AFA       843            mov R2, #250
0E80 120039     843            lcall ?Wait_Milli_Seconds
0E83 D002       843            pop AR2
0E85 7465       844            mov a, #'e'
0E87 12007E     844            lcall ?WriteData
0E8A C002       845            push AR2
0E8C 7AFA       845            mov R2, #250
0E8E 120039     845            lcall ?Wait_Milli_Seconds
0E91 D002       845            pop AR2
0E93 7421       846            mov a, #'!'
0E95 12007E     846            lcall ?WriteData
0E98 C002       847            push AR2
0E9A 7AFA       847            mov R2, #250
0E9C 120039     847            lcall ?Wait_Milli_Seconds
0E9F D002       847            pop AR2
0EA1 7420       848            mov a, #' '
0EA3 12007E     848            lcall ?WriteData
0EA6 C002       849            push AR2
0EA8 7AFA       849            mov R2, #250
0EAA 120039     849            lcall ?Wait_Milli_Seconds
0EAD D002       849            pop AR2
0EAF 7460       850            mov a, #96
0EB1 12007E     850            lcall ?WriteData
0EB4 C002       851            push AR2
0EB6 7AFA       851            mov R2, #250
0EB8 120039     851            lcall ?Wait_Milli_Seconds
0EBB D002       851            pop AR2
0EBD 74EF       852            mov a, #239
0EBF 12007E     852            lcall ?WriteData
0EC2 C002       853            push AR2
0EC4 7AFA       853            mov R2, #250
0EC6 120039     853            lcall ?Wait_Milli_Seconds
0EC9 D002       853            pop AR2
0ECB 742F       854            mov a, #47
0ECD 12007E     854            lcall ?WriteData
0ED0 121011     855       lcall Wait_One_Second
0ED3 121011     856       lcall Wait_One_Second
0ED6 740C       857            mov a, #0x0c
0ED8 120083     857            lcall ?WriteCommand ;clear cursor
0EDB 22         858   ret
0EDC            859   
0EDC            860   ;The following functions store and restore the values--------------------------------------------------------------------------
                861   loadbyte mac
                862       mov a, %0
                863       movx @dptr, a
                864       inc dptr
                865   endmac
0EDC            866   
0EDC            867   Save_Configuration:
0EDC C0A8       868       push IE ; Save the current state of bit EA in the stack
0EDE C2AF       869       clr EA ; Disable interrupts
0EE0 75D108     870       mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
0EE3 907F80     871       mov dptr, #0x7f80 ; Last page of flash memory
0EE6            872       ; Save variables
0EE6 E534       873       mov a, temp_soak
0EE8 F0         873       movx @dptr, a
0EE9 A3         873       inc dptr ; @0x7f80
0EEA E535       874       mov a, time_soak
0EEC F0         874       movx @dptr, a
0EED A3         874       inc dptr ; @0x7f81
0EEE E536       875       mov a, temp_refl
0EF0 F0         875       movx @dptr, a
0EF1 A3         875       inc dptr ; @0x7f82
0EF2 E537       876       mov a, time_refl
0EF4 F0         876       movx @dptr, a
0EF5 A3         876       inc dptr ; @0x7f83
0EF6 7455       877       mov a, #0x55
0EF8 F0         877       movx @dptr, a
0EF9 A3         877       inc dptr ; First key value @0x7f84
0EFA 74AA       878       mov a, #0xAA
0EFC F0         878       movx @dptr, a
0EFD A3         878       inc dptr ; Second key value @0x7f85
0EFE 75D100     879       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0) 
0F01 43D240     880       orl EECON, #0b01000000 ; Enable auto-erase on next write sequence  
0F04 75D150     881       mov FCON, #0x50 ; Write trigger first byte
0F07 75D1A0     882       mov FCON, #0xA0 ; Write trigger second byte
0F0A            883       ; CPU idles until writing of flash completes.
0F0A 75D100     884       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
0F0D 53D2BF     885       anl EECON, #0b10111111 ; Disable auto-erase
0F10 D0A8       886       pop IE ; Restore the state of bit EA from the stack
0F12 22         887   ret
0F13            888   
                889   getbyte mac
                890       clr a
                891       movc a, @a+dptr
                892       mov %0, a
                893       inc dptr
                894   endmac
0F13            895   
0F13            896   Load_Configuration:
0F13 907F84     897       mov dptr, #0x7f84 ; First key value location.
0F16 E4         898       clr a
0F17 93         898       movc a, @a+dptr
0F18 F8         898       mov R0, a
0F19 A3         898       inc dptr ; 0x7f84 should contain 0x55
0F1A B8551F     899       cjne R0, #0x55, Load_Defaults
0F1D E4         900       clr a
0F1E 93         900       movc a, @a+dptr
0F1F F8         900       mov R0, a
0F20 A3         900       inc dptr ; 0x7f85 should contain 0xAA
0F21 B8AA18     901       cjne R0, #0xAA, Load_Defaults
0F24            902   ; Keys are good.  Get stored values.
0F24 907F80     903       mov dptr, #0x7f80
0F27 E4         904       clr a
0F28 93         904       movc a, @a+dptr
0F29 F534       904       mov Temp_soak, a
0F2B A3         904       inc dptr ; 0x7f80
0F2C E4         905       clr a
0F2D 93         905       movc a, @a+dptr
0F2E F535       905       mov Time_soak, a
0F30 A3         905       inc dptr ; 0x7f81
0F31 E4         906       clr a
0F32 93         906       movc a, @a+dptr
0F33 F536       906       mov Temp_refl, a
0F35 A3         906       inc dptr ; 0x7f82
0F36 E4         907       clr a
0F37 93         907       movc a, @a+dptr
0F38 F537       907       mov Time_refl, a
0F3A A3         907       inc dptr ; 0x7f83
0F3B 22         908   ret
0F3C            909   
0F3C            910   Load_Defaults:
0F3C 753482     911       mov Temp_soak, #130 ; Soak Tmp Range is 130-170
0F3F 75353C     912       mov Time_soak, #0x3C ; Range 60-90 seconds
0F42 7536DC     913       mov Temp_refl, #220 ; Range 220-240
0F45 75371E     914       mov Time_refl, #0x1E ; Range 30-45 seconds
0F48 22         915       ret 
0F49            916   ;-------------------------------------------------------------------------------------------------------------------------------
0F49            917   ;off state
0F49            918   
0F49            919   OFF_STATE:
0F49            920       ;**CLEAR SCREEN**
0F49 7401       921            mov a, #0x01
0F4B 120083     921            lcall ?WriteCommand
0F4E            922       ;OFF_STATE1:
0F4E            923       
0F4E 20C5FD     924       jb POWER_BUTTON, $ ; loop while the button is not pressed
0F51 C002       925            push AR2
0F53 7A32       925            mov R2, #50
0F55 120039     925            lcall ?Wait_Milli_Seconds
0F58 D002       925            pop AR2 ; debounce time
0F5A 20C5EC     926            jb POWER_BUTTON, OFF_STATE ; it was a bounce, try again
0F5D 30C5FD     927            jnb POWER_BUTTON, $ ; loop while the button is pressed
0F60 0210FA     928       ljmp main
0F63 22         929   ret
0F64            930   ;-------------------------------------------------------------------------------------------------------------------------------
0F64            931   
0F64            932   ;***CHECK TEMPERATURE BY READING VOLTAGE AND CONVERTING
0F64            933   Check_Temp:
0F64            934       
0F64            935       ;jnb one_seconds_flag, Check_Temp_done
0F64            936       ;clr one_seconds_flag
0F64            937       
0F64 C297       938       clr CE_ADC
0F66 7801       939            mov R0, #00000001B ; Start bit:1
0F68 1203F4     940            lcall DO_SPI_G
0F6B 7880       941            mov R0, #10000000B ; Single ended, read channel 0
0F6D 1203F4     942            lcall DO_SPI_G
0F70 E9         943            mov a, R1          ; R1 contains bits 8 and 9
0F71 5403       944            anl a, #00000011B  ; We need only the two least significant bits
0F73 F54B       945            mov Result+1, a    ; Save result high.
0F75 7855       946            mov R0, #55H ; It doesn't matter what we transmit...
0F77 1203F4     947            lcall DO_SPI_G
0F7A 894A       948            mov Result+0, R1     ; R1 contains bits 0 to 7.  Save result low.
0F7C D297       949            setb CE_ADC
0F7E            950   
0F7E C002       951            push AR2
0F80 7A0A       951            mov R2, #10
0F82 120039     951            lcall ?Wait_Milli_Seconds
0F85 D002       951            pop AR2
0F87            952       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
0F87 AE4A       953            mov R6, Result+0
0F89 AF4B       954            mov R7, Result+1
0F8B 22         955   ret
0F8C            956   
0F8C            957       
0F8C            958       
0F8C            959   ;***CALCULATES THE TEMPERATURE
0F8C            960   Average_Temp:
0F8C 753D00     961            mov x+0, #low (0 % 0x10000) 
0F8F 753E00     961            mov x+1, #high(0 % 0x10000) 
0F92 753F00     961            mov x+2, #low (0 / 0x10000) 
0F95 754000     961            mov x+3, #high(0 / 0x10000) 
0F98 7D64       962       mov R5, #100
0F9A            963   Ave_loop:
0F9A 120F64     964       lcall Check_Temp
0F9D 754400     965       mov y+3, #0
0FA0 754300     966       mov y+2, #0
0FA3 8F42       967       mov y+1, R7
0FA5 8E41       968       mov y+0, R6
0FA7 1201B5     969       lcall add32
0FAA 121049     970       lcall Wait10us
0FAD DDEB       971       djnz R5, Ave_loop
0FAF 754164     972            mov y+0, #low (100 % 0x10000) 
0FB2 754200     972            mov y+1, #high(100 % 0x10000) 
0FB5 754300     972            mov y+2, #low (100 / 0x10000) 
0FB8 754400     972            mov y+3, #high(100 / 0x10000) 
0FBB 1202F7     973       lcall div32
0FBE            974   
0FBE            975       ;**INSERT MATH FUNCTIONS
0FBE            976   
0FBE 75414E     977            mov y+0, #low (2894 % 0x10000) 
0FC1 75420B     977            mov y+1, #high(2894 % 0x10000) 
0FC4 754300     977            mov y+2, #low (2894 / 0x10000) 
0FC7 754400     977            mov y+3, #high(2894 / 0x10000)  ;6078; 2026
0FCA 12026A     978            lcall mul32
0FCD 754110     979            mov y+0, #low (10000 % 0x10000) 
0FD0 754227     979            mov y+1, #high(10000 % 0x10000) 
0FD3 754300     979            mov y+2, #low (10000 / 0x10000) 
0FD6 754400     979            mov y+3, #high(10000 / 0x10000)  ;14000; 7000
0FD9 1202F7     980            lcall div32
0FDC 754116     981            mov y+0, #low (22 % 0x10000) 
0FDF 754200     981            mov y+1, #high(22 % 0x10000) 
0FE2 754300     981            mov y+2, #low (22 / 0x10000) 
0FE5 754400     981            mov y+3, #high(22 / 0x10000) 
0FE8 1201B5     982       lcall add32
0FEB 853D3B     983       mov Temp_oven, x+0
0FEE            984       ;add KTemp_oven, Temp_oven, #273
0FEE            985   
0FEE            986   Display_Temp_BCD_Or_Kelvin:
0FEE 1200F0     987            lcall hex2bcd ; converts binary in x to BCD in BCD
0FF1            988       ;mov a, K_or_C
0FF1            989       ;cjne a, #1, Display_3_digit_BCD
0FF1            990       ;mov a, KTemp_oven
0FF1            991       ;SendToLCD
0FF1            992       ;sjmp Send_Temp_Port
0FF1            993   
0FF1            994   Display_Temp_BCD:    
0FF1 120E0A     995       lcall Display_3_digit_BCD
0FF4            996   
0FF4            997   Send_Temp_Port:
0FF4            998       ;Send_BCD(bcd+4)
0FF4            999       ;Send_BCD(bcd+3)
0FF4           1000       ;Send_BCD(bcd+2)
0FF4 C000      1001       push ar0
0FF6 A846      1001       mov r0, bcd+1
0FF8 1200DA    1001       lcall ?Send_BCD
0FFB D000      1001       pop ar0
0FFD           1001   
0FFD C000      1002       push ar0
0FFF A845      1002       mov r0, bcd+0
1001 1200DA    1002       lcall ?Send_BCD
1004 D000      1002       pop ar0
1006           1002   
1006 740D      1003            mov a, #'\r'
1008 12047E    1004            lcall putchar
100B 740A      1005            mov a, #'\n'
100D 12047E    1006            lcall putchar
1010           1007   Check_Temp_done:
1010 22        1008   ret    
1011           1009   
1011           1010   ;-------------------------------------------------------------------------------------------------------------------------------
1011           1011   
1011           1012   ;Time wait
1011           1013   
1011           1014   Wait_One_Second:
1011 C002      1015            push AR2
1013 7AFA      1015            mov R2, #250
1015 120039    1015            lcall ?Wait_Milli_Seconds
1018 D002      1015            pop AR2
101A C002      1016            push AR2
101C 7AFA      1016            mov R2, #250
101E 120039    1016            lcall ?Wait_Milli_Seconds
1021 D002      1016            pop AR2
1023 C002      1017            push AR2
1025 7AFA      1017            mov R2, #250
1027 120039    1017            lcall ?Wait_Milli_Seconds
102A D002      1017            pop AR2
102C C002      1018            push AR2
102E 7AFA      1018            mov R2, #250
1030 120039    1018            lcall ?Wait_Milli_Seconds
1033 D002      1018            pop AR2
1035 22        1019   ret
1036           1020   
1036           1021   Wait_Half_Second:
1036 C002      1022            push AR2
1038 7AFA      1022            mov R2, #250
103A 120039    1022            lcall ?Wait_Milli_Seconds
103D D002      1022            pop AR2
103F C002      1023            push AR2
1041 7AFA      1023            mov R2, #250
1043 120039    1023            lcall ?Wait_Milli_Seconds
1046 D002      1023            pop AR2
1048 22        1024   ret
1049           1025   
1049           1026   
1049           1027   
1049           1028   Wait10us:
1049 784A      1029       mov R0, #74
104B D8FE      1030       djnz R0, $
104D 22        1031   ret
104E           1032   ; ==================================================================================================
104E           1033   
104E           1034   ;-------------------------------------;
104E           1035   ; ISR for Timer 1.  Used to playback  ;
104E           1036   ; the WAV file stored in the SPI      ;
104E           1037   ; flash memory.                       ;
104E           1038   ;-------------------------------------;
104E           1039   Timer1_ISR:
104E           1040            ; The registers used in the ISR must be saved in the stack
104E C0E0      1041            push acc
1050 C0D0      1042            push psw
1052           1043            
1052           1044            ; Check if the play counter is zero.  If so, stop playing sound.
1052 E54C      1045            mov a, w+0
1054 454D      1046            orl a, w+1
1056 454E      1047            orl a, w+2
1058 601C      1048            jz stop_playing
105A           1049            
105A           1050            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
105A 74FF      1051            mov a, #0xff
105C 154C      1052            dec w+0
105E B54C07    1053            cjne a, w+0, keep_playing
1061 154D      1054            dec w+1
1063 B54D02    1055            cjne a, w+1, keep_playing
1066 154E      1056            dec w+2
1068           1057            
1068           1058   keep_playing:
1068 D2A6      1059            setb SPEAKER
106A 12040D    1060            lcall Send_SPI ; Read the next byte from the SPI Flash...
106D           1061            ;mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
106D 2480      1062            add a, #0x80
106F F5AD      1063            mov DADH, a ; Output to DAC. DAC output is pin P2.3
1071 43A440    1064            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
1074 800C      1065            sjmp Timer1_ISR_Done
1076           1066   
1076           1067   stop_playing:
1076 C28E      1068            clr TR1 ; Stop timer 1
1078 D2A5      1069            setb FLASH_CE  ; Disable SPI Flash
107A C2A6      1070            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
107C 75AD80    1071            mov DADH, #0x80 ; middle of range
107F 43A440    1072            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
1082           1073   
1082           1074   Timer1_ISR_Done:         
1082 D0D0      1075            pop psw
1084 D0E0      1076            pop acc
1086 32        1077            reti
1087           1078   ; ==================================================================================================
1087           1079   
1087           1080   ;---------------------------------;
1087           1081   ; Routine to initialize the ISR   ;
1087           1082   ; for timer 2                     ;
1087           1083   ;---------------------------------;
1087           1084   Timer2_init:
1087 75C800    1085       mov T2CON, #0
108A 75CDA9    1086       mov TH2, #high(TIMER2_RELOAD)
108D 75CC9A    1087       mov TL2, #low(TIMER2_RELOAD)
1090           1088   
1090 75CBA9    1089       mov RCAP2H, #high(TIMER2_RELOAD)
1093 75CA9A    1090       mov RCAP2L, #low(TIMER2_RELOAD)
1096           1091   
1096 E4        1092       clr a
1097 F530      1093       mov Count1ms+0, a
1099 F531      1094       mov Count1ms+1, a
109B F532      1095       mov Count5sec , a
109D D2AD      1096       setb ET2
109F D2CA      1097       setb TR2
10A1 C202      1098       clr enable_clk
10A3 22        1099       ret
10A4           1100   
10A4           1101   ;---------------------------------;
10A4           1102   ; ISR for timer 2                 ;
10A4           1103   ;---------------------------------;
10A4           1104   Timer2_ISR:
10A4 C2CF      1105       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
10A6 B290      1106       cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
10A8           1107            
10A8           1108            ; The two registers used in the ISR must be saved in the stack
10A8 C0E0      1109       push acc
10AA C0D0      1110       push psw
10AC           1111            
10AC           1112            ; Increment the 16-bit one mili second counter
10AC 0530      1113            inc Count1ms+0    ; Increment the low 8-bits first
10AE E530      1114            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
10B0 7002      1115            jnz Inc_Done
10B2 0531      1116            inc Count1ms+1
10B4           1117   
10B4           1118   Inc_Done:
10B4           1119   
10B4           1120   ;**Oven Power Output-------------------
10B4           1121       ; Do the PWM thing
10B4           1122            ; Check if Count1ms > pwm_ratio (this is a 16-bit compare)
10B4 C3        1123            clr c
10B5 E54F      1124            mov a, pwm_ratio+0
10B7 9530      1125            subb a, Count1ms+0
10B9 E550      1126            mov a, pwm_ratio+1
10BB 9531      1127            subb a, Count1ms+1
10BD           1128            ; if Count1ms > pwm_ratio  the carry is set.  Just copy the carry to the pwm output pin:
10BD 9290      1129            mov PWM_OUTPUT, c
10BF           1130   ;**----------------------------------
10BF           1131            ; Check if one second has passed
10BF E530      1132            mov a, Count1ms+0
10C1 B4E831    1133            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
10C4 E531      1134            mov a, Count1ms+1
10C6 B4032C    1135            cjne a, #high(1000), Timer2_ISR_done
10C9           1136            
10C9           1137            ; 1000 milliseconds have passed.  Set a flag so the main program knows
10C9 D200      1138            setb one_seconds_flag ; Let the main program know one second had passed
10CB           1139       
10CB 0532      1140       inc Count5sec
10CD E532      1141       mov a, Count5sec
10CF B40505    1142       cjne a, #5, Set_5sec_flag_done
10D2 D201      1143       setb five_seconds_flag
10D4 E4        1144       clr a
10D5 F532      1145       mov Count5sec, a
10D7           1146       
10D7           1147   Set_5sec_flag_done:
10D7 E4        1148            clr a
10D8 F530      1149            mov Count1ms+0, a
10DA F531      1150            mov Count1ms+1, a
10DC           1151   
10DC 300216    1152       jnb enable_clk, Timer2_ISR_done ;if the clk is enabled, increment the second. Otherwise skip
10DF           1153   ; Increment the run time counter and state time counter
10DF E538      1154            mov a, Run_time_seconds
10E1 2401      1155            add a, #0x01
10E3 D4        1156            da a
10E4 F538      1157       mov Run_time_seconds, a
10E6           1158       ;check sec overflow
10E6 B4600A    1159       cjne a, #0x60, Check_sec_overflow_done
10E9 753800    1160       mov Run_time_seconds, #0x00
10EC E539      1161       mov a, Run_time_minutes ;inc min
10EE 2401      1162       add a, #1
10F0 D4        1163       da a
10F1 F539      1164       mov Run_time_minutes, a
10F3           1165   Check_sec_overflow_done:
10F3 053A      1166       inc State_time
10F5           1167   Timer2_ISR_done:
10F5 D0D0      1168            pop psw
10F7 D0E0      1169            pop acc
10F9 32        1170            reti
10FA           1171   
10FA           1172   
10FA           1173   ; ==================================================================================================
10FA           1174   
10FA           1175   main:
10FA 75817F    1176       mov SP, #0x7F
10FD 121087    1177       lcall Timer2_Init
1100           1178       ;lcall INI_SPI
1100 120088    1179       lcall LCD_4BIT
1103 120466    1180       lcall InitSerialPort
1106 120C55    1181       lcall INI_PLAYBACK_TEMP
1109           1182       ; In case you decide to use the pins of P0, configure the port in bidirectional mode. Can be ignored
1109 75E600    1183       mov P0M0, #0
110C 75E700    1184       mov P0M1, #0
110F D2AF      1185       setb EA   ;Enable global enterupt
1111           1186   
1111 120F13    1187       lcall Load_Configuration
1114           1188   
1114           1189       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
1114 754F00    1190            mov pwm_ratio+0, #low(0)
1117 755000    1191            mov pwm_ratio+1, #high(0)
111A 753300    1192       mov States, #0
111D 120E27    1193       lcall Animation
1120           1194       
1120           1195       
1120           1196   state0: ; idle
1120           1197       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
1120           1198            ;mov pwm_ratio+0, #low(0)
1120           1199            ;mov pwm_ratio+1, #high(0)
1120           1200       ;mov States, #0
1120           1201   
1120           1202   ;***initial parameters displayed***
1120           1203       
1120           1204       ;Displays Soak Temp and Time
1120 120D5D    1205       lcall State0_display
1123           1206       ;check power on
1123 1204F6    1207       lcall CHECK_POWER
1126           1208       ; check the parameters being pressed
1126 120486    1209       lcall CHECK_STIME
1129 1204A2    1210       lcall CHECK_STEMP
112C 1204BE    1211       lcall CHECK_RTIME
112F 1204DA    1212       lcall CHECK_RTEMP
1132 120EDC    1213       lcall Save_Configuration
1135           1214       
1135           1215       ;lcall Check_Temp
1135           1216       ;lcall PLAYBACK_TEMP
1135           1217   
1135 2085E8    1218       jb NEXT_STATE_BUTTON, state0
1138 C002      1219            push AR2
113A 7A32      1219            mov R2, #50
113C 120039    1219            lcall ?Wait_Milli_Seconds
113F D002      1219            pop AR2 ; debounce time
1141 2085DC    1220            jb NEXT_STATE_BUTTON, state0 ; if button not pressed, loop
1144 3085FD    1221            jnb NEXT_STATE_BUTTON, $
1147           1222   state0_done:
1147 753301    1223       mov States, #1
114A 753A00    1224       mov State_time, #0
114D D202      1225       setb enable_clk
114F           1226      
114F           1227        
114F           1228   
114F           1229   state1_beginning:
114F           1230       
114F           1231       ;Start Run Time
114F 753800    1232       mov Run_time_seconds, #0 ; time starts at 0:00
1152 753900    1233       mov Run_time_minutes, #0
1155 753A00    1234       mov State_time, #0
1158           1235   
1158           1236       ;***clear the screen and set new display***
1158 120CB7    1237       lcall Initialize_State_Display
115B C0E0      1238            push acc
115D 7407      1238            mov a, #7
115F 14        1238            dec a
1160 1200BD    1238            lcall ?Set_Cursor_2 ; Select column and row
1163 D0E0      1238            pop acc
1165 C083      1239            push dph
1167 C082      1239            push dpl
1169 C0E0      1239            push acc
116B 9003C7    1239            mov dptr, #Ramp2Soak
116E 1200B2    1239            lcall ?Send_Constant_String
1171 D0E0      1239            pop acc
1173 D082      1239            pop dpl
1175 D083      1239            pop dph; displays current state
1177           1240   
1177           1241       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
1177 754FE8    1242            mov pwm_ratio+0, #low(1000)
117A 755003    1243            mov pwm_ratio+1, #high(1000)
117D           1244       ; ***play audio***
117D           1244       ;cjne sound_flag, #0, $
117D           1244       
117D 121036    1244       lcall Wait_Half_Second
1180 C28E      1244       clr TR1 ; Stop Timer 1 ISR from playing previous request
1182 D2A5      1244       setb FLASH_CE
1184           1244       ;setb sound_flag ; sound starts
1184 C2A6      1244       clr SPEAKER ; Turn off speaker
1186 C2A5      1244       clr FLASH_CE ; Enable SPI Flash
1188 7403      1244       mov a, #READ_BYTES
118A 12040D    1244       lcall Send_SPI
118D           1244       ; Set the initial position in memory where to start playing
118D           1244       
118D 7400      1244       mov a, #0x00 ; change initial position
118F 12040D    1244       lcall Send_SPI
1192 7400      1244       mov a, #0x00 ; next memory position
1194 12040D    1244       lcall Send_SPI
1197 742D      1244       mov a, #0x2d ; next memory position
1199 12040D    1244       lcall Send_SPI
119C 7400      1244       mov a, #0x00 ; request first byte to send to DAC
119E 12040D    1244       lcall Send_SPI
11A1           1244       
11A1           1244       ; How many bytes to play?
11A1 754E00    1244       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
11A4 754D4E    1244       mov w+1, #0x4e ; Load the middle byte of the number of bytes to play
11A7 754C20    1244       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
11AA           1244       
11AA           1244       
11AA D2A6      1244       setb SPEAKER ;Turn on speaker
11AC D28E      1244       setb TR1 ;Start playback by enabling Timer1
11AE           1244       ;clr sound_flag ; sound ends
11AE 8003      1245       sjmp state1
11B0           1246       
11B0           1247   main_1:
11B0 0210FA    1248            ljmp main
11B3           1249   
11B3           1250   state1: ; ramp to soak
11B3           1251       
11B3           1252       ;PLAYBACK_TEMP(#0x00,#0x00,#0x2d, #0x4e,#0x20)
11B3           1253       ;check power on
11B3 1204F6    1254       lcall CHECK_POWER
11B6           1255       ;Update Time and Temp
11B6 120D36    1256       lcall Update_Display
11B9 120F8C    1257       lcall Average_Temp
11BC           1258       
11BC 120525    1259       lcall SOUND_FSM
11BF           1260   
11BF           1261   Check_Temp_done1:
11BF           1262   
11BF           1263       ;check if temp is below 150 
11BF E53B      1264       mov a, Temp_oven           
11C1 9534      1265       subb a, Temp_soak
11C3 5014      1266       jnc state1_done        ; if greater, jump to state 2
11C5 6012      1267       jz state1_done         ; if equal to, jump to state 2
11C7 4000      1268       jc Check_state1_safety ; if less than, check state time
11C9           1269   Check_state1_safety:       ; safety
11C9 E53B      1270       mov a, Temp_oven           
11CB 9432      1271       subb a, #50
11CD 50E4      1272       jnc state1             ; if greater, go back to state1
11CF E53A      1273       mov a, State_time      ; if less than 50C, check if state time is too long
11D1 943C      1274       subb a, #60
11D3 50DB      1275       jnc main_1             ; if greater, restart
11D5 60D9      1276       jz main_1              ; if equal to, restart
11D7 40DA      1277       jc state1              ; if less than, go back to state1
11D9           1278   ;*Checking moving to states with buttons---- 
11D9           1279   ;*Will remove after proper temperature reading----
11D9           1280   
11D9           1281       ;jb NEXT_STATE_BUTTON, state1
11D9           1282       ;Wait_Milli_Seconds(#50) ; debounce time
11D9           1283            ;jb NEXT_STATE_BUTTON, state1 ; if button not pressed, loop
11D9           1284            ;jnb NEXT_STATE_BUTTON, $ 
11D9           1285   
11D9           1286   state1_done:
11D9 753302    1287       mov States, #2
11DC           1288   
11DC           1289   ; preheat/soak
11DC           1290   state2_beginning: 
11DC 753A00    1291       mov State_time, #0;x00 ;clear the state time
11DF           1292       ;***clear the screen and set new display***
11DF 120CB7    1293       lcall Initialize_State_Display
11E2 C0E0      1294            push acc
11E4 7407      1294            mov a, #7
11E6 14        1294            dec a
11E7 1200BD    1294            lcall ?Set_Cursor_2 ; Select column and row
11EA D0E0      1294            pop acc
11EC C083      1295            push dph
11EE C082      1295            push dpl
11F0 C0E0      1295            push acc
11F2 9003D1    1295            mov dptr, #Soak
11F5 1200B2    1295            lcall ?Send_Constant_String
11F8 D0E0      1295            pop acc
11FA D082      1295            pop dpl
11FC D083      1295            pop dph ;displays current state
11FE           1296   
11FE           1297       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
11FE 754FC8    1298            mov pwm_ratio+0, #low(200)
1201 755000    1299            mov pwm_ratio+1, #high(000)
1204           1300       ; Produces SOAK on speaker
1204           1301       ; ***play audio***
1204           1301       ;cjne sound_flag, #0, $
1204           1301       
1204 121036    1301       lcall Wait_Half_Second
1207 C28E      1301       clr TR1 ; Stop Timer 1 ISR from playing previous request
1209 D2A5      1301       setb FLASH_CE
120B           1301       ;setb sound_flag ; sound starts
120B C2A6      1301       clr SPEAKER ; Turn off speaker
120D C2A5      1301       clr FLASH_CE ; Enable SPI Flash
120F 7403      1301       mov a, #READ_BYTES
1211 12040D    1301       lcall Send_SPI
1214           1301       ; Set the initial position in memory where to start playing
1214           1301       
1214 7400      1301       mov a, #0x00 ; change initial position
1216 12040D    1301       lcall Send_SPI
1219 7444      1301       mov a, #0x44 ; next memory position
121B 12040D    1301       lcall Send_SPI
121E 74DD      1301       mov a, #0xdd ; next memory position
1220 12040D    1301       lcall Send_SPI
1223 7400      1301       mov a, #0x00 ; request first byte to send to DAC
1225 12040D    1301       lcall Send_SPI
1228           1301       
1228           1301       ; How many bytes to play?
1228 754E00    1301       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
122B 754D4E    1301       mov w+1, #0x4e ; Load the middle byte of the number of bytes to play
122E 754C20    1301       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
1231           1301       
1231           1301       
1231 D2A6      1301       setb SPEAKER ;Turn on speaker
1233 D28E      1301       setb TR1 ;Start playback by enabling Timer1
1235           1301       ;clr sound_flag ; sound ends
1235           1302   
1235           1303   state2:
1235           1304       ;check power on
1235 1204F6    1305       lcall CHECK_POWER 
1238           1306       ;Update Time and Temp
1238 120D36    1307       lcall Update_Display
123B 120F8C    1308       lcall Average_Temp
123E           1309   
123E 120525    1310       lcall SOUND_FSM
1241           1311       
1241           1312       ; loop back to state2 if run time is less than soak time. If greater than jump to state3 cuz of overflow of time
1241           1313        
1241 E53A      1314       mov a, State_time
1243 9535      1315       subb a, Time_soak
1245 5002      1316       jnc state2_done
1247 40EC      1317       jc state2
1249           1318   
1249           1319   
1249           1320   ;*Checking moving to states with buttons---- 
1249           1321   ;*Will remove after proper temperature reading----
1249           1322   
1249           1323       ;jb NEXT_STATE_BUTTON, state2
1249           1324       ;Wait_Milli_Seconds(#50) ; debounce time
1249           1325            ;jb NEXT_STATE_BUTTON, state2 ; if button not pressed, loop
1249           1326            ;jnb NEXT_STATE_BUTTON, $ 
1249           1327       
1249           1328   state2_done:
1249 753A03    1329       mov State_time, #3
124C           1330   
124C           1331   ; ramp to peak
124C           1332   state3_beginning:
124C           1333       ;setb OVEN_POWER ;turn power on 100%
124C           1334   
124C           1335       ;***clear the screen and set new display***
124C 120CB7    1336       lcall Initialize_State_Display
124F C0E0      1337            push acc
1251 7407      1337            mov a, #7
1253 14        1337            dec a
1254 1200BD    1337            lcall ?Set_Cursor_2 ; Select column and row
1257 D0E0      1337            pop acc
1259 C083      1338            push dph
125B C082      1338            push dpl
125D C0E0      1338            push acc
125F 9003D6    1338            mov dptr, #Ramp2Peak
1262 1200B2    1338            lcall ?Send_Constant_String
1265 D0E0      1338            pop acc
1267 D082      1338            pop dpl
1269 D083      1338            pop dph
126B           1339   
126B           1340       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
126B 754FE8    1341            mov pwm_ratio+0, #low(1000)
126E 755003    1342            mov pwm_ratio+1, #high(1000)
1271           1343   
1271           1344       ; Produces RAMP TO PEAK on speaker
1271           1345       ; ***play audio***
1271           1345       ;cjne sound_flag, #0, $
1271           1345       
1271 121036    1345       lcall Wait_Half_Second
1274 C28E      1345       clr TR1 ; Stop Timer 1 ISR from playing previous request
1276 D2A5      1345       setb FLASH_CE
1278           1345       ;setb sound_flag ; sound starts
1278 C2A6      1345       clr SPEAKER ; Turn off speaker
127A C2A5      1345       clr FLASH_CE ; Enable SPI Flash
127C 7403      1345       mov a, #READ_BYTES
127E 12040D    1345       lcall Send_SPI
1281           1345       ; Set the initial position in memory where to start playing
1281           1345       
1281 7400      1345       mov a, #0x00 ; change initial position
1283 12040D    1345       lcall Send_SPI
1286 748B      1345       mov a, #0x8b ; next memory position
1288 12040D    1345       lcall Send_SPI
128B 74CA      1345       mov a, #0xca ; next memory position
128D 12040D    1345       lcall Send_SPI
1290 7400      1345       mov a, #0x00 ; request first byte to send to DAC
1292 12040D    1345       lcall Send_SPI
1295           1345       
1295           1345       ; How many bytes to play?
1295 754E00    1345       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
1298 754D75    1345       mov w+1, #0x75 ; Load the middle byte of the number of bytes to play
129B 754C30    1345       mov w+0, #0x30 ; Load the low byte of the number of bytes to play
129E           1345       
129E           1345       
129E D2A6      1345       setb SPEAKER ;Turn on speaker
12A0 D28E      1345       setb TR1 ;Start playback by enabling Timer1
12A2           1345       ;clr sound_flag ; sound ends
12A2           1346   
12A2           1347   state3: 
12A2           1348       ;check power on
12A2 1204F6    1349       lcall CHECK_POWER
12A5 120F8C    1350       lcall Average_Temp
12A8           1351       
12A8           1352       
12A8           1353       ;Update Time and Temp
12A8 120D36    1354       lcall Update_Display
12AB 120525    1355       lcall SOUND_FSM
12AE           1356   
12AE           1357       
12AE E53B      1358       mov a, Temp_oven           
12B0 9536      1359       subb a, Temp_refl
12B2 5004      1360       jnc state3_done    ; if greater, jump to state 4
12B4 6002      1361       jz state3_done ; if equal to, jump to state 4
12B6 40EA      1362       jc state3 ; if less than, go back to state3
12B8           1363       
12B8           1364       ;jb NEXT_STATE_BUTTON, state3
12B8           1365       ;Wait_Milli_Seconds(#50) ; debounce time
12B8           1366            ;jb NEXT_STATE_BUTTON, state3 ; if button not pressed, loop
12B8           1367            ;jnb NEXT_STATE_BUTTON, $
12B8           1368   
12B8           1369   state3_done:
12B8 753A04    1370       mov State_time, #4
12BB           1371   
12BB           1372   ; reflow 
12BB           1373   state4_beginning:
12BB           1374       
12BB 753A00    1375       mov State_time, #0;x00 clear the state time
12BE           1376       ;***clear the screen and set new display***
12BE 120CB7    1377       lcall Initialize_State_Display
12C1 C0E0      1378            push acc
12C3 7407      1378            mov a, #7
12C5 14        1378            dec a
12C6 1200BD    1378            lcall ?Set_Cursor_2 ; Select column and row
12C9 D0E0      1378            pop acc
12CB C083      1379            push dph
12CD C082      1379            push dpl
12CF C0E0      1379            push acc
12D1 9003E0    1379            mov dptr, #Reflow
12D4 1200B2    1379            lcall ?Send_Constant_String
12D7 D0E0      1379            pop acc
12D9 D082      1379            pop dpl
12DB D083      1379            pop dph
12DD           1380   
12DD           1381       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
12DD 754FC8    1382            mov pwm_ratio+0, #low(200)
12E0 755000    1383            mov pwm_ratio+1, #high(000)
12E3           1384   
12E3           1385       ; Produces REFLOW on speaker
12E3           1386       ; ***play audio***
12E3           1386       ;cjne sound_flag, #0, $
12E3           1386       
12E3 121036    1386       lcall Wait_Half_Second
12E6 C28E      1386       clr TR1 ; Stop Timer 1 ISR from playing previous request
12E8 D2A5      1386       setb FLASH_CE
12EA           1386       ;setb sound_flag ; sound starts
12EA C2A6      1386       clr SPEAKER ; Turn off speaker
12EC C2A5      1386       clr FLASH_CE ; Enable SPI Flash
12EE 7403      1386       mov a, #READ_BYTES
12F0 12040D    1386       lcall Send_SPI
12F3           1386       ; Set the initial position in memory where to start playing
12F3           1386       
12F3 7400      1386       mov a, #0x00 ; change initial position
12F5 12040D    1386       lcall Send_SPI
12F8 74F0      1386       mov a, #0xf0 ; next memory position
12FA 12040D    1386       lcall Send_SPI
12FD 7463      1386       mov a, #0x63 ; next memory position
12FF 12040D    1386       lcall Send_SPI
1302 7400      1386       mov a, #0x00 ; request first byte to send to DAC
1304 12040D    1386       lcall Send_SPI
1307           1386       
1307           1386       ; How many bytes to play?
1307 754E00    1386       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
130A 754D59    1386       mov w+1, #0x59 ; Load the middle byte of the number of bytes to play
130D 754CD8    1386       mov w+0, #0xd8 ; Load the low byte of the number of bytes to play
1310           1386       
1310           1386       
1310 D2A6      1386       setb SPEAKER ;Turn on speaker
1312 D28E      1386       setb TR1 ;Start playback by enabling Timer1
1314           1386       ;clr sound_flag ; sound ends
1314           1387   
1314           1388   
1314           1389   state4:
1314           1390       ;check power on
1314 1204F6    1391       lcall CHECK_POWER
1317           1392       ;Update Time and Temp
1317 120D36    1393       lcall Update_Display
131A 120F8C    1394       lcall Average_Temp
131D 120525    1395       lcall SOUND_FSM
1320           1396   
1320           1397       
1320           1398       ; loop back to state2 if run time is less than soak time
1320 E53A      1399       mov a, State_time
1322 9537      1400       subb a, Time_refl
1324 5002      1401       jnc state4_done
1326 40EC      1402       jc state4
1328           1403   
1328           1404       ;*Checking moving to states with buttons---- 
1328           1405   ;*Will remove after proper temperature reading----
1328           1406   
1328           1407       ;jb NEXT_STATE_BUTTON, state4
1328           1408       ;Wait_Milli_Seconds(#50) ; debounce time
1328           1409            ;jb NEXT_STATE_BUTTON, state4 ; if button not pressed, loop
1328           1410            ;jnb NEXT_STATE_BUTTON, $ 
1328           1411   
1328           1412   state4_done: 
1328 753A00    1413       mov State_time, #0
132B 02132E    1414       ljmp state5_beginning 
132E           1415   
132E           1416   
132E           1417   ; cooling
132E           1418   state5_beginning: ; turn oven off
132E C287      1419       clr OVEN_POWER
1330           1420   
1330           1421   ;***clear the screen and set new display***
1330 120CB7    1422       lcall Initialize_State_Display
1333 C083      1423            push dph
1335 C082      1423            push dpl
1337 C0E0      1423            push acc
1339 9003E7    1423            mov dptr, #Cooling
133C 1200B2    1423            lcall ?Send_Constant_String
133F D0E0      1423            pop acc
1341 D082      1423            pop dpl
1343 D083      1423            pop dph
1345           1424   
1345           1425       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
1345 754F00    1426            mov pwm_ratio+0, #low(0)
1348 755000    1427            mov pwm_ratio+1, #high(0)
134B           1428   
134B           1429       ; Produces COOLING on speaker
134B           1430       ; ***play audio***
134B           1430       ;cjne sound_flag, #0, $
134B           1430       
134B 121036    1430       lcall Wait_Half_Second
134E C28E      1430       clr TR1 ; Stop Timer 1 ISR from playing previous request
1350 D2A5      1430       setb FLASH_CE
1352           1430       ;setb sound_flag ; sound starts
1352 C2A6      1430       clr SPEAKER ; Turn off speaker
1354 C2A5      1430       clr FLASH_CE ; Enable SPI Flash
1356 7403      1430       mov a, #READ_BYTES
1358 12040D    1430       lcall Send_SPI
135B           1430       ; Set the initial position in memory where to start playing
135B           1430       
135B 7401      1430       mov a, #0x01 ; change initial position
135D 12040D    1430       lcall Send_SPI
1360 7448      1430       mov a, #0x48 ; next memory position
1362 12040D    1430       lcall Send_SPI
1365 749A      1430       mov a, #0x9a ; next memory position
1367 12040D    1430       lcall Send_SPI
136A 7401      1430       mov a, #0x01 ; request first byte to send to DAC
136C 12040D    1430       lcall Send_SPI
136F           1430       
136F           1430       ; How many bytes to play?
136F 754E00    1430       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
1372 754D6B    1430       mov w+1, #0x6b ; Load the middle byte of the number of bytes to play
1375 754C6C    1430       mov w+0, #0x6c ; Load the low byte of the number of bytes to play
1378           1430       
1378           1430       
1378 D2A6      1430       setb SPEAKER ;Turn on speaker
137A D28E      1430       setb TR1 ;Start playback by enabling Timer1
137C           1430       ;clr sound_flag ; sound ends
137C           1431   
137C           1432   state5:
137C           1433       ;check power on
137C 1204F6    1434       lcall CHECK_POWER
137F           1435       
137F           1436       ; update display
137F 120D36    1437       lcall Update_Display
1382 120F8C    1438       lcall Average_Temp
1385           1439   
1385 120525    1440       lcall SOUND_FSM
1388           1441   
1388 E53B      1442       mov a, Temp_oven
138A 943C      1443       subb a, #60
138C 50EE      1444       JNC state5    ; if greater, jump back to state 5
138E 60EC      1445       JZ state5 ; if equal to, go back to state5
1390 4000      1446       JC state5_done ; if less than, go back to state 0
1392           1447   
1392           1448       ;*Checking moving to states with buttons---- 
1392           1449   ;*Will remove after proper temperature reading----
1392           1450   
1392           1451       ;jb NEXT_STATE_BUTTON, state5
1392           1452       ;Wait_Milli_Seconds(#50) ; debounce time
1392           1453            ;jb NEXT_STATE_BUTTON, state5 ; if button not pressed, loop
1392           1454            ;jnb NEXT_STATE_BUTTON, $ 
1392           1455   
1392           1456   state5_done:
1392 753A00    1457       mov State_time, #0
1395 753300    1458       mov States, #0
1398 0210FA    1459       ljmp main
139B           1460   
139B           1461   EN
