                  2   $LIST
0000              4   
0000              5   
0000              6   ;-------------------------------------------------------------------------------------------------------------------------------
0000              7   ;These EQU must match the wiring between the microcontroller and ADC
0000              8   CLK  EQU 22118400
0000              9   TIMER1_RATE    EQU 25000 ;22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             10   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             11   BAUD equ 115200
0000             12   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000             13   
0000             14   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             15   TIMER2_RELOAD EQU (65536-(CLK/TIMER2_RATE))
0000             16   
0000             17   ;shjfjdfs
0000             18   ;-------------------------------------------------------------------------------------------------------------------------------
0000             19   ;Button Pin Mapping
0000             20   NEXT_STATE_BUTTON  equ P0.5
0000             21   STIME_BUTTON    equ P0.2
0000             22   STEMP_BUTTON    equ P0.3
0000             23   RTIME_BUTTON    equ P0.4
0000             24   RTEMP_BUTTON    equ P0.6
0000             25   
0000             26   POWER_BUTTON    equ P4.5
0000             27   SHIFT_BUTTON    equ p0.4
0000             28   
0000             29   ;Output Pins
0000             30   OVEN_POWER      equ P0.7
0000             31   SPEAKER         equ P2.6
0000             32   
0000             33   PWM_OUTPUT    equ P1.0 ; Attach an LED (with 1k resistor in series) to P1.0
0000             34   
0000             35   
0000             36   ;FLASH pins
0000             37   MY_MOSI_SOUND EQU P2.4
0000             38   MY_MISO_SOUND EQU P2.1
0000             39   MY_SCLK_SOUND EQU P2.0
0000             40   FLASH_CE        equ P2.5
0000             41   
0000             42   ;Thermowire Pins
0000             43   CE_ADC    EQU  P1.7
0000             44   MY_MOSI   EQU  P1.6
0000             45   MY_MISO   EQU  P1.5
0000             46   MY_SCLK   EQU  P1.4 
0000             47   
0000             48   ; Commands supported by the SPI flash memory according to the datasheet
0000             49   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             50   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             51   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             52   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             53   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             54   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             55   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             56   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             57   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             58   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             59   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             60   
0000             61   ; These 'equ' must match the hardware wiring
0000             62   LCD_RS equ P3.2
0000             63   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
0000             64   LCD_E  equ P3.3
0000             65   LCD_D4 equ P3.4
0000             66   LCD_D5 equ P3.5
0000             67   LCD_D6 equ P3.6
0000             68   LCD_D7 equ P3.7
0000             69   
0000             70   ;-------------------------------------------------------------------------------------------------------------------------------
0000             71   
0000             72   org 0x0000
0000 020AC0      73       ljmp main
0003             74   
0003             75   ; External interrupt 0 vector (not used in this code)
0003             76   org 0x0003
0003 32          77            reti
0004             78   
0004             79   ; Timer/Counter 0 overflow interrupt vector
000B             80   org 0x000B
000B 32          81            reti
000C             82   
000C             83   ; External interrupt 1 vector (not used in this code)
0013             84   org 0x0013
0013 32          85            reti
0014             86   
0014             87   ; Timer/Counter 1 overflow interrupt vector
001B             88   org 0x001B
001B 020A14      89            ljmp Timer1_ISR
001E             90   
001E             91   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             92   org 0x0023 
0023 32          93            reti
0024             94            
0024             95   ; Timer/Counter 2 overflow interrupt vector
002B             96   org 0x002B
002B 020A6A      97       ljmp Timer2_ISR
002E             98   ;-------------------------------------------------------------------------------------------------------------------------------
002E             99   ; Place our variables here
0030            100   DSEG at 0x30 ; Before the state machine!
0030            101   Count1ms:         ds 2 ; Used to determine when one second has passed
0032            102   Count5sec:        ds 1
0033            103   States:           ds 1
0034            104   Temp_soak:        ds 1
0035            105   Time_soak:        ds 1
0036            106   Temp_refl:        ds 1
0037            107   Time_refl:        ds 1
0038            108   Run_time_seconds: ds 1
0039            109   Run_time_minutes: ds 1
003A            110   State_time:       ds 1
003B            111   Temp_oven:        ds 1
003C            112   KTemp_oven:       ds 1
003D            113   x:                ds 4
0041            114   y:                ds 4
0045            115   bcd:              ds 5
004A            116   Result:           ds 2
004C            117   w:                ds 3
004F            118   pwm_ratio:        ds 2
0051            119   average_count:    ds 1
0052            120   K_or_C:           ds 1
0053            121   
                123   $LIST
00F0            125   
                546   $LIST
                127   $LIST
0360            129   
                131   $LIST
03E7            133   
0000            134   bseg
0000            135   one_seconds_flag:  dbit 1
0001            136   five_seconds_flag: dbit 1
0002            137   enable_clk:        dbit 1
0003            138   mf:                dbit 1
0004            139   
03E7            140   cseg
03E7            141   
03E7            142   ;-------------------------------------------------------------------------------------------------------------------------------
03E7            143   ;***Messages To Display*** 
03E7            144   
03E7            145   ;shortened labels
03E7 53546D70   146   STemp:  db 'STmp:', 0
     3A00
03ED 53546D3A   147   STime:  db 'STm:', 0
     00
03F2 52546D70   148   RTemp:  db 'RTmp:', 0
     3A00
03F8 52546D3A   149   RTime:  db 'RTm:', 0
     00
03FD            150   
03FD            151   ;lables for runnning oven
03FD 53746174   152   state:     db 'State>' , 0
     653E00
0404 546D653E   153   time:      db 'Tme>' , 0
     00
0409 3A00       154   colon:     db ':', 0
040B 546D703E   155   temp:      db 'Tmp>', 0
     00
0410            156   
0410            157   ;labels for changin parameters
0410 5265666C   158   ReflowTemp:  db 'Reflow Temperature:', 0
     6F772054
     656D7065
     72617475
     72653A00
0424 5265666C   159   ReflowTime:  db 'Reflow Time:', 0
     6F772054
     696D653A
     00
0431 536F616B   160   SoakTime:    db 'Soak Time:', 0
     2054696D
     653A00
043C 536F616B   161   SoakTemp:    db 'Soak Temperature:', 0
     2054656D
     70657261
     74757265
     3A00
044E            162   
044E            163   
044E            164   ;Current State in Oven
044E 52616D70   165   Ramp2Soak: db 'Ramp-Soak' , 0
     2D536F61
     6B00
0458 536F616B   166   Soak:      db 'Soak' , 0
     00
045D 52616D70   167   Ramp2Peak: db 'Ramp-Peak' , 0
     2D506561
     6B00
0467 5265666C   168   Reflow:    db 'Reflow' , 0
     6F7700
046E 436F6F6C   169   Cooling:   db 'Cooling' , 0
     696E6700
0476            170   
0476            171   ;-------------------------------------------------------------------------------------------------------------------------------
0476            172   ;FXNS FOR THERMOWIRE
0476            173   
0476            174   ;initialize SPI 
0476            175   INI_SPI:
0476 D295       176            setb MY_MISO          ; Make MISO an input pin
0478 C294       177            clr MY_SCLK           ; Mode 0,0 default
047A 22         178            ret
047B            179   DO_SPI_G:
047B C0E0       180            push acc
047D 7900       181            mov R1, #0            ; Received byte stored in R1
047F 7A08       182            mov R2, #8            ; Loop counter (8-bits)
0481            183   DO_SPI_G_LOOP:
0481 E8         184            mov a, R0             ; Byte to write is in R0
0482 33         185            rlc a                 ; Carry flag has bit to write
0483 F8         186            mov R0, a
0484 9296       187            mov MY_MOSI, c
0486 D294       188            setb MY_SCLK          ; Transmit
0488 A295       189            mov c, MY_MISO        ; Read received bit
048A E9         190            mov a, R1             ; Save received bit in R1
048B 33         191            rlc a
048C F9         192            mov R1, a
048D C294       193            clr MY_SCLK
048F DAF0       194            djnz R2, DO_SPI_G_LOOP
0491 D0E0       195            pop acc
0493 22         196   ret
0494            197   
0494            198   Send_SPI:
                199   	SPIBIT MAC
                200   	    ; Send/Receive bit %0
                201   		rlc a
                202   		mov MY_MOSI_SOUND, c
                203   		setb MY_SCLK_SOUND
                204   		mov c, MY_MISO_SOUND
                205   		clr MY_SCLK_SOUND
                206   		mov acc.0, c
                207   	ENDMAC
0494            208            
0494            209                ; Send/Receive bit 7
0494 33         209                    rlc a
0495 92A4       209                    mov MY_MOSI_SOUND, c
0497 D2A0       209                    setb MY_SCLK_SOUND
0499 A2A1       209                    mov c, MY_MISO_SOUND
049B C2A0       209                    clr MY_SCLK_SOUND
049D 92E0       209                    mov acc.0, c
049F            210                ; Send/Receive bit 6
049F 33         210                    rlc a
04A0 92A4       210                    mov MY_MOSI_SOUND, c
04A2 D2A0       210                    setb MY_SCLK_SOUND
04A4 A2A1       210                    mov c, MY_MISO_SOUND
04A6 C2A0       210                    clr MY_SCLK_SOUND
04A8 92E0       210                    mov acc.0, c
04AA            211                ; Send/Receive bit 5
04AA 33         211                    rlc a
04AB 92A4       211                    mov MY_MOSI_SOUND, c
04AD D2A0       211                    setb MY_SCLK_SOUND
04AF A2A1       211                    mov c, MY_MISO_SOUND
04B1 C2A0       211                    clr MY_SCLK_SOUND
04B3 92E0       211                    mov acc.0, c
04B5            212                ; Send/Receive bit 4
04B5 33         212                    rlc a
04B6 92A4       212                    mov MY_MOSI_SOUND, c
04B8 D2A0       212                    setb MY_SCLK_SOUND
04BA A2A1       212                    mov c, MY_MISO_SOUND
04BC C2A0       212                    clr MY_SCLK_SOUND
04BE 92E0       212                    mov acc.0, c
04C0            213                ; Send/Receive bit 3
04C0 33         213                    rlc a
04C1 92A4       213                    mov MY_MOSI_SOUND, c
04C3 D2A0       213                    setb MY_SCLK_SOUND
04C5 A2A1       213                    mov c, MY_MISO_SOUND
04C7 C2A0       213                    clr MY_SCLK_SOUND
04C9 92E0       213                    mov acc.0, c
04CB            214                ; Send/Receive bit 2
04CB 33         214                    rlc a
04CC 92A4       214                    mov MY_MOSI_SOUND, c
04CE D2A0       214                    setb MY_SCLK_SOUND
04D0 A2A1       214                    mov c, MY_MISO_SOUND
04D2 C2A0       214                    clr MY_SCLK_SOUND
04D4 92E0       214                    mov acc.0, c
04D6            215                ; Send/Receive bit 1
04D6 33         215                    rlc a
04D7 92A4       215                    mov MY_MOSI_SOUND, c
04D9 D2A0       215                    setb MY_SCLK_SOUND
04DB A2A1       215                    mov c, MY_MISO_SOUND
04DD C2A0       215                    clr MY_SCLK_SOUND
04DF 92E0       215                    mov acc.0, c
04E1            216                ; Send/Receive bit 0
04E1 33         216                    rlc a
04E2 92A4       216                    mov MY_MOSI_SOUND, c
04E4 D2A0       216                    setb MY_SCLK_SOUND
04E6 A2A1       216                    mov c, MY_MISO_SOUND
04E8 C2A0       216                    clr MY_SCLK_SOUND
04EA 92E0       216                    mov acc.0, c
04EC            217   
04EC 22         218   ret
04ED            219   
                220   Change_8bit_Variable MAC
                221       jb %0, %2
                222       Wait_Milli_Seconds(#50) ; de-bounce
                223       jb %0, %2
                224       jnb %0, $
                225       jb SHIFT_BUTTON, skip%Mb
                226       dec %1
                227       sjmp skip%Ma
                228       skip%Mb:
                229       inc %1
                230       skip%Ma:
                231   ENDMAC
04ED            232   
04ED            233   ;Change_8bit_Variable(MY_VARIABLE_BUTTON, my_variable, loop_c)
04ED            234   ;    Set_Cursor(2, 14)
04ED            235   ;    mov a, my_variable
04ED            236   ;    lcall SendToLCD
04ED            237   ;lcall Save_Configuration
04ED            238   
04ED            239   ;-------------------------------------------------------------------------------------------------------------------------------
04ED            240   ;***FXNS For Serial Port
04ED            241   
04ED            242   ; Configure the serial port and baud rate
04ED            243   InitSerialPort:
04ED            244       ; Since the reset button bounces, we need to wait a bit before
04ED            245       ; sending messages, otherwise we risk displaying gibberish!
04ED 79DE       246       mov R1, #222
04EF 78A6       247       mov R0, #166
04F1 D8FE       248       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
04F3 D9FA       249       djnz R1, $-4 ; 22.51519us*222=4.998ms
04F5            250       ; Now we can proceed with the configuration
04F5 438780     251            orl     PCON,#0x80
04F8 759852     252            mov     SCON,#0x52
04FB 759B00     253            mov     BDRCON,#0x00
04FE 759AF4     254            mov     BRL,#BRG_VAL
0501 759B1E     255            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0504 22         256   ret
0505            257   
0505            258   
0505            259   putchar:
0505 3099FD     260       jnb TI, putchar
0508 C299       261       clr TI
050A F599       262       mov SBUF, a
050C 22         263   ret
050D            264   
050D            265   ;-------------------------------------------------------------------------------------------------------------------------------
050D            266   ;***FXNS to CHECK BUTTONS
050D            267   
050D            268   CHECK_STIME:
050D            269   
050D 208218     270       jb STIME_BUTTON, CHECK_STIME_END
0510 C002       270            push AR2
0512 7A32       270            mov R2, #50
0514 120039     270            lcall ?Wait_Milli_Seconds
0517 D002       270            pop AR2 ; de-bounce
0519 20820C     270       jb STIME_BUTTON, CHECK_STIME_END
051C 3082FD     270       jnb STIME_BUTTON, $
051F 208404     270       jb SHIFT_BUTTON, skip16b
0522 1535       270       dec Time_soak
0524 8002       270       sjmp skip16a
0526            270       skip16b:
0526 0535       270       inc Time_soak
0528            270       skip16a:
0528            271            
0528            272   CHECK_STIME_END:
0528 22         273   ret
0529            274   
0529            275   CHECK_STEMP:
0529 208318     276       jb STEMP_BUTTON, CHECK_STEMP_END
052C C002       276            push AR2
052E 7A32       276            mov R2, #50
0530 120039     276            lcall ?Wait_Milli_Seconds
0533 D002       276            pop AR2 ; de-bounce
0535 20830C     276       jb STEMP_BUTTON, CHECK_STEMP_END
0538 3083FD     276       jnb STEMP_BUTTON, $
053B 208404     276       jb SHIFT_BUTTON, skip18b
053E 1534       276       dec Temp_soak
0540 8002       276       sjmp skip18a
0542            276       skip18b:
0542 0534       276       inc Temp_soak
0544            276       skip18a:
0544            277       ;lcall Save_Configuration
0544            278            
0544            279   CHECK_STEMP_END:
0544 22         280   ret
0545            281   
0545            282   CHECK_RTIME:
0545 208418     283       jb RTIME_BUTTON, CHECK_RTIME_END
0548 C002       283            push AR2
054A 7A32       283            mov R2, #50
054C 120039     283            lcall ?Wait_Milli_Seconds
054F D002       283            pop AR2 ; de-bounce
0551 20840C     283       jb RTIME_BUTTON, CHECK_RTIME_END
0554 3084FD     283       jnb RTIME_BUTTON, $
0557 208404     283       jb SHIFT_BUTTON, skip20b
055A 1537       283       dec Time_refl
055C 8002       283       sjmp skip20a
055E            283       skip20b:
055E 0537       283       inc Time_refl
0560            283       skip20a:
0560            284   CHECK_RTIME_END:
0560 22         285   ret
0561            286   
0561            287   CHECK_RTEMP:
0561 208618     288       jb RTEMP_BUTTON, CHECK_RTEMP_END
0564 C002       288            push AR2
0566 7A32       288            mov R2, #50
0568 120039     288            lcall ?Wait_Milli_Seconds
056B D002       288            pop AR2 ; de-bounce
056D 20860C     288       jb RTEMP_BUTTON, CHECK_RTEMP_END
0570 3086FD     288       jnb RTEMP_BUTTON, $
0573 208404     288       jb SHIFT_BUTTON, skip22b
0576 1536       288       dec Temp_refl
0578 8002       288       sjmp skip22a
057A            288       skip22b:
057A 0536       288       inc Temp_refl
057C            288       skip22a:
057C            289   CHECK_RTEMP_END:
057C 22         290   ret
057D            291   
057D            292   CHECK_POWER:
057D            293   
057D 20C518     294       jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
0580 C002       295            push AR2
0582 7A32       295            mov R2, #50
0584 120039     295            lcall ?Wait_Milli_Seconds
0587 D002       295            pop AR2 ; debounce time
0589 20C50C     296            jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
058C 30C5FD     297            jnb POWER_BUTTON, $ ; loop while the button is pressed
058F 754F00     298       mov pwm_ratio+0, #low(0)
0592 755000     299            mov pwm_ratio+1, #high(0)
0595 12090F     300       lcall OFF_STATE
0598            301   
0598            302   CHECK_POWER_END:
0598 22         303   ret
0599            304   
0599            305   CHECK_K_OR_C:
0599            306   
0599 20860F     307       jb RTEMP_BUTTON, CHECK_K_OR_C_END ; if button not pressed, stop checking
059C C002       308            push AR2
059E 7A32       308            mov R2, #50
05A0 120039     308            lcall ?Wait_Milli_Seconds
05A3 D002       308            pop AR2 ; debounce time
05A5 208603     309            jb RTEMP_BUTTON, CHECK_K_OR_C_END ; if button not pressed, stop checking
05A8 3086FD     310            jnb RTEMP_BUTTON, $ ; loop while the button is pressed
05AB            311       
05AB            312       ;mov a, K_or_C
05AB            313       ;anl a,
05AB            314       ;anl a, #00000001B  ; We need only the two least significant bits
05AB            315   
05AB            316   
05AB            317   
05AB            318   
05AB            319   CHECK_K_OR_C_END:
05AB 22         320   ret
05AC            321   
05AC            322   
05AC            323   ;**SOUND STUFF---------------------------------------------------------------
05AC            324   
05AC            325   SOUND_FSM:
05AC            326   state_0_sound:
05AC            327   ;check if 5 seconds has passed, if yes go to state 1, if no exit function 
05AC 300105     328       jnb five_seconds_flag, Sound_ret
05AF C201       329       clr five_seconds_flag
05B1 0205B5     330       ljmp state_1_sound
05B4            331   Sound_ret:
05B4 22         332       ret
05B5            333   
05B5            334   state_1_sound:
05B5            335   ; check if temp is greater than 100, if yes go to state 2
05B5            336   ; check if temp is less than 100, if yes go to state 4
05B5 E53B       337       mov a, Temp_oven
05B7 9464       338       subb a, #100
05B9 5002       339       jnc state_2_sound
05BB 4023       340       jc state_4_sound
05BD            341   
05BD            342   state_2_sound:
05BD            343   ;divide temp by 100, if it is 1 play sound: "100", if it is 2 play sound: "200"
05BD            344   ; go to state_3_sound
05BD 75F064     345       mov b, #100
05C0 E53B       346       mov a, Temp_oven
05C2 84         347       div ab
05C3 9401       348       subb a, #1
05C5 600A       349       jz play_sound_1
05C7            350   
05C7 75F064     351       mov b, #100
05CA E53B       352       mov a, Temp_oven
05CC 84         353       div ab
05CD 9402       354       subb a, #2
05CF 6000       355       jz play_sound_1
05D1            356      
05D1            357      play_sound_1: 
05D1            358       ;ljmp PLAYBACK_TEMP
05D1            359   
05D1 0205D4     360       ljmp state_3_sound
05D4            361   
05D4            362   
05D4            363   state_3_sound:
05D4            364   ; check remainder of temp, if it is 0, go back to state_0_sound
05D4            365   ; if not 0, go to state_4_sound
05D4            366   
05D4 75F064     367       mov b, #100
05D7 E53B       368       mov a, Temp_oven
05D9 84         369       div ab
05DA E5F0       370       mov a, b
05DC 60CE       371       jz state_0_sound
05DE 7000       372       jnz state_4_sound
05E0            373   
05E0            374   state_4_sound:
05E0            375   ; if T % 100 greater or equal to 20, go to state_5_sound,
05E0 75F064     376       mov b, #100
05E3 E53B       377       mov a, Temp_oven
05E5 84         378       div ab
05E6 E5F0       379       mov a, b 
05E8 9414       380       subb a, #20
05EA 5011       381       jnc state_5_sound
05EC E4         382       clr a
05ED            383   ; if T % 100 is less than 10, go to state_6_sound
05ED 75F064     384       mov b, #100
05F0 E53B       385       mov a, Temp_oven
05F2 84         386       div ab
05F3 E5F0       387       mov a, b
05F5 940A       388       subb a, #10
05F7 4019       389       jc state_6_sound
05F9 E4         390       clr a
05FA            391   ; if T % 100 is greater than 10 and less than 20, go to state_7_sound
05FA 020615     392       ljmp state_7_sound
05FD            393       
05FD            394   
05FD            395   state_5_sound:
05FD            396   ; play number from 20 to 90 in decades (20, 30, 40, 50, 60, 70, 80, 90), based off remainder from temp divided by 100
05FD            397   ; if (T % 100) % 10 is not equal to 0, go to state_6_sound
05FD            398   ; if (T % 100) % 10 is equal to 0, go to state_8_sound
05FD            399   
05FD E53B       400       mov a, Temp_oven
05FF 75F064     401       mov b, #100 
0602 84         402       div ab
0603 E5F0       403       mov a, b
0605 75F00A     404       mov b, #10
0608 84         405       div ab
0609 E5F0       406       mov a, b
060B 6002       407       jz play_sound
060D 7003       408       jnz state_6_sound
060F            409       
060F            410   
060F            411       play_sound:
060F            412           ;ljmp PLAYBACK_TEMP
060F 020618     413           ljmp state_8_sound
0612            414   
0612            415   
0612            416   state_6_sound:
0612            417   ; play 1 - 9
0612            418       ;ljmp PLAYBACK_TEMP
0612            419   ; go to state_8_sound
0612 020618     420       ljmp state_8_sound
0615            421   
0615            422   
0615            423   state_7_sound:
0615            424   ; play 10 - 19
0615            425       ;ljmp PLAYBACK_TEMP
0615            426   ; go to state_8_sound 
0615 020618     427       ljmp state_8_sound
0618            428   
0618            429   state_8_sound:
0618            430   ; go to state_0_sound
0618 0205AC     431       ljmp state_0_sound
061B            432   
061B            433   
061B            434   INI_PLAYBACK_TEMP:
061B            435       ; ****INITIALIZATION****
061B            436       ; Configure SPI pins and turn off speaker
061B            437            ;anl P2M0, #0b_1100_1110
061B 43CE90     438       orl P2M0, #0b_1001_0000
061E            439       ;orl P2M0, #0b_0011_0001
061E            440            ;orl P2M1, #0b_0011_0001
061E 43CF90     441       orl P2M1, #0b_1001_0000
0621 D2A1       442            setb MY_MISO_SOUND  ; Configured as input
0623 D2A5       443            setb FLASH_CE ; CS=1 for SPI flash memory
0625 C2A0       444            clr MY_SCLK_SOUND   ; Rest state of SCLK=0
0627 C2A6       445            clr SPEAKER   ; Turn off speaker.
0629            446            
0629            447            ; Configure timer 1
0629 53890F     448            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
062C 438910     449            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
062F 758DFC     450            mov TH1, #high(TIMER1_RELOAD)
0632 758B8C     451            mov TL1, #low(TIMER1_RELOAD)
0635            452            ; Set autoreload value
0635 75F5FC     453            mov RH1, #high(TIMER1_RELOAD)
0638 75F38C     454            mov RL1, #low(TIMER1_RELOAD)
063B            455   
063B            456            ;Enable the timer and interrupts
063B D2AB       457       setb ET1  ; Enable timer 1 interrupt
063D D28E       458            setb TR1 ; Timer 1 is only enabled to play stored sound
063F            459   
063F            460            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
063F 75A5A0     461            mov DADI, #0b_1010_0000 ; ACON=1
0642 75A43A     462            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0645 75AD80     463            mov DADH, #0x80 ; Middle of scale
0648 75AC00     464            mov DADL, #0
064B 43A440     465            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
064E            466       check_DAC_init:
064E E5A4       467            mov a, DADC
0650 20E6FB     468            jb acc.6, check_DAC_init ; Wait for DAC to finish
0653            469            
0653 22         470   ret
0654            471   
                472   PLAYBACK_TEMP MAC
                473       ; ***play audio***
                474       clr TR1 ; Stop Timer 1 ISR from playing previous request
                475       setb FLASH_CE
                476       clr SPEAKER ; Turn off speaker
                477       
                478       clr FLASH_CE ; Enable SPI Flash
                479       mov a, #READ_BYTES
                480       lcall Send_SPI
                481       ; Set the initial position in memory where to start playing
                482       
                483       mov a, %0 ; change initial position
                484       lcall Send_SPI
                485       mov a, %1 ; next memory position
                486       lcall Send_SPI
                487       mov a, %2 ; next memory position
                488       lcall Send_SPI
                489       mov a, %0 ; request first byte to send to DAC
                490       lcall Send_SPI
                491       
                492       ; How many bytes to play?
                493       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
                494       mov w+1, %3 ; Load the middle byte of the number of bytes to play
                495       mov w+0, %4 ; Load the low byte of the number of bytes to play
                496       
                497       
                498       setb SPEAKER ;Turn on speaker
                499       setb TR1 ;Start playback by enabling Timer1
                500   ENDMAC
0654            501       
0654            502   ;-------------------------------------------------------------------------------------------------------------------------------
0654            503   ;***LCD FXNS
0654            504   
                505   Display_lower_BCD mac
                506       push ar0
                507       mov r0, %0
                508       lcall ?Display_lower_BCD
                509       pop ar0
                510   endmac
0654            511   
0654            512   ?Display_lower_BCD:
0654 C0E0       513       push acc
0656            514       ; write least significant digit
0656 E8         515       mov a, r0
0657 540F       516       anl a, #0fh
0659 4430       517       orl a, #30h
065B 12007E     518       lcall ?WriteData
065E D0E0       519       pop acc
0660 22         520   ret
0661            521   
0661            522   
0661            523   SendToLCD:
0661 75F064     524       mov b, #100
0664 84         525       div ab
0665 4430       526       orl a, #0x30h ; Convert hundreds to ASCII
0667 12007E     527       lcall ?WriteData ; Send to LCD
066A E5F0       528       mov a, b    ; Remainder is in register b
066C 75F00A     529       mov b, #10
066F 84         530       div ab
0670 4430       531       orl a, #0x30h ; Convert tens to ASCII
0672 12007E     532       lcall ?WriteData; Send to LCD
0675 E5F0       533       mov a, b
0677 4430       534       orl a, #0x30h ; Convert units to ASCII
0679 12007E     535       lcall ?WriteData; Send to LCD
067C 22         536   ret
067D            537   
067D            538   Initialize_State_Display:
067D            539   
067D            540       ;***clear the screen and set new display***
067D 7401       541            mov a, #0x01
067F 120083     541            lcall ?WriteCommand
0682 C002       542            push AR2
0684 7A02       542            mov R2, #2
0686 120039     542            lcall ?Wait_Milli_Seconds
0689 D002       542            pop AR2
068B            543       
068B C0E0       544            push acc
068D 7401       544            mov a, #1
068F 14         544            dec a
0690 1200BF     544            lcall ?Set_Cursor_1 ; Select column and row
0693 D0E0       544            pop acc
0695 C083       545            push dph
0697 C082       545            push dpl
0699 C0E0       545            push acc
069B 900404     545            mov dptr, #time
069E 1200B2     545            lcall ?Send_Constant_String
06A1 D0E0       545            pop acc
06A3 D082       545            pop dpl
06A5 D083       545            pop dph
06A7            546            
06A7 C0E0       547            push acc
06A9 7406       547            mov a, #6
06AB 14         547            dec a
06AC 1200BF     547            lcall ?Set_Cursor_1 ; Select column and row
06AF D0E0       547            pop acc
06B1 C083       548            push dph
06B3 C082       548            push dpl
06B5 C0E0       548            push acc
06B7 900409     548            mov dptr, #colon
06BA 1200B2     548            lcall ?Send_Constant_String
06BD D0E0       548            pop acc
06BF D082       548            pop dpl
06C1 D083       548            pop dph
06C3            549      
06C3 C0E0       550            push acc
06C5 740A       550            mov a, #10
06C7 14         550            dec a
06C8 1200BF     550            lcall ?Set_Cursor_1 ; Select column and row
06CB D0E0       550            pop acc
06CD C083       551            push dph
06CF C082       551            push dpl
06D1 C0E0       551            push acc
06D3 90040B     551            mov dptr, #temp
06D6 1200B2     551            lcall ?Send_Constant_String
06D9 D0E0       551            pop acc
06DB D082       551            pop dpl
06DD D083       551            pop dph
06DF            552       
06DF C0E0       553            push acc
06E1 7401       553            mov a, #1
06E3 14         553            dec a
06E4 1200BD     553            lcall ?Set_Cursor_2 ; Select column and row
06E7 D0E0       553            pop acc
06E9 C083       554            push dph
06EB C082       554            push dpl
06ED C0E0       554            push acc
06EF 9003FD     554            mov dptr, #state
06F2 1200B2     554            lcall ?Send_Constant_String
06F5 D0E0       554            pop acc
06F7 D082       554            pop dpl
06F9 D083       554            pop dph
06FB 22         555   ret
06FC            556   
06FC            557   Update_Display:
06FC C0E0       558            push acc
06FE 7405       558            mov a, #5
0700 14         558            dec a
0701 1200BF     558            lcall ?Set_Cursor_1 ; Select column and row
0704 D0E0       558            pop acc
0706 C000       559       push ar0
0708 A839       559       mov r0, Run_time_minutes
070A 120654     559       lcall ?Display_lower_BCD
070D D000       559       pop ar0
070F C0E0       560            push acc
0711 7407       560            mov a, #7
0713 14         560            dec a
0714 1200BF     560            lcall ?Set_Cursor_1 ; Select column and row
0717 D0E0       560            pop acc
0719 C000       561            push ar0
071B A838       561            mov r0, Run_time_seconds
071D 1200C4     561            lcall ?Display_BCD
0720 D000       561            pop ar0
0722            562       ;Set_Cursor(1,14)
0722            563       ;mov a, Temp_oven
0722            564       ;SendToLCD(Temp_oven)
0722 22         565   ret
0723            566   
0723            567   State0_display:
0723 C0E0       568            push acc
0725 7401       568            mov a, #1
0727 14         568            dec a
0728 1200BF     568            lcall ?Set_Cursor_1 ; Select column and row
072B D0E0       568            pop acc
072D C083       569            push dph
072F C082       569            push dpl
0731 C0E0       569            push acc
0733 9003E7     569            mov dptr, #STemp
0736 1200B2     569            lcall ?Send_Constant_String
0739 D0E0       569            pop acc
073B D082       569            pop dpl
073D D083       569            pop dph
073F C0E0       570            push acc
0741 7406       570            mov a, #6
0743 14         570            dec a
0744 1200BF     570            lcall ?Set_Cursor_1 ; Select column and row
0747 D0E0       570            pop acc
0749 E534       571       mov a, Temp_soak
074B 120661     572       lcall SendToLCD
074E            573       
074E C0E0       574            push acc
0750 740A       574            mov a, #10
0752 14         574            dec a
0753 1200BF     574            lcall ?Set_Cursor_1 ; Select column and row
0756 D0E0       574            pop acc
0758 C083       575            push dph
075A C082       575            push dpl
075C C0E0       575            push acc
075E 9003ED     575            mov dptr, #STime
0761 1200B2     575            lcall ?Send_Constant_String
0764 D0E0       575            pop acc
0766 D082       575            pop dpl
0768 D083       575            pop dph
076A C0E0       576            push acc
076C 740E       576            mov a, #14
076E 14         576            dec a
076F 1200BF     576            lcall ?Set_Cursor_1 ; Select column and row
0772 D0E0       576            pop acc
0774 E535       577       mov a, Time_soak
0776 120661     578            lcall SendToLCD
0779            579       ;Display_BCD(Time_soak)
0779            580   
0779            581       ;Displays Reflow Temp and Time
0779 C0E0       582            push acc
077B 7401       582            mov a, #1
077D 14         582            dec a
077E 1200BD     582            lcall ?Set_Cursor_2 ; Select column and row
0781 D0E0       582            pop acc
0783 C083       583            push dph
0785 C082       583            push dpl
0787 C0E0       583            push acc
0789 9003F2     583            mov dptr, #RTemp
078C 1200B2     583            lcall ?Send_Constant_String
078F D0E0       583            pop acc
0791 D082       583            pop dpl
0793 D083       583            pop dph
0795 C0E0       584            push acc
0797 7406       584            mov a, #6
0799 14         584            dec a
079A 1200BD     584            lcall ?Set_Cursor_2 ; Select column and row
079D D0E0       584            pop acc
079F E536       585       mov a, Temp_refl
07A1 120661     586       lcall SendToLCD
07A4            587       
07A4 C0E0       588            push acc
07A6 740A       588            mov a, #10
07A8 14         588            dec a
07A9 1200BD     588            lcall ?Set_Cursor_2 ; Select column and row
07AC D0E0       588            pop acc
07AE C083       589            push dph
07B0 C082       589            push dpl
07B2 C0E0       589            push acc
07B4 9003F8     589            mov dptr, #RTime
07B7 1200B2     589            lcall ?Send_Constant_String
07BA D0E0       589            pop acc
07BC D082       589            pop dpl
07BE D083       589            pop dph
07C0 C0E0       590            push acc
07C2 740E       590            mov a, #14
07C4 14         590            dec a
07C5 1200BD     590            lcall ?Set_Cursor_2 ; Select column and row
07C8 D0E0       590            pop acc
07CA E537       591       mov a, Time_refl
07CC 120661     592            lcall SendToLCD
07CF 22         593   ret
07D0            594   
07D0            595   Display_3_digit_BCD:
07D0 C0E0       596            push acc
07D2 740E       596            mov a, #14
07D4 14         596            dec a
07D5 1200BF     596            lcall ?Set_Cursor_1 ; Select column and row
07D8 D0E0       596            pop acc
07DA C000       597       push ar0
07DC A846       597       mov r0, bcd+1
07DE 120654     597       lcall ?Display_lower_BCD
07E1 D000       597       pop ar0
07E3 C000       598            push ar0
07E5 A845       598            mov r0, bcd+0
07E7 1200C4     598            lcall ?Display_BCD
07EA D000       598            pop ar0
07EC 22         599   ret
07ED            600   
07ED            601   Animation:
07ED 740F       602            mov a, #0x0f
07EF 120083     602            lcall ?WriteCommand ;display cursor
07F2            603   
07F2            604       ;name ; Move cursor to line 1 column 1
07F2 7480       605            mov a, #0x80
07F4 120083     605            lcall ?WriteCommand
07F7 7457       606            mov a, #'W'
07F9 12007E     606            lcall ?WriteData
07FC C002       607            push AR2
07FE 7AFA       607            mov R2, #250
0800 120039     607            lcall ?Wait_Milli_Seconds
0803 D002       607            pop AR2
0805 7465       608            mov a, #'e'
0807 12007E     608            lcall ?WriteData
080A C002       609            push AR2
080C 7AFA       609            mov R2, #250
080E 120039     609            lcall ?Wait_Milli_Seconds
0811 D002       609            pop AR2
0813 746C       610            mov a, #'l'
0815 12007E     610            lcall ?WriteData
0818 C002       611            push AR2
081A 7AFA       611            mov R2, #250
081C 120039     611            lcall ?Wait_Milli_Seconds
081F D002       611            pop AR2
0821 7463       612            mov a, #'c'
0823 12007E     612            lcall ?WriteData
0826 C002       613            push AR2
0828 7AFA       613            mov R2, #250
082A 120039     613            lcall ?Wait_Milli_Seconds
082D D002       613            pop AR2
082F 746F       614            mov a, #'o'
0831 12007E     614            lcall ?WriteData
0834 C002       615            push AR2
0836 7AFA       615            mov R2, #250
0838 120039     615            lcall ?Wait_Milli_Seconds
083B D002       615            pop AR2
083D 746D       616            mov a, #'m'
083F 12007E     616            lcall ?WriteData
0842 C002       617            push AR2
0844 7AFA       617            mov R2, #250
0846 120039     617            lcall ?Wait_Milli_Seconds
0849 D002       617            pop AR2
084B 7465       618            mov a, #'e'
084D 12007E     618            lcall ?WriteData
0850 C002       619            push AR2
0852 7AFA       619            mov R2, #250
0854 120039     619            lcall ?Wait_Milli_Seconds
0857 D002       619            pop AR2
0859 7421       620            mov a, #'!'
085B 12007E     620            lcall ?WriteData
085E C002       621            push AR2
0860 7AFA       621            mov R2, #250
0862 120039     621            lcall ?Wait_Milli_Seconds
0865 D002       621            pop AR2
0867 7420       622            mov a, #' '
0869 12007E     622            lcall ?WriteData
086C C002       623            push AR2
086E 7AFA       623            mov R2, #250
0870 120039     623            lcall ?Wait_Milli_Seconds
0873 D002       623            pop AR2
0875 7460       624            mov a, #96
0877 12007E     624            lcall ?WriteData
087A C002       625            push AR2
087C 7AFA       625            mov R2, #250
087E 120039     625            lcall ?Wait_Milli_Seconds
0881 D002       625            pop AR2
0883 74EF       626            mov a, #239
0885 12007E     626            lcall ?WriteData
0888 C002       627            push AR2
088A 7AFA       627            mov R2, #250
088C 120039     627            lcall ?Wait_Milli_Seconds
088F D002       627            pop AR2
0891 742F       628            mov a, #47
0893 12007E     628            lcall ?WriteData
0896 1209D7     629       lcall Wait_One_Second
0899 1209D7     630       lcall Wait_One_Second
089C 740C       631            mov a, #0x0c
089E 120083     631            lcall ?WriteCommand ;clear cursor
08A1 22         632   ret
08A2            633   
08A2            634   ;The following functions store and restore the values--------------------------------------------------------------------------
                635   loadbyte mac
                636       mov a, %0
                637       movx @dptr, a
                638       inc dptr
                639   endmac
08A2            640   
08A2            641   Save_Configuration:
08A2 C0A8       642       push IE ; Save the current state of bit EA in the stack
08A4 C2AF       643       clr EA ; Disable interrupts
08A6 75D108     644       mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
08A9 907F80     645       mov dptr, #0x7f80 ; Last page of flash memory
08AC            646       ; Save variables
08AC E534       647       mov a, temp_soak
08AE F0         647       movx @dptr, a
08AF A3         647       inc dptr ; @0x7f80
08B0 E535       648       mov a, time_soak
08B2 F0         648       movx @dptr, a
08B3 A3         648       inc dptr ; @0x7f81
08B4 E536       649       mov a, temp_refl
08B6 F0         649       movx @dptr, a
08B7 A3         649       inc dptr ; @0x7f82
08B8 E537       650       mov a, time_refl
08BA F0         650       movx @dptr, a
08BB A3         650       inc dptr ; @0x7f83
08BC 7455       651       mov a, #0x55
08BE F0         651       movx @dptr, a
08BF A3         651       inc dptr ; First key value @0x7f84
08C0 74AA       652       mov a, #0xAA
08C2 F0         652       movx @dptr, a
08C3 A3         652       inc dptr ; Second key value @0x7f85
08C4 75D100     653       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0) 
08C7 43D240     654       orl EECON, #0b01000000 ; Enable auto-erase on next write sequence  
08CA 75D150     655       mov FCON, #0x50 ; Write trigger first byte
08CD 75D1A0     656       mov FCON, #0xA0 ; Write trigger second byte
08D0            657       ; CPU idles until writing of flash completes.
08D0 75D100     658       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
08D3 53D2BF     659       anl EECON, #0b10111111 ; Disable auto-erase
08D6 D0A8       660       pop IE ; Restore the state of bit EA from the stack
08D8 22         661   ret
08D9            662   
                663   getbyte mac
                664       clr a
                665       movc a, @a+dptr
                666       mov %0, a
                667       inc dptr
                668   endmac
08D9            669   
08D9            670   Load_Configuration:
08D9 907F84     671       mov dptr, #0x7f84 ; First key value location.
08DC E4         672       clr a
08DD 93         672       movc a, @a+dptr
08DE F8         672       mov R0, a
08DF A3         672       inc dptr ; 0x7f84 should contain 0x55
08E0 B8551F     673       cjne R0, #0x55, Load_Defaults
08E3 E4         674       clr a
08E4 93         674       movc a, @a+dptr
08E5 F8         674       mov R0, a
08E6 A3         674       inc dptr ; 0x7f85 should contain 0xAA
08E7 B8AA18     675       cjne R0, #0xAA, Load_Defaults
08EA            676   ; Keys are good.  Get stored values.
08EA 907F80     677       mov dptr, #0x7f80
08ED E4         678       clr a
08EE 93         678       movc a, @a+dptr
08EF F534       678       mov Temp_soak, a
08F1 A3         678       inc dptr ; 0x7f80
08F2 E4         679       clr a
08F3 93         679       movc a, @a+dptr
08F4 F535       679       mov Time_soak, a
08F6 A3         679       inc dptr ; 0x7f81
08F7 E4         680       clr a
08F8 93         680       movc a, @a+dptr
08F9 F536       680       mov Temp_refl, a
08FB A3         680       inc dptr ; 0x7f82
08FC E4         681       clr a
08FD 93         681       movc a, @a+dptr
08FE F537       681       mov Time_refl, a
0900 A3         681       inc dptr ; 0x7f83
0901 22         682   ret
0902            683   
0902            684   Load_Defaults:
0902 753482     685       mov Temp_soak, #130 ; Soak Tmp Range is 130-170
0905 75353C     686       mov Time_soak, #0x3C ; Range 60-90 seconds
0908 7536DC     687       mov Temp_refl, #220 ; Range 220-240
090B 75371E     688       mov Time_refl, #0x1E ; Range 30-45 seconds
090E 22         689       ret 
090F            690   ;-------------------------------------------------------------------------------------------------------------------------------
090F            691   ;off state
090F            692   
090F            693   OFF_STATE:
090F            694       ;**CLEAR SCREEN**
090F 7401       695            mov a, #0x01
0911 120083     695            lcall ?WriteCommand
0914            696       ;OFF_STATE1:
0914            697       
0914 20C5FD     698       jb POWER_BUTTON, $ ; loop while the button is not pressed
0917 C002       699            push AR2
0919 7A32       699            mov R2, #50
091B 120039     699            lcall ?Wait_Milli_Seconds
091E D002       699            pop AR2 ; debounce time
0920 20C5EC     700            jb POWER_BUTTON, OFF_STATE ; it was a bounce, try again
0923 30C5FD     701            jnb POWER_BUTTON, $ ; loop while the button is pressed
0926 020AC0     702       ljmp main
0929 22         703   ret
092A            704   ;-------------------------------------------------------------------------------------------------------------------------------
092A            705   
092A            706   ;***CHECK TEMPERATURE BY READING VOLTAGE AND CONVERTING
092A            707   Check_Temp:
092A            708       
092A            709       ;jnb one_seconds_flag, Check_Temp_done
092A            710       ;clr one_seconds_flag
092A            711       
092A C297       712       clr CE_ADC
092C 7801       713            mov R0, #00000001B ; Start bit:1
092E 12047B     714            lcall DO_SPI_G
0931 7880       715            mov R0, #10000000B ; Single ended, read channel 0
0933 12047B     716            lcall DO_SPI_G
0936 E9         717            mov a, R1          ; R1 contains bits 8 and 9
0937 5403       718            anl a, #00000011B  ; We need only the two least significant bits
0939 F54B       719            mov Result+1, a    ; Save result high.
093B 7855       720            mov R0, #55H ; It doesn't matter what we transmit...
093D 12047B     721            lcall DO_SPI_G
0940 894A       722            mov Result+0, R1     ; R1 contains bits 0 to 7.  Save result low.
0942 D297       723            setb CE_ADC
0944            724   
0944 C002       725            push AR2
0946 7A0A       725            mov R2, #10
0948 120039     725            lcall ?Wait_Milli_Seconds
094B D002       725            pop AR2
094D            726       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
094D AE4A       727            mov R6, Result+0
094F AF4B       728            mov R7, Result+1
0951 22         729   ret
0952            730   
0952            731       
0952            732       
0952            733   ;***CALCULATES THE TEMPERATURE
0952            734   Average_Temp:
0952 753D00     735            mov x+0, #low (0 % 0x10000) 
0955 753E00     735            mov x+1, #high(0 % 0x10000) 
0958 753F00     735            mov x+2, #low (0 / 0x10000) 
095B 754000     735            mov x+3, #high(0 / 0x10000) 
095E 7D64       736       mov R5, #100
0960            737   Ave_loop:
0960 12092A     738       lcall Check_Temp
0963 754400     739       mov y+3, #0
0966 754300     740       mov y+2, #0
0969 8F42       741       mov y+1, R7
096B 8E41       742       mov y+0, R6
096D 1201B5     743       lcall add32
0970 120A0F     744       lcall Wait10us
0973 DDEB       745       djnz R5, Ave_loop
0975 754164     746            mov y+0, #low (100 % 0x10000) 
0978 754200     746            mov y+1, #high(100 % 0x10000) 
097B 754300     746            mov y+2, #low (100 / 0x10000) 
097E 754400     746            mov y+3, #high(100 / 0x10000) 
0981 1202F7     747       lcall div32
0984            748   
0984            749       ;**INSERT MATH FUNCTIONS
0984            750   
0984 75414E     751            mov y+0, #low (2894 % 0x10000) 
0987 75420B     751            mov y+1, #high(2894 % 0x10000) 
098A 754300     751            mov y+2, #low (2894 / 0x10000) 
098D 754400     751            mov y+3, #high(2894 / 0x10000)  ;6078; 2026
0990 12026A     752            lcall mul32
0993 754110     753            mov y+0, #low (10000 % 0x10000) 
0996 754227     753            mov y+1, #high(10000 % 0x10000) 
0999 754300     753            mov y+2, #low (10000 / 0x10000) 
099C 754400     753            mov y+3, #high(10000 / 0x10000)  ;14000; 7000
099F 1202F7     754            lcall div32
09A2 754116     755            mov y+0, #low (22 % 0x10000) 
09A5 754200     755            mov y+1, #high(22 % 0x10000) 
09A8 754300     755            mov y+2, #low (22 / 0x10000) 
09AB 754400     755            mov y+3, #high(22 / 0x10000) 
09AE 1201B5     756       lcall add32
09B1 853D3B     757       mov Temp_oven, x+0
09B4            758       ;add KTemp_oven, Temp_oven, #273
09B4            759   
09B4            760   Display_Temp_BCD_Or_Kelvin:
09B4 1200F0     761            lcall hex2bcd ; converts binary in x to BCD in BCD
09B7            762       ;mov a, K_or_C
09B7            763       ;cjne a, #1, Display_3_digit_BCD
09B7            764       ;mov a, KTemp_oven
09B7            765       ;SendToLCD
09B7            766       ;sjmp Send_Temp_Port
09B7            767   
09B7            768   Display_Temp_BCD:    
09B7 1207D0     769       lcall Display_3_digit_BCD
09BA            770   
09BA            771   Send_Temp_Port:
09BA            772       ;Send_BCD(bcd+4)
09BA            773       ;Send_BCD(bcd+3)
09BA            774       ;Send_BCD(bcd+2)
09BA C000       775       push ar0
09BC A846       775       mov r0, bcd+1
09BE 1200DA     775       lcall ?Send_BCD
09C1 D000       775       pop ar0
09C3            775   
09C3 C000       776       push ar0
09C5 A845       776       mov r0, bcd+0
09C7 1200DA     776       lcall ?Send_BCD
09CA D000       776       pop ar0
09CC            776   
09CC 740D       777            mov a, #'\r'
09CE 120505     778            lcall putchar
09D1 740A       779            mov a, #'\n'
09D3 120505     780            lcall putchar
09D6            781   Check_Temp_done:
09D6 22         782   ret    
09D7            783   
09D7            784   ;-------------------------------------------------------------------------------------------------------------------------------
09D7            785   
09D7            786   ;Time wait
09D7            787   
09D7            788   Wait_One_Second:
09D7 C002       789            push AR2
09D9 7AFA       789            mov R2, #250
09DB 120039     789            lcall ?Wait_Milli_Seconds
09DE D002       789            pop AR2
09E0 C002       790            push AR2
09E2 7AFA       790            mov R2, #250
09E4 120039     790            lcall ?Wait_Milli_Seconds
09E7 D002       790            pop AR2
09E9 C002       791            push AR2
09EB 7AFA       791            mov R2, #250
09ED 120039     791            lcall ?Wait_Milli_Seconds
09F0 D002       791            pop AR2
09F2 C002       792            push AR2
09F4 7AFA       792            mov R2, #250
09F6 120039     792            lcall ?Wait_Milli_Seconds
09F9 D002       792            pop AR2
09FB 22         793   ret
09FC            794   
09FC            795   Wait_Half_Second:
09FC C002       796            push AR2
09FE 7AFA       796            mov R2, #250
0A00 120039     796            lcall ?Wait_Milli_Seconds
0A03 D002       796            pop AR2
0A05 C002       797            push AR2
0A07 7AFA       797            mov R2, #250
0A09 120039     797            lcall ?Wait_Milli_Seconds
0A0C D002       797            pop AR2
0A0E 22         798   ret
0A0F            799   
0A0F            800   
0A0F            801   
0A0F            802   Wait10us:
0A0F 784A       803       mov R0, #74
0A11 D8FE       804       djnz R0, $
0A13 22         805   ret
0A14            806   ; ==================================================================================================
0A14            807   
0A14            808   ;-------------------------------------;
0A14            809   ; ISR for Timer 1.  Used to playback  ;
0A14            810   ; the WAV file stored in the SPI      ;
0A14            811   ; flash memory.                       ;
0A14            812   ;-------------------------------------;
0A14            813   Timer1_ISR:
0A14            814            ; The registers used in the ISR must be saved in the stack
0A14 C0E0       815            push acc
0A16 C0D0       816            push psw
0A18            817            
0A18            818            ; Check if the play counter is zero.  If so, stop playing sound.
0A18 E54C       819            mov a, w+0
0A1A 454D       820            orl a, w+1
0A1C 454E       821            orl a, w+2
0A1E 601C       822            jz stop_playing
0A20            823            
0A20            824            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0A20 74FF       825            mov a, #0xff
0A22 154C       826            dec w+0
0A24 B54C07     827            cjne a, w+0, keep_playing
0A27 154D       828            dec w+1
0A29 B54D02     829            cjne a, w+1, keep_playing
0A2C 154E       830            dec w+2
0A2E            831            
0A2E            832   keep_playing:
0A2E D2A6       833            setb SPEAKER
0A30 120494     834            lcall Send_SPI ; Read the next byte from the SPI Flash...
0A33            835            ;mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
0A33 2480       836            add a, #0x80
0A35 F5AD       837            mov DADH, a ; Output to DAC. DAC output is pin P2.3
0A37 43A440     838            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0A3A 800C       839            sjmp Timer1_ISR_Done
0A3C            840   
0A3C            841   stop_playing:
0A3C C28E       842            clr TR1 ; Stop timer 1
0A3E D2A5       843            setb FLASH_CE  ; Disable SPI Flash
0A40 C2A6       844            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
0A42 75AD80     845            mov DADH, #0x80 ; middle of range
0A45 43A440     846            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0A48            847   
0A48            848   Timer1_ISR_Done:         
0A48 D0D0       849            pop psw
0A4A D0E0       850            pop acc
0A4C 32         851            reti
0A4D            852   ; ==================================================================================================
0A4D            853   
0A4D            854   ;---------------------------------;
0A4D            855   ; Routine to initialize the ISR   ;
0A4D            856   ; for timer 2                     ;
0A4D            857   ;---------------------------------;
0A4D            858   Timer2_init:
0A4D 75C800     859       mov T2CON, #0
0A50 75CDA9     860       mov TH2, #high(TIMER2_RELOAD)
0A53 75CC9A     861       mov TL2, #low(TIMER2_RELOAD)
0A56            862   
0A56 75CBA9     863       mov RCAP2H, #high(TIMER2_RELOAD)
0A59 75CA9A     864       mov RCAP2L, #low(TIMER2_RELOAD)
0A5C            865   
0A5C E4         866       clr a
0A5D F530       867       mov Count1ms+0, a
0A5F F531       868       mov Count1ms+1, a
0A61 F532       869       mov Count5sec , a
0A63 D2AD       870       setb ET2
0A65 D2CA       871       setb TR2
0A67 C202       872       clr enable_clk
0A69 22         873       ret
0A6A            874   
0A6A            875   ;---------------------------------;
0A6A            876   ; ISR for timer 2                 ;
0A6A            877   ;---------------------------------;
0A6A            878   Timer2_ISR:
0A6A C2CF       879       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0A6C B290       880       cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0A6E            881            
0A6E            882            ; The two registers used in the ISR must be saved in the stack
0A6E C0E0       883       push acc
0A70 C0D0       884       push psw
0A72            885            
0A72            886            ; Increment the 16-bit one mili second counter
0A72 0530       887            inc Count1ms+0    ; Increment the low 8-bits first
0A74 E530       888            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0A76 7002       889            jnz Inc_Done
0A78 0531       890            inc Count1ms+1
0A7A            891   
0A7A            892   Inc_Done:
0A7A            893   
0A7A            894   ;**Oven Power Output-------------------
0A7A            895       ; Do the PWM thing
0A7A            896            ; Check if Count1ms > pwm_ratio (this is a 16-bit compare)
0A7A C3         897            clr c
0A7B E54F       898            mov a, pwm_ratio+0
0A7D 9530       899            subb a, Count1ms+0
0A7F E550       900            mov a, pwm_ratio+1
0A81 9531       901            subb a, Count1ms+1
0A83            902            ; if Count1ms > pwm_ratio  the carry is set.  Just copy the carry to the pwm output pin:
0A83 9290       903            mov PWM_OUTPUT, c
0A85            904   ;**----------------------------------
0A85            905            ; Check if one second has passed
0A85 E530       906            mov a, Count1ms+0
0A87 B4E831     907            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0A8A E531       908            mov a, Count1ms+1
0A8C B4032C     909            cjne a, #high(1000), Timer2_ISR_done
0A8F            910            
0A8F            911            ; 1000 milliseconds have passed.  Set a flag so the main program knows
0A8F D200       912            setb one_seconds_flag ; Let the main program know one second had passed
0A91            913       
0A91 0532       914       inc Count5sec
0A93 E532       915       mov a, Count5sec
0A95 B40505     916       cjne a, #5, Set_5sec_flag_done
0A98 D201       917       setb five_seconds_flag
0A9A E4         918       clr a
0A9B F532       919       mov Count5sec, a
0A9D            920       
0A9D            921   Set_5sec_flag_done:
0A9D E4         922            clr a
0A9E F530       923            mov Count1ms+0, a
0AA0 F531       924            mov Count1ms+1, a
0AA2            925   
0AA2 300216     926       jnb enable_clk, Timer2_ISR_done ;if the clk is enabled, increment the second. Otherwise skip
0AA5            927   ; Increment the run time counter and state time counter
0AA5 E538       928            mov a, Run_time_seconds
0AA7 2401       929            add a, #0x01
0AA9 D4         930            da a
0AAA F538       931       mov Run_time_seconds, a
0AAC            932       ;check sec overflow
0AAC B4600A     933       cjne a, #0x60, Check_sec_overflow_done
0AAF 753800     934       mov Run_time_seconds, #0x00
0AB2 E539       935       mov a, Run_time_minutes ;inc min
0AB4 2401       936       add a, #1
0AB6 D4         937       da a
0AB7 F539       938       mov Run_time_minutes, a
0AB9            939   Check_sec_overflow_done:
0AB9 053A       940       inc State_time
0ABB            941   Timer2_ISR_done:
0ABB D0D0       942            pop psw
0ABD D0E0       943            pop acc
0ABF 32         944            reti
0AC0            945   
0AC0            946   
0AC0            947   ; ==================================================================================================
0AC0            948   
0AC0            949   main:
0AC0 75817F     950       mov SP, #0x7F
0AC3 120A4D     951       lcall Timer2_Init
0AC6            952       ;lcall INI_SPI
0AC6 120088     953       lcall LCD_4BIT
0AC9 1204ED     954       lcall InitSerialPort
0ACC 12061B     955       lcall INI_PLAYBACK_TEMP
0ACF            956       ; In case you decide to use the pins of P0, configure the port in bidirectional mode. Can be ignored
0ACF 75E600     957       mov P0M0, #0
0AD2 75E700     958       mov P0M1, #0
0AD5 D2AF       959       setb EA   ;Enable global enterupt
0AD7            960   
0AD7 1208D9     961       lcall Load_Configuration
0ADA            962   
0ADA            963       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0ADA 754F00     964            mov pwm_ratio+0, #low(0)
0ADD 755000     965            mov pwm_ratio+1, #high(0)
0AE0 753300     966       mov States, #0
0AE3 1207ED     967       lcall Animation
0AE6            968       
0AE6            969   state0: ; idle
0AE6            970       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0AE6            971            ;mov pwm_ratio+0, #low(0)
0AE6            972            ;mov pwm_ratio+1, #high(0)
0AE6            973       ;mov States, #0
0AE6            974   
0AE6            975   ;***initial parameters displayed***
0AE6            976       
0AE6            977       ;Displays Soak Temp and Time
0AE6 120723     978       lcall State0_display
0AE9            979       ;check power on
0AE9 12057D     980       lcall CHECK_POWER
0AEC            981       ; check the parameters being pressed
0AEC 12050D     982       lcall CHECK_STIME
0AEF 120529     983       lcall CHECK_STEMP
0AF2 120545     984       lcall CHECK_RTIME
0AF5 120561     985       lcall CHECK_RTEMP
0AF8 1208A2     986       lcall Save_Configuration
0AFB            987       
0AFB            988       ;lcall Check_Temp
0AFB            989       ;lcall PLAYBACK_TEMP
0AFB            990   
0AFB 2085E8     991       jb NEXT_STATE_BUTTON, state0
0AFE C002       992            push AR2
0B00 7A32       992            mov R2, #50
0B02 120039     992            lcall ?Wait_Milli_Seconds
0B05 D002       992            pop AR2 ; debounce time
0B07 2085DC     993            jb NEXT_STATE_BUTTON, state0 ; if button not pressed, loop
0B0A 3085FD     994            jnb NEXT_STATE_BUTTON, $
0B0D            995   state0_done:
0B0D 753301     996       mov States, #1
0B10 753A00     997       mov State_time, #0
0B13 D202       998       setb enable_clk
0B15            999      
0B15           1000        
0B15           1001   
0B15           1002   state1_beginning:
0B15           1003       
0B15           1004       ;Start Run Time
0B15 753800    1005       mov Run_time_seconds, #0 ; time starts at 0:00
0B18 753900    1006       mov Run_time_minutes, #0
0B1B 753A00    1007       mov State_time, #0
0B1E           1008   
0B1E           1009       ;***clear the screen and set new display***
0B1E 12067D    1010       lcall Initialize_State_Display
0B21 C0E0      1011            push acc
0B23 7407      1011            mov a, #7
0B25 14        1011            dec a
0B26 1200BD    1011            lcall ?Set_Cursor_2 ; Select column and row
0B29 D0E0      1011            pop acc
0B2B C083      1012            push dph
0B2D C082      1012            push dpl
0B2F C0E0      1012            push acc
0B31 90044E    1012            mov dptr, #Ramp2Soak
0B34 1200B2    1012            lcall ?Send_Constant_String
0B37 D0E0      1012            pop acc
0B39 D082      1012            pop dpl
0B3B D083      1012            pop dph; displays current state
0B3D           1013   
0B3D           1014       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0B3D 754FE8    1015            mov pwm_ratio+0, #low(1000)
0B40 755003    1016            mov pwm_ratio+1, #high(1000)
0B43 8003      1017       sjmp state1
0B45           1018       
0B45           1019   main_1:
0B45 020AC0    1020            ljmp main
0B48           1021   
0B48           1022   state1: ; ramp to soak
0B48           1023       
0B48           1024       ;PLAYBACK_TEMP(#0x00,#0x00,#0x2d, #0x4e,#0x20)
0B48           1025       ; ***play audio***
0B48 C28E      1025       clr TR1 ; Stop Timer 1 ISR from playing previous request
0B4A D2A5      1025       setb FLASH_CE
0B4C C2A6      1025       clr SPEAKER ; Turn off speaker
0B4E           1025       
0B4E C2A5      1025       clr FLASH_CE ; Enable SPI Flash
0B50 7403      1025       mov a, #READ_BYTES
0B52 120494    1025       lcall Send_SPI
0B55           1025       ; Set the initial position in memory where to start playing
0B55           1025       
0B55 7401      1025       mov a, #0x01 ; change initial position
0B57 120494    1025       lcall Send_SPI
0B5A 7448      1025       mov a, #0x48 ; next memory position
0B5C 120494    1025       lcall Send_SPI
0B5F 749A      1025       mov a, #0x9a ; next memory position
0B61 120494    1025       lcall Send_SPI
0B64 7401      1025       mov a, #0x01 ; request first byte to send to DAC
0B66 120494    1025       lcall Send_SPI
0B69           1025       
0B69           1025       ; How many bytes to play?
0B69 754E00    1025       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0B6C 754D59    1025       mov w+1, #0x59 ; Load the middle byte of the number of bytes to play
0B6F 754CD8    1025       mov w+0, #0xd8 ; Load the low byte of the number of bytes to play
0B72           1025       
0B72           1025       
0B72 D2A6      1025       setb SPEAKER ;Turn on speaker
0B74 D28E      1025       setb TR1 ;Start playback by enabling Timer1
0B76           1026       ;check power on
0B76 12057D    1027       lcall CHECK_POWER
0B79           1028       ;Update Time and Temp
0B79 1206FC    1029       lcall Update_Display
0B7C 120952    1030       lcall Average_Temp
0B7F           1031   
0B7F           1032   Check_Temp_done1:
0B7F           1033   
0B7F           1034       ;check if temp is below 150 
0B7F           1035       
0B7F E53B      1036       mov a, Temp_oven           
0B81 9534      1037       subb a, Temp_soak
0B83 500E      1038       jnc state1_done      ; if greater, jump to state 2
0B85 600C      1039       jz state1_done       ; if equal to, jump to state 2
0B87 4000      1040       jc Check_state1_time ; if less than, check state time
0B89           1041   Check_state1_time:       ;safety
0B89 E53A      1042       mov a, State_time      
0B8B 943C      1043       subb a, #60
0B8D 50B6      1044       jnc main_1             ; if greater, restart
0B8F 60B4      1045       jz main_1              ; if equal to, restart
0B91 40B5      1046       jc state1            ; if less than, go back to state1
0B93           1047   ;*Checking moving to states with buttons---- 
0B93           1048   ;*Will remove after proper temperature reading----
0B93           1049   
0B93           1050       ;jb NEXT_STATE_BUTTON, state1
0B93           1051       ;Wait_Milli_Seconds(#50) ; debounce time
0B93           1052            ;jb NEXT_STATE_BUTTON, state1 ; if button not pressed, loop
0B93           1053            ;jnb NEXT_STATE_BUTTON, $ 
0B93           1054   
0B93           1055   state1_done:
0B93 753302    1056       mov States, #2
0B96           1057   
0B96           1058   ; preheat/soak
0B96           1059   state2_beginning: 
0B96 753A00    1060       mov State_time, #0;x00 ;clear the state time
0B99           1061       ;***clear the screen and set new display***
0B99 12067D    1062       lcall Initialize_State_Display
0B9C C0E0      1063            push acc
0B9E 7407      1063            mov a, #7
0BA0 14        1063            dec a
0BA1 1200BD    1063            lcall ?Set_Cursor_2 ; Select column and row
0BA4 D0E0      1063            pop acc
0BA6 C083      1064            push dph
0BA8 C082      1064            push dpl
0BAA C0E0      1064            push acc
0BAC 900458    1064            mov dptr, #Soak
0BAF 1200B2    1064            lcall ?Send_Constant_String
0BB2 D0E0      1064            pop acc
0BB4 D082      1064            pop dpl
0BB6 D083      1064            pop dph ;displays current state
0BB8           1065   
0BB8           1066       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
0BB8 754FC8    1067            mov pwm_ratio+0, #low(200)
0BBB 755000    1068            mov pwm_ratio+1, #high(000)
0BBE           1069   
0BBE           1070   state2:
0BBE           1071       ; Produces SOAK on speaker
0BBE           1072       ; ***play audio***
0BBE C28E      1072       clr TR1 ; Stop Timer 1 ISR from playing previous request
0BC0 D2A5      1072       setb FLASH_CE
0BC2 C2A6      1072       clr SPEAKER ; Turn off speaker
0BC4           1072       
0BC4 C2A5      1072       clr FLASH_CE ; Enable SPI Flash
0BC6 7403      1072       mov a, #READ_BYTES
0BC8 120494    1072       lcall Send_SPI
0BCB           1072       ; Set the initial position in memory where to start playing
0BCB           1072       
0BCB 7400      1072       mov a, #0x00 ; change initial position
0BCD 120494    1072       lcall Send_SPI
0BD0 7444      1072       mov a, #0x44 ; next memory position
0BD2 120494    1072       lcall Send_SPI
0BD5 74DD      1072       mov a, #0xdd ; next memory position
0BD7 120494    1072       lcall Send_SPI
0BDA 7400      1072       mov a, #0x00 ; request first byte to send to DAC
0BDC 120494    1072       lcall Send_SPI
0BDF           1072       
0BDF           1072       ; How many bytes to play?
0BDF 754E00    1072       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0BE2 754D4E    1072       mov w+1, #0x4e ; Load the middle byte of the number of bytes to play
0BE5 754C20    1072       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
0BE8           1072       
0BE8           1072       
0BE8 D2A6      1072       setb SPEAKER ;Turn on speaker
0BEA D28E      1072       setb TR1 ;Start playback by enabling Timer1
0BEC           1073       ;check power on
0BEC 12057D    1074       lcall CHECK_POWER 
0BEF           1075       ;Update Time and Temp
0BEF 1206FC    1076       lcall Update_Display
0BF2 120952    1077       lcall Average_Temp
0BF5           1078       
0BF5           1079       ; loop back to state2 if run time is less than soak time. If greater than jump to state3 cuz of overflow of time
0BF5           1080        
0BF5 E53A      1081       mov a, State_time
0BF7 9535      1082       subb a, Time_soak
0BF9 5002      1083       jnc state2_done
0BFB 40C1      1084       jc state2
0BFD           1085   
0BFD           1086   
0BFD           1087   ;*Checking moving to states with buttons---- 
0BFD           1088   ;*Will remove after proper temperature reading----
0BFD           1089   
0BFD           1090       ;jb NEXT_STATE_BUTTON, state2
0BFD           1091       ;Wait_Milli_Seconds(#50) ; debounce time
0BFD           1092            ;jb NEXT_STATE_BUTTON, state2 ; if button not pressed, loop
0BFD           1093            ;jnb NEXT_STATE_BUTTON, $ 
0BFD           1094       
0BFD           1095   state2_done:
0BFD 753A03    1096       mov State_time, #3
0C00           1097   
0C00           1098   ; ramp to peak
0C00           1099   state3_beginning:
0C00           1100       ;setb OVEN_POWER ;turn power on 100%
0C00           1101   
0C00           1102       ;***clear the screen and set new display***
0C00 12067D    1103       lcall Initialize_State_Display
0C03 C0E0      1104            push acc
0C05 7407      1104            mov a, #7
0C07 14        1104            dec a
0C08 1200BD    1104            lcall ?Set_Cursor_2 ; Select column and row
0C0B D0E0      1104            pop acc
0C0D C083      1105            push dph
0C0F C082      1105            push dpl
0C11 C0E0      1105            push acc
0C13 90045D    1105            mov dptr, #Ramp2Peak
0C16 1200B2    1105            lcall ?Send_Constant_String
0C19 D0E0      1105            pop acc
0C1B D082      1105            pop dpl
0C1D D083      1105            pop dph
0C1F           1106   
0C1F           1107       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0C1F 754FE8    1108            mov pwm_ratio+0, #low(1000)
0C22 755003    1109            mov pwm_ratio+1, #high(1000)
0C25           1110   
0C25           1111   state3: 
0C25           1112       ; Produces RAMP TO PEAK on speaker
0C25           1113       ; ***play audio***
0C25 C28E      1113       clr TR1 ; Stop Timer 1 ISR from playing previous request
0C27 D2A5      1113       setb FLASH_CE
0C29 C2A6      1113       clr SPEAKER ; Turn off speaker
0C2B           1113       
0C2B C2A5      1113       clr FLASH_CE ; Enable SPI Flash
0C2D 7403      1113       mov a, #READ_BYTES
0C2F 120494    1113       lcall Send_SPI
0C32           1113       ; Set the initial position in memory where to start playing
0C32           1113       
0C32 7400      1113       mov a, #0x00 ; change initial position
0C34 120494    1113       lcall Send_SPI
0C37 748B      1113       mov a, #0x8b ; next memory position
0C39 120494    1113       lcall Send_SPI
0C3C 74CA      1113       mov a, #0xca ; next memory position
0C3E 120494    1113       lcall Send_SPI
0C41 7400      1113       mov a, #0x00 ; request first byte to send to DAC
0C43 120494    1113       lcall Send_SPI
0C46           1113       
0C46           1113       ; How many bytes to play?
0C46 754E00    1113       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0C49 754D75    1113       mov w+1, #0x75 ; Load the middle byte of the number of bytes to play
0C4C 754C30    1113       mov w+0, #0x30 ; Load the low byte of the number of bytes to play
0C4F           1113       
0C4F           1113       
0C4F D2A6      1113       setb SPEAKER ;Turn on speaker
0C51 D28E      1113       setb TR1 ;Start playback by enabling Timer1
0C53           1114       ;check power on
0C53 12057D    1115       lcall CHECK_POWER
0C56 120952    1116       lcall Average_Temp
0C59           1117       
0C59           1118       
0C59           1119       ;Update Time and Temp
0C59 1206FC    1120       lcall Update_Display
0C5C           1121       
0C5C E53B      1122       mov a, Temp_oven           
0C5E 9536      1123       subb a, Temp_refl
0C60 5004      1124       jnc state3_done    ; if greater, jump to state 4
0C62 6002      1125       jz state3_done ; if equal to, jump to state 4
0C64 40BF      1126       jc state3 ; if less than, go back to state3
0C66           1127       
0C66           1128       ;jb NEXT_STATE_BUTTON, state3
0C66           1129       ;Wait_Milli_Seconds(#50) ; debounce time
0C66           1130            ;jb NEXT_STATE_BUTTON, state3 ; if button not pressed, loop
0C66           1131            ;jnb NEXT_STATE_BUTTON, $
0C66           1132   
0C66           1133   state3_done:
0C66 753A04    1134       mov State_time, #4
0C69           1135   
0C69           1136   ; reflow 
0C69           1137   state4_beginning:
0C69           1138       
0C69 753A00    1139       mov State_time, #0;x00 clear the state time
0C6C           1140       ;***clear the screen and set new display***
0C6C 12067D    1141       lcall Initialize_State_Display
0C6F C0E0      1142            push acc
0C71 7407      1142            mov a, #7
0C73 14        1142            dec a
0C74 1200BD    1142            lcall ?Set_Cursor_2 ; Select column and row
0C77 D0E0      1142            pop acc
0C79 C083      1143            push dph
0C7B C082      1143            push dpl
0C7D C0E0      1143            push acc
0C7F 900467    1143            mov dptr, #Reflow
0C82 1200B2    1143            lcall ?Send_Constant_String
0C85 D0E0      1143            pop acc
0C87 D082      1143            pop dpl
0C89 D083      1143            pop dph
0C8B           1144   
0C8B           1145       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
0C8B 754FC8    1146            mov pwm_ratio+0, #low(200)
0C8E 755000    1147            mov pwm_ratio+1, #high(000)
0C91           1148   
0C91           1149   
0C91           1150   state4:
0C91           1151       ; Produces REFLOW on speaker
0C91           1152       ; ***play audio***
0C91 C28E      1152       clr TR1 ; Stop Timer 1 ISR from playing previous request
0C93 D2A5      1152       setb FLASH_CE
0C95 C2A6      1152       clr SPEAKER ; Turn off speaker
0C97           1152       
0C97 C2A5      1152       clr FLASH_CE ; Enable SPI Flash
0C99 7403      1152       mov a, #READ_BYTES
0C9B 120494    1152       lcall Send_SPI
0C9E           1152       ; Set the initial position in memory where to start playing
0C9E           1152       
0C9E 7400      1152       mov a, #0x00 ; change initial position
0CA0 120494    1152       lcall Send_SPI
0CA3 74F0      1152       mov a, #0xf0 ; next memory position
0CA5 120494    1152       lcall Send_SPI
0CA8 7463      1152       mov a, #0x63 ; next memory position
0CAA 120494    1152       lcall Send_SPI
0CAD 7400      1152       mov a, #0x00 ; request first byte to send to DAC
0CAF 120494    1152       lcall Send_SPI
0CB2           1152       
0CB2           1152       ; How many bytes to play?
0CB2 754E00    1152       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0CB5 754D59    1152       mov w+1, #0x59 ; Load the middle byte of the number of bytes to play
0CB8 754CD8    1152       mov w+0, #0xd8 ; Load the low byte of the number of bytes to play
0CBB           1152       
0CBB           1152       
0CBB D2A6      1152       setb SPEAKER ;Turn on speaker
0CBD D28E      1152       setb TR1 ;Start playback by enabling Timer1
0CBF           1153       ;check power on
0CBF 12057D    1154       lcall CHECK_POWER
0CC2           1155       ;Update Time and Temp
0CC2 1206FC    1156       lcall Update_Display
0CC5 120952    1157       lcall Average_Temp
0CC8           1158       
0CC8           1159       ; loop back to state2 if run time is less than soak time
0CC8 E53A      1160       mov a, State_time
0CCA 9537      1161       subb a, Time_refl
0CCC 5002      1162       jnc state4_done
0CCE 40C1      1163       jc state4
0CD0           1164   
0CD0           1165       ;*Checking moving to states with buttons---- 
0CD0           1166   ;*Will remove after proper temperature reading----
0CD0           1167   
0CD0           1168       ;jb NEXT_STATE_BUTTON, state4
0CD0           1169       ;Wait_Milli_Seconds(#50) ; debounce time
0CD0           1170            ;jb NEXT_STATE_BUTTON, state4 ; if button not pressed, loop
0CD0           1171            ;jnb NEXT_STATE_BUTTON, $ 
0CD0           1172   
0CD0           1173   state4_done: 
0CD0 753A00    1174       mov State_time, #0
0CD3 020CD6    1175       ljmp state5_beginning 
0CD6           1176   
0CD6           1177   
0CD6           1178   ; cooling
0CD6           1179   state5_beginning: ; turn oven off
0CD6 C287      1180       clr OVEN_POWER
0CD8           1181   
0CD8           1182   ;***clear the screen and set new display***
0CD8 12067D    1183       lcall Initialize_State_Display
0CDB C083      1184            push dph
0CDD C082      1184            push dpl
0CDF C0E0      1184            push acc
0CE1 90046E    1184            mov dptr, #Cooling
0CE4 1200B2    1184            lcall ?Send_Constant_String
0CE7 D0E0      1184            pop acc
0CE9 D082      1184            pop dpl
0CEB D083      1184            pop dph
0CED           1185   
0CED           1186       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0CED 754F00    1187            mov pwm_ratio+0, #low(0)
0CF0 755000    1188            mov pwm_ratio+1, #high(0)
0CF3           1189   
0CF3           1190   state5:
0CF3           1191       ;check power on
0CF3 12057D    1192       lcall CHECK_POWER
0CF6           1193       
0CF6           1194       ; update display
0CF6 1206FC    1195       lcall Update_Display
0CF9 120952    1196       lcall Average_Temp
0CFC           1197   
0CFC E53B      1198       mov a, Temp_oven
0CFE 943C      1199       subb a, #60
0D00 50F1      1200       JNC state5    ; if greater, jump back to state 5
0D02 60EF      1201       JZ state5 ; if equal to, go back to state5
0D04 4000      1202       JC state5_done ; if less than, go back to state 0
0D06           1203   
0D06           1204       ;*Checking moving to states with buttons---- 
0D06           1205   ;*Will remove after proper temperature reading----
0D06           1206   
0D06           1207       ;jb NEXT_STATE_BUTTON, state5
0D06           1208       ;Wait_Milli_Seconds(#50) ; debounce time
0D06           1209            ;jb NEXT_STATE_BUTTON, state5 ; if button not pressed, loop
0D06           1210            ;jnb NEXT_STATE_BUTTON, $ 
0D06           1211   
0D06           1212   state5_done:
0D06 753A00    1213       mov State_time, #0
0D09 753300    1214       mov States, #0
0D0C 020AC0    1215       ljmp main
0D0F           1216   
0D0F           1217   EN
