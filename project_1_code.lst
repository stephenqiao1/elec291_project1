                  2   $LIST
0000              4   
0000              5   
0000              6   ;-------------------------------------------------------------------------------------------------------------------------------
0000              7   ;These EQU must match the wiring between the microcontroller and ADC
0000              8   CLK  EQU 22118400
0000              9   TIMER1_RATE    EQU 35000 ;22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             10   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             11   BAUD equ 115200
0000             12   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000             13   
0000             14   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             15   TIMER2_RELOAD EQU (65536-(CLK/TIMER2_RATE))
0000             16   
0000             17   ;shjfjdfs
0000             18   ;-------------------------------------------------------------------------------------------------------------------------------
0000             19   ;Button Pin Mapping
0000             20   NEXT_STATE_BUTTON  equ P0.5
0000             21   STIME_BUTTON    equ P0.2
0000             22   STEMP_BUTTON    equ P0.3
0000             23   RTIME_BUTTON    equ P0.4
0000             24   RTEMP_BUTTON    equ P0.6
0000             25   
0000             26   POWER_BUTTON    equ P4.5
0000             27   SHIFT_BUTTON    equ p0.4
0000             28   
0000             29   ;Output Pins
0000             30   OVEN_POWER      equ P0.7
0000             31   SPEAKER         equ P2.6
0000             32   
0000             33   PWM_OUTPUT    equ P1.0 ; Attach an LED (with 1k resistor in series) to P1.0
0000             34   
0000             35   
0000             36   ;FLASH pins
0000             37   MY_MOSI_SOUND EQU P2.4
0000             38   MY_MISO_SOUND EQU P2.1
0000             39   MY_SCLK_SOUND EQU P2.0
0000             40   FLASH_CE        equ P2.5
0000             41   
0000             42   ;Thermowire Pins
0000             43   CE_ADC    EQU  P1.7
0000             44   MY_MOSI   EQU  P1.6
0000             45   MY_MISO   EQU  P1.5
0000             46   MY_SCLK   EQU  P1.4 
0000             47   
0000             48   ; Commands supported by the SPI flash memory according to the datasheet
0000             49   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             50   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             51   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             52   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             53   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             54   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             55   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             56   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             57   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             58   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             59   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             60   
0000             61   ; These 'equ' must match the hardware wiring
0000             62   LCD_RS equ P3.2
0000             63   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
0000             64   LCD_E  equ P3.3
0000             65   LCD_D4 equ P3.4
0000             66   LCD_D5 equ P3.5
0000             67   LCD_D6 equ P3.6
0000             68   LCD_D7 equ P3.7
0000             69   
0000             70   ;-------------------------------------------------------------------------------------------------------------------------------
0000             71   
0000             72   org 0x0000
0000 0209EA      73       ljmp main
0003             74   
0003             75   ; External interrupt 0 vector (not used in this code)
0003             76   org 0x0003
0003 32          77            reti
0004             78   
0004             79   ; Timer/Counter 0 overflow interrupt vector
000B             80   org 0x000B
000B 32          81            reti
000C             82   
000C             83   ; External interrupt 1 vector (not used in this code)
0013             84   org 0x0013
0013 32          85            reti
0014             86   
0014             87   ; Timer/Counter 1 overflow interrupt vector
001B             88   org 0x001B
001B 020939      89            ljmp Timer1_ISR
001E             90   
001E             91   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             92   org 0x0023 
0023 32          93            reti
0024             94            
0024             95   ; Timer/Counter 2 overflow interrupt vector
002B             96   org 0x002B
002B 02098F      97       ljmp Timer2_ISR
002E             98   ;-------------------------------------------------------------------------------------------------------------------------------
002E             99   ; Place our variables here
0030            100   DSEG at 0x30 ; Before the state machine!
0030            101   Count1ms:         ds 2 ; Used to determine when one second has passed
0032            102   Count5sec:        ds 1
0033            103   States:           ds 1
0034            104   Temp_soak:        ds 1
0035            105   Time_soak:        ds 1
0036            106   Temp_refl:        ds 1
0037            107   Time_refl:        ds 1
0038            108   Run_time_seconds: ds 1
0039            109   Run_time_minutes: ds 1
003A            110   State_time:       ds 1
003B            111   Temp_oven:        ds 1
003C            112   x:                ds 4
0040            113   y:                ds 4
0044            114   bcd:              ds 5
0049            115   Result:           ds 2
004B            116   w:                ds 3
004E            117   pwm_ratio:        ds 2
0050            118   average_count:    ds 1
0051            119   
                121   $LIST
00F0            123   
                546   $LIST
                125   $LIST
0360            127   
                129   $LIST
03E7            131   
0000            132   bseg
0000            133   one_seconds_flag:  dbit 1
0001            134   five_seconds_flag: dbit 1
0002            135   enable_clk:        dbit 1
0003            136   mf:                dbit 1
0004            137   
03E7            138   cseg
03E7            139   
03E7            140   ;-------------------------------------------------------------------------------------------------------------------------------
03E7            141   ;***Messages To Display*** 
03E7            142   
03E7            143   ;shortened labels
03E7 53546D70   144   STemp:  db 'STmp:', 0
     3A00
03ED 53546D3A   145   STime:  db 'STm:', 0
     00
03F2 52546D70   146   RTemp:  db 'RTmp:', 0
     3A00
03F8 52546D3A   147   RTime:  db 'RTm:', 0
     00
03FD            148   
03FD            149   ;lables for runnning oven
03FD 53746174   150   state:     db 'State>' , 0
     653E00
0404 546D653E   151   time:      db 'Tme>' , 0
     00
0409 3A00       152   colon:     db ':', 0
040B 546D703E   153   temp:      db 'Tmp>', 0
     00
0410            154   
0410            155   ;labels for changin parameters
0410 5265666C   156   ReflowTemp:  db 'Reflow Temperature:', 0
     6F772054
     656D7065
     72617475
     72653A00
0424 5265666C   157   ReflowTime:  db 'Reflow Time:', 0
     6F772054
     696D653A
     00
0431 536F616B   158   SoakTime:    db 'Soak Time:', 0
     2054696D
     653A00
043C 536F616B   159   SoakTemp:    db 'Soak Temperature:', 0
     2054656D
     70657261
     74757265
     3A00
044E            160   
044E            161   
044E            162   ;Current State in Oven
044E 52616D70   163   Ramp2Soak: db 'Ramp-Soak' , 0
     2D536F61
     6B00
0458 536F616B   164   Soak:      db 'Soak' , 0
     00
045D 52616D70   165   Ramp2Peak: db 'Ramp-Peak' , 0
     2D506561
     6B00
0467 5265666C   166   Reflow:    db 'Reflow' , 0
     6F7700
046E 436F6F6C   167   Cooling:   db 'Cooling' , 0
     696E6700
0476            168   
0476            169   ;-------------------------------------------------------------------------------------------------------------------------------
0476            170   ;FXNS FOR THERMOWIRE
0476            171   
0476            172   ;initialize SPI 
0476            173   INI_SPI:
0476 D295       174            setb MY_MISO          ; Make MISO an input pin
0478 C294       175            clr MY_SCLK           ; Mode 0,0 default
047A 22         176            ret
047B            177   DO_SPI_G:
047B C0E0       178            push acc
047D 7900       179            mov R1, #0            ; Received byte stored in R1
047F 7A08       180            mov R2, #8            ; Loop counter (8-bits)
0481            181   DO_SPI_G_LOOP:
0481 E8         182            mov a, R0             ; Byte to write is in R0
0482 33         183            rlc a                 ; Carry flag has bit to write
0483 F8         184            mov R0, a
0484 9296       185            mov MY_MOSI, c
0486 D294       186            setb MY_SCLK          ; Transmit
0488 A295       187            mov c, MY_MISO        ; Read received bit
048A E9         188            mov a, R1             ; Save received bit in R1
048B 33         189            rlc a
048C F9         190            mov R1, a
048D C294       191            clr MY_SCLK
048F DAF0       192            djnz R2, DO_SPI_G_LOOP
0491 D0E0       193            pop acc
0493 22         194   ret
0494            195   
0494            196   Send_SPI:
                197   	SPIBIT MAC
                198   	    ; Send/Receive bit %0
                199   		rlc a
                200   		mov MY_MOSI_SOUND, c
                201   		setb MY_SCLK_SOUND
                202   		mov c, MY_MISO_SOUND
                203   		clr MY_SCLK_SOUND
                204   		mov acc.0, c
                205   	ENDMAC
0494            206            
0494            207                ; Send/Receive bit 7
0494 33         207                    rlc a
0495 92A4       207                    mov MY_MOSI_SOUND, c
0497 D2A0       207                    setb MY_SCLK_SOUND
0499 A2A1       207                    mov c, MY_MISO_SOUND
049B C2A0       207                    clr MY_SCLK_SOUND
049D 92E0       207                    mov acc.0, c
049F            208                ; Send/Receive bit 6
049F 33         208                    rlc a
04A0 92A4       208                    mov MY_MOSI_SOUND, c
04A2 D2A0       208                    setb MY_SCLK_SOUND
04A4 A2A1       208                    mov c, MY_MISO_SOUND
04A6 C2A0       208                    clr MY_SCLK_SOUND
04A8 92E0       208                    mov acc.0, c
04AA            209                ; Send/Receive bit 5
04AA 33         209                    rlc a
04AB 92A4       209                    mov MY_MOSI_SOUND, c
04AD D2A0       209                    setb MY_SCLK_SOUND
04AF A2A1       209                    mov c, MY_MISO_SOUND
04B1 C2A0       209                    clr MY_SCLK_SOUND
04B3 92E0       209                    mov acc.0, c
04B5            210                ; Send/Receive bit 4
04B5 33         210                    rlc a
04B6 92A4       210                    mov MY_MOSI_SOUND, c
04B8 D2A0       210                    setb MY_SCLK_SOUND
04BA A2A1       210                    mov c, MY_MISO_SOUND
04BC C2A0       210                    clr MY_SCLK_SOUND
04BE 92E0       210                    mov acc.0, c
04C0            211                ; Send/Receive bit 3
04C0 33         211                    rlc a
04C1 92A4       211                    mov MY_MOSI_SOUND, c
04C3 D2A0       211                    setb MY_SCLK_SOUND
04C5 A2A1       211                    mov c, MY_MISO_SOUND
04C7 C2A0       211                    clr MY_SCLK_SOUND
04C9 92E0       211                    mov acc.0, c
04CB            212                ; Send/Receive bit 2
04CB 33         212                    rlc a
04CC 92A4       212                    mov MY_MOSI_SOUND, c
04CE D2A0       212                    setb MY_SCLK_SOUND
04D0 A2A1       212                    mov c, MY_MISO_SOUND
04D2 C2A0       212                    clr MY_SCLK_SOUND
04D4 92E0       212                    mov acc.0, c
04D6            213                ; Send/Receive bit 1
04D6 33         213                    rlc a
04D7 92A4       213                    mov MY_MOSI_SOUND, c
04D9 D2A0       213                    setb MY_SCLK_SOUND
04DB A2A1       213                    mov c, MY_MISO_SOUND
04DD C2A0       213                    clr MY_SCLK_SOUND
04DF 92E0       213                    mov acc.0, c
04E1            214                ; Send/Receive bit 0
04E1 33         214                    rlc a
04E2 92A4       214                    mov MY_MOSI_SOUND, c
04E4 D2A0       214                    setb MY_SCLK_SOUND
04E6 A2A1       214                    mov c, MY_MISO_SOUND
04E8 C2A0       214                    clr MY_SCLK_SOUND
04EA 92E0       214                    mov acc.0, c
04EC            215   
04EC 22         216   ret
04ED            217   
                218   Change_8bit_Variable MAC
                219       jb %0, %2
                220       Wait_Milli_Seconds(#50) ; de-bounce
                221       jb %0, %2
                222       jnb %0, $
                223       jb SHIFT_BUTTON, skip%Mb
                224       dec %1
                225       sjmp skip%Ma
                226       skip%Mb:
                227       inc %1
                228       skip%Ma:
                229   ENDMAC
04ED            230   
04ED            231   ;Change_8bit_Variable(MY_VARIABLE_BUTTON, my_variable, loop_c)
04ED            232   ;    Set_Cursor(2, 14)
04ED            233   ;    mov a, my_variable
04ED            234   ;    lcall SendToLCD
04ED            235   ;lcall Save_Configuration
04ED            236   
04ED            237   ;-------------------------------------------------------------------------------------------------------------------------------
04ED            238   ;***FXNS For Serial Port
04ED            239   
04ED            240   ; Configure the serial port and baud rate
04ED            241   InitSerialPort:
04ED            242       ; Since the reset button bounces, we need to wait a bit before
04ED            243       ; sending messages, otherwise we risk displaying gibberish!
04ED 79DE       244       mov R1, #222
04EF 78A6       245       mov R0, #166
04F1 D8FE       246       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
04F3 D9FA       247       djnz R1, $-4 ; 22.51519us*222=4.998ms
04F5            248       ; Now we can proceed with the configuration
04F5 438780     249            orl     PCON,#0x80
04F8 759852     250            mov     SCON,#0x52
04FB 759B00     251            mov     BDRCON,#0x00
04FE 759AF4     252            mov     BRL,#BRG_VAL
0501 759B1E     253            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0504 22         254   ret
0505            255   
0505            256   
0505            257   putchar:
0505 3099FD     258       jnb TI, putchar
0508 C299       259       clr TI
050A F599       260       mov SBUF, a
050C 22         261   ret
050D            262   
050D            263   ;-------------------------------------------------------------------------------------------------------------------------------
050D            264   ;***FXNS to CHECK BUTTONS
050D            265   
050D            266   CHECK_STIME:
050D            267   
050D 208218     268       jb STIME_BUTTON, CHECK_STIME_END
0510 C002       268            push AR2
0512 7A32       268            mov R2, #50
0514 120039     268            lcall ?Wait_Milli_Seconds
0517 D002       268            pop AR2 ; de-bounce
0519 20820C     268       jb STIME_BUTTON, CHECK_STIME_END
051C 3082FD     268       jnb STIME_BUTTON, $
051F 208404     268       jb SHIFT_BUTTON, skip16b
0522 1535       268       dec Time_soak
0524 8002       268       sjmp skip16a
0526            268       skip16b:
0526 0535       268       inc Time_soak
0528            268       skip16a:
0528            269            
0528            270   CHECK_STIME_END:
0528 22         271   ret
0529            272   
0529            273   CHECK_STEMP:
0529 208318     274       jb STEMP_BUTTON, CHECK_STEMP_END
052C C002       274            push AR2
052E 7A32       274            mov R2, #50
0530 120039     274            lcall ?Wait_Milli_Seconds
0533 D002       274            pop AR2 ; de-bounce
0535 20830C     274       jb STEMP_BUTTON, CHECK_STEMP_END
0538 3083FD     274       jnb STEMP_BUTTON, $
053B 208404     274       jb SHIFT_BUTTON, skip18b
053E 1534       274       dec Temp_soak
0540 8002       274       sjmp skip18a
0542            274       skip18b:
0542 0534       274       inc Temp_soak
0544            274       skip18a:
0544            275       ;lcall Save_Configuration
0544            276            
0544            277   CHECK_STEMP_END:
0544 22         278   ret
0545            279   
0545            280   CHECK_RTIME:
0545 208418     281       jb RTIME_BUTTON, CHECK_RTIME_END
0548 C002       281            push AR2
054A 7A32       281            mov R2, #50
054C 120039     281            lcall ?Wait_Milli_Seconds
054F D002       281            pop AR2 ; de-bounce
0551 20840C     281       jb RTIME_BUTTON, CHECK_RTIME_END
0554 3084FD     281       jnb RTIME_BUTTON, $
0557 208404     281       jb SHIFT_BUTTON, skip20b
055A 1537       281       dec Time_refl
055C 8002       281       sjmp skip20a
055E            281       skip20b:
055E 0537       281       inc Time_refl
0560            281       skip20a:
0560            282   CHECK_RTIME_END:
0560 22         283   ret
0561            284   
0561            285   CHECK_RTEMP:
0561 208618     286       jb RTEMP_BUTTON, CHECK_RTEMP_END
0564 C002       286            push AR2
0566 7A32       286            mov R2, #50
0568 120039     286            lcall ?Wait_Milli_Seconds
056B D002       286            pop AR2 ; de-bounce
056D 20860C     286       jb RTEMP_BUTTON, CHECK_RTEMP_END
0570 3086FD     286       jnb RTEMP_BUTTON, $
0573 208404     286       jb SHIFT_BUTTON, skip22b
0576 1536       286       dec Temp_refl
0578 8002       286       sjmp skip22a
057A            286       skip22b:
057A 0536       286       inc Temp_refl
057C            286       skip22a:
057C            287   CHECK_RTEMP_END:
057C 22         288   ret
057D            289   
057D            290   CHECK_POWER:
057D            291   
057D 20C518     292       jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
0580 C002       293            push AR2
0582 7A32       293            mov R2, #50
0584 120039     293            lcall ?Wait_Milli_Seconds
0587 D002       293            pop AR2 ; debounce time
0589 20C50C     294            jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
058C 30C5FD     295            jnb POWER_BUTTON, $ ; loop while the button is pressed
058F 754E00     296       mov pwm_ratio+0, #low(0)
0592 754F00     297            mov pwm_ratio+1, #high(0)
0595 120847     298       lcall OFF_STATE
0598            299   
0598            300   CHECK_POWER_END:
0598 22         301   ret
0599            302   ;**SOUND STUFF---------------------------------------------------------------
0599            303   
0599            304   SOUND_FSM:
0599            305   state_0_sound:
0599            306   ;check if 5 seconds has passed, if yes go to state 1, if no exit function 
0599 300105     307       jnb five_seconds_flag, Sound_ret
059C C201       308       clr five_seconds_flag
059E 0205A2     309       ljmp state_1_sound
05A1            310   Sound_ret:
05A1 22         311       ret
05A2            312   
05A2            313   state_1_sound:
05A2            314   ; check if temp is greater than 100, if yes go to state 2
05A2            315   ; check if temp is less than 100, if yes go to state 4
05A2 E53B       316       mov a, Temp_oven
05A4 9464       317       subb a, #100
05A6 5002       318       jnc state_2_sound
05A8 4023       319       jc state_4_sound
05AA            320   
05AA            321   state_2_sound:
05AA            322   ;divide temp by 100, if it is 1 play sound: "100", if it is 2 play sound: "200"
05AA            323   ; go to state_3_sound
05AA 75F064     324       mov b, #100
05AD E53B       325       mov a, Temp_oven
05AF 84         326       div ab
05B0 9401       327       subb a, #1
05B2 600A       328       jz play_sound_1
05B4            329   
05B4 75F064     330       mov b, #100
05B7 E53B       331       mov a, Temp_oven
05B9 84         332       div ab
05BA 9402       333       subb a, #2
05BC 6000       334       jz play_sound_1
05BE            335      
05BE            336      play_sound_1: 
05BE            337       ;ljmp PLAYBACK_TEMP
05BE            338   
05BE 0205C1     339       ljmp state_3_sound
05C1            340   
05C1            341   
05C1            342   state_3_sound:
05C1            343   ; check remainder of temp, if it is 0, go back to state_0_sound
05C1            344   ; if not 0, go to state_4_sound
05C1            345   
05C1 75F064     346       mov b, #100
05C4 E53B       347       mov a, Temp_oven
05C6 84         348       div ab
05C7 E5F0       349       mov a, b
05C9 60CE       350       jz state_0_sound
05CB 7000       351       jnz state_4_sound
05CD            352   
05CD            353   state_4_sound:
05CD            354   ; if T % 100 greater or equal to 20, go to state_5_sound,
05CD 75F064     355       mov b, #100
05D0 E53B       356       mov a, Temp_oven
05D2 84         357       div ab
05D3 E5F0       358       mov a, b 
05D5 9414       359       subb a, #20
05D7 5011       360       jnc state_5_sound
05D9 E4         361       clr a
05DA            362   ; if T % 100 is less than 10, go to state_6_sound
05DA 75F064     363       mov b, #100
05DD E53B       364       mov a, Temp_oven
05DF 84         365       div ab
05E0 E5F0       366       mov a, b
05E2 940A       367       subb a, #10
05E4 4019       368       jc state_6_sound
05E6 E4         369       clr a
05E7            370   ; if T % 100 is greater than 10 and less than 20, go to state_7_sound
05E7 020602     371       ljmp state_7_sound
05EA            372       
05EA            373   
05EA            374   state_5_sound:
05EA            375   ; play number from 20 to 90 in decades (20, 30, 40, 50, 60, 70, 80, 90), based off remainder from temp divided by 100
05EA            376   ; if (T % 100) % 10 is not equal to 0, go to state_6_sound
05EA            377   ; if (T % 100) % 10 is equal to 0, go to state_8_sound
05EA            378   
05EA E53B       379       mov a, Temp_oven
05EC 75F064     380       mov b, #100 
05EF 84         381       div ab
05F0 E5F0       382       mov a, b
05F2 75F00A     383       mov b, #10
05F5 84         384       div ab
05F6 E5F0       385       mov a, b
05F8 6002       386       jz play_sound
05FA 7003       387       jnz state_6_sound
05FC            388       
05FC            389   
05FC            390       play_sound:
05FC            391           ;ljmp PLAYBACK_TEMP
05FC 020605     392           ljmp state_8_sound
05FF            393   
05FF            394   
05FF            395   state_6_sound:
05FF            396   ; play 1 - 9
05FF            397       ;ljmp PLAYBACK_TEMP
05FF            398   ; go to state_8_sound
05FF 020605     399       ljmp state_8_sound
0602            400   
0602            401   
0602            402   state_7_sound:
0602            403   ; play 10 - 19
0602            404       ;ljmp PLAYBACK_TEMP
0602            405   ; go to state_8_sound 
0602 020605     406       ljmp state_8_sound
0605            407   
0605            408   state_8_sound:
0605            409   ; go to state_0_sound
0605 020599     410       ljmp state_0_sound
0608            411   
0608            412   
0608            413   INI_PLAYBACK_TEMP:
0608            414       ; ****INITIALIZATION****
0608            415       ; Configure SPI pins and turn off speaker
0608            416            ;anl P2M0, #0b_1100_1110
0608 43CE90     417       orl P2M0, #0b_1001_0000
060B            418       ;orl P2M0, #0b_0011_0001
060B            419            ;orl P2M1, #0b_0011_0001
060B 43CF90     420       orl P2M1, #0b_1001_0000
060E D2A1       421            setb MY_MISO_SOUND  ; Configured as input
0610 D2A5       422            setb FLASH_CE ; CS=1 for SPI flash memory
0612 C2A0       423            clr MY_SCLK_SOUND   ; Rest state of SCLK=0
0614 C2A6       424            clr SPEAKER   ; Turn off speaker.
0616            425            
0616            426            ; Configure timer 1
0616 53890F     427            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
0619 438910     428            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
061C 758DFD     429            mov TH1, #high(TIMER1_RELOAD)
061F 758B89     430            mov TL1, #low(TIMER1_RELOAD)
0622            431            ; Set autoreload value
0622 75F5FD     432            mov RH1, #high(TIMER1_RELOAD)
0625 75F389     433            mov RL1, #low(TIMER1_RELOAD)
0628            434   
0628            435            ;Enable the timer and interrupts
0628 D2AB       436       setb ET1  ; Enable timer 1 interrupt
062A D28E       437            setb TR1 ; Timer 1 is only enabled to play stored sound
062C            438   
062C            439            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
062C 75A5A0     440            mov DADI, #0b_1010_0000 ; ACON=1
062F 75A43A     441            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0632 75AD80     442            mov DADH, #0x80 ; Middle of scale
0635 75AC00     443            mov DADL, #0
0638 43A440     444            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
063B            445       check_DAC_init:
063B E5A4       446            mov a, DADC
063D 20E6FB     447            jb acc.6, check_DAC_init ; Wait for DAC to finish
0640            448            
0640 22         449   ret
0641            450   
                451   PLAYBACK_TEMP MAC
                452       ; ***play audio***
                453       clr TR1 ; Stop Timer 1 ISR from playing previous request
                454       setb FLASH_CE
                455       clr SPEAKER ; Turn off speaker
                456       
                457       clr FLASH_CE ; Enable SPI Flash
                458       mov a, #READ_BYTES
                459       lcall Send_SPI
                460       ; Set the initial position in memory where to start playing
                461       
                462       mov a, %0 ; change initial position
                463       lcall Send_SPI
                464       mov a, %1 ; next memory position
                465       lcall Send_SPI
                466       mov a, %2 ; next memory position
                467       lcall Send_SPI
                468       mov a, %0 ; request first byte to send to DAC
                469       lcall Send_SPI
                470       
                471       ; How many bytes to play?
                472       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
                473       mov w+1, %3 ; Load the middle byte of the number of bytes to play
                474       mov w+0, %4 ; Load the low byte of the number of bytes to play
                475       
                476       
                477       setb SPEAKER ;Turn on speaker
                478       setb TR1 ;Start playback by enabling Timer1
                479   ENDMAC
0641            480       
0641            481   ;-------------------------------------------------------------------------------------------------------------------------------
0641            482   ;***LCD FXNS
0641            483   
                484   Display_lower_BCD mac
                485       push ar0
                486       mov r0, %0
                487       lcall ?Display_lower_BCD
                488       pop ar0
                489   endmac
0641            490   
0641            491   ?Display_lower_BCD:
0641 C0E0       492       push acc
0643            493       ; write least significant digit
0643 E8         494       mov a, r0
0644 540F       495       anl a, #0fh
0646 4430       496       orl a, #30h
0648 12007E     497       lcall ?WriteData
064B D0E0       498       pop acc
064D 22         499   ret
064E            500   
064E            501   
064E            502   SendToLCD:
064E 75F064     503       mov b, #100
0651 84         504       div ab
0652 4430       505       orl a, #0x30h ; Convert hundreds to ASCII
0654 12007E     506       lcall ?WriteData ; Send to LCD
0657 E5F0       507       mov a, b    ; Remainder is in register b
0659 75F00A     508       mov b, #10
065C 84         509       div ab
065D 4430       510       orl a, #0x30h ; Convert tens to ASCII
065F 12007E     511       lcall ?WriteData; Send to LCD
0662 E5F0       512       mov a, b
0664 4430       513       orl a, #0x30h ; Convert units to ASCII
0666 12007E     514       lcall ?WriteData; Send to LCD
0669 22         515   ret
066A            516   
066A            517   Initialize_State_Display:
066A            518   
066A            519       ;***clear the screen and set new display***
066A 7401       520            mov a, #0x01
066C 120083     520            lcall ?WriteCommand
066F C002       521            push AR2
0671 7A02       521            mov R2, #2
0673 120039     521            lcall ?Wait_Milli_Seconds
0676 D002       521            pop AR2
0678            522       
0678 C0E0       523            push acc
067A 7401       523            mov a, #1
067C 14         523            dec a
067D 1200BF     523            lcall ?Set_Cursor_1 ; Select column and row
0680 D0E0       523            pop acc
0682 C083       524            push dph
0684 C082       524            push dpl
0686 C0E0       524            push acc
0688 900404     524            mov dptr, #time
068B 1200B2     524            lcall ?Send_Constant_String
068E D0E0       524            pop acc
0690 D082       524            pop dpl
0692 D083       524            pop dph
0694            525            
0694 C0E0       526            push acc
0696 7406       526            mov a, #6
0698 14         526            dec a
0699 1200BF     526            lcall ?Set_Cursor_1 ; Select column and row
069C D0E0       526            pop acc
069E C083       527            push dph
06A0 C082       527            push dpl
06A2 C0E0       527            push acc
06A4 900409     527            mov dptr, #colon
06A7 1200B2     527            lcall ?Send_Constant_String
06AA D0E0       527            pop acc
06AC D082       527            pop dpl
06AE D083       527            pop dph
06B0            528      
06B0 C0E0       529            push acc
06B2 740A       529            mov a, #10
06B4 14         529            dec a
06B5 1200BF     529            lcall ?Set_Cursor_1 ; Select column and row
06B8 D0E0       529            pop acc
06BA C083       530            push dph
06BC C082       530            push dpl
06BE C0E0       530            push acc
06C0 90040B     530            mov dptr, #temp
06C3 1200B2     530            lcall ?Send_Constant_String
06C6 D0E0       530            pop acc
06C8 D082       530            pop dpl
06CA D083       530            pop dph
06CC            531       
06CC C0E0       532            push acc
06CE 7401       532            mov a, #1
06D0 14         532            dec a
06D1 1200BD     532            lcall ?Set_Cursor_2 ; Select column and row
06D4 D0E0       532            pop acc
06D6 C083       533            push dph
06D8 C082       533            push dpl
06DA C0E0       533            push acc
06DC 9003FD     533            mov dptr, #state
06DF 1200B2     533            lcall ?Send_Constant_String
06E2 D0E0       533            pop acc
06E4 D082       533            pop dpl
06E6 D083       533            pop dph
06E8 22         534   ret
06E9            535   
06E9            536   Update_Display:
06E9 C0E0       537            push acc
06EB 7405       537            mov a, #5
06ED 14         537            dec a
06EE 1200BF     537            lcall ?Set_Cursor_1 ; Select column and row
06F1 D0E0       537            pop acc
06F3 C000       538       push ar0
06F5 A839       538       mov r0, Run_time_minutes
06F7 120641     538       lcall ?Display_lower_BCD
06FA D000       538       pop ar0
06FC C0E0       539            push acc
06FE 7407       539            mov a, #7
0700 14         539            dec a
0701 1200BF     539            lcall ?Set_Cursor_1 ; Select column and row
0704 D0E0       539            pop acc
0706 C000       540            push ar0
0708 A838       540            mov r0, Run_time_seconds
070A 1200C4     540            lcall ?Display_BCD
070D D000       540            pop ar0
070F            541       ;Set_Cursor(1,14)
070F            542       ;mov a, Temp_oven
070F            543       ;SendToLCD(Temp_oven)
070F 22         544   ret
0710            545   
0710            546   State0_display:
0710 C0E0       547            push acc
0712 7401       547            mov a, #1
0714 14         547            dec a
0715 1200BF     547            lcall ?Set_Cursor_1 ; Select column and row
0718 D0E0       547            pop acc
071A C083       548            push dph
071C C082       548            push dpl
071E C0E0       548            push acc
0720 9003E7     548            mov dptr, #STemp
0723 1200B2     548            lcall ?Send_Constant_String
0726 D0E0       548            pop acc
0728 D082       548            pop dpl
072A D083       548            pop dph
072C C0E0       549            push acc
072E 7406       549            mov a, #6
0730 14         549            dec a
0731 1200BF     549            lcall ?Set_Cursor_1 ; Select column and row
0734 D0E0       549            pop acc
0736 E534       550       mov a, Temp_soak
0738 12064E     551       lcall SendToLCD
073B            552       
073B C0E0       553            push acc
073D 740A       553            mov a, #10
073F 14         553            dec a
0740 1200BF     553            lcall ?Set_Cursor_1 ; Select column and row
0743 D0E0       553            pop acc
0745 C083       554            push dph
0747 C082       554            push dpl
0749 C0E0       554            push acc
074B 9003ED     554            mov dptr, #STime
074E 1200B2     554            lcall ?Send_Constant_String
0751 D0E0       554            pop acc
0753 D082       554            pop dpl
0755 D083       554            pop dph
0757 C0E0       555            push acc
0759 740E       555            mov a, #14
075B 14         555            dec a
075C 1200BF     555            lcall ?Set_Cursor_1 ; Select column and row
075F D0E0       555            pop acc
0761 E535       556       mov a, Time_soak
0763 12064E     557            lcall SendToLCD
0766            558       ;Display_BCD(Time_soak)
0766            559   
0766            560       ;Displays Reflow Temp and Time
0766 C0E0       561            push acc
0768 7401       561            mov a, #1
076A 14         561            dec a
076B 1200BD     561            lcall ?Set_Cursor_2 ; Select column and row
076E D0E0       561            pop acc
0770 C083       562            push dph
0772 C082       562            push dpl
0774 C0E0       562            push acc
0776 9003F2     562            mov dptr, #RTemp
0779 1200B2     562            lcall ?Send_Constant_String
077C D0E0       562            pop acc
077E D082       562            pop dpl
0780 D083       562            pop dph
0782 C0E0       563            push acc
0784 7406       563            mov a, #6
0786 14         563            dec a
0787 1200BD     563            lcall ?Set_Cursor_2 ; Select column and row
078A D0E0       563            pop acc
078C E536       564       mov a, Temp_refl
078E 12064E     565       lcall SendToLCD
0791            566       
0791 C0E0       567            push acc
0793 740A       567            mov a, #10
0795 14         567            dec a
0796 1200BD     567            lcall ?Set_Cursor_2 ; Select column and row
0799 D0E0       567            pop acc
079B C083       568            push dph
079D C082       568            push dpl
079F C0E0       568            push acc
07A1 9003F8     568            mov dptr, #RTime
07A4 1200B2     568            lcall ?Send_Constant_String
07A7 D0E0       568            pop acc
07A9 D082       568            pop dpl
07AB D083       568            pop dph
07AD C0E0       569            push acc
07AF 740E       569            mov a, #14
07B1 14         569            dec a
07B2 1200BD     569            lcall ?Set_Cursor_2 ; Select column and row
07B5 D0E0       569            pop acc
07B7 E537       570       mov a, Time_refl
07B9 12064E     571            lcall SendToLCD
07BC 22         572   ret
07BD            573   
07BD            574   Display_3_digit_BCD:
07BD C0E0       575            push acc
07BF 740E       575            mov a, #14
07C1 14         575            dec a
07C2 1200BF     575            lcall ?Set_Cursor_1 ; Select column and row
07C5 D0E0       575            pop acc
07C7 C000       576       push ar0
07C9 A845       576       mov r0, bcd+1
07CB 120641     576       lcall ?Display_lower_BCD
07CE D000       576       pop ar0
07D0 C000       577            push ar0
07D2 A844       577            mov r0, bcd+0
07D4 1200C4     577            lcall ?Display_BCD
07D7 D000       577            pop ar0
07D9 22         578   ret
07DA            579   
07DA            580   
07DA            581   ;The following functions store and restore the values--------------------------------------------------------------------------
                582   loadbyte mac
                583       mov a, %0
                584       movx @dptr, a
                585       inc dptr
                586   endmac
07DA            587   
07DA            588   Save_Configuration:
07DA C0A8       589       push IE ; Save the current state of bit EA in the stack
07DC C2AF       590       clr EA ; Disable interrupts
07DE 75D108     591       mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
07E1 907F80     592       mov dptr, #0x7f80 ; Last page of flash memory
07E4            593       ; Save variables
07E4 E534       594       mov a, temp_soak
07E6 F0         594       movx @dptr, a
07E7 A3         594       inc dptr ; @0x7f80
07E8 E535       595       mov a, time_soak
07EA F0         595       movx @dptr, a
07EB A3         595       inc dptr ; @0x7f81
07EC E536       596       mov a, temp_refl
07EE F0         596       movx @dptr, a
07EF A3         596       inc dptr ; @0x7f82
07F0 E537       597       mov a, time_refl
07F2 F0         597       movx @dptr, a
07F3 A3         597       inc dptr ; @0x7f83
07F4 7455       598       mov a, #0x55
07F6 F0         598       movx @dptr, a
07F7 A3         598       inc dptr ; First key value @0x7f84
07F8 74AA       599       mov a, #0xAA
07FA F0         599       movx @dptr, a
07FB A3         599       inc dptr ; Second key value @0x7f85
07FC 75D100     600       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0) 
07FF 43D240     601       orl EECON, #0b01000000 ; Enable auto-erase on next write sequence  
0802 75D150     602       mov FCON, #0x50 ; Write trigger first byte
0805 75D1A0     603       mov FCON, #0xA0 ; Write trigger second byte
0808            604       ; CPU idles until writing of flash completes.
0808 75D100     605       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
080B 53D2BF     606       anl EECON, #0b10111111 ; Disable auto-erase
080E D0A8       607       pop IE ; Restore the state of bit EA from the stack
0810 22         608   ret
0811            609   
                610   getbyte mac
                611       clr a
                612       movc a, @a+dptr
                613       mov %0, a
                614       inc dptr
                615   endmac
0811            616   
0811            617   Load_Configuration:
0811 907F84     618       mov dptr, #0x7f84 ; First key value location.
0814 E4         619       clr a
0815 93         619       movc a, @a+dptr
0816 F8         619       mov R0, a
0817 A3         619       inc dptr ; 0x7f84 should contain 0x55
0818 B8551F     620       cjne R0, #0x55, Load_Defaults
081B E4         621       clr a
081C 93         621       movc a, @a+dptr
081D F8         621       mov R0, a
081E A3         621       inc dptr ; 0x7f85 should contain 0xAA
081F B8AA18     622       cjne R0, #0xAA, Load_Defaults
0822            623   ; Keys are good.  Get stored values.
0822 907F80     624       mov dptr, #0x7f80
0825 E4         625       clr a
0826 93         625       movc a, @a+dptr
0827 F534       625       mov Temp_soak, a
0829 A3         625       inc dptr ; 0x7f80
082A E4         626       clr a
082B 93         626       movc a, @a+dptr
082C F535       626       mov Time_soak, a
082E A3         626       inc dptr ; 0x7f81
082F E4         627       clr a
0830 93         627       movc a, @a+dptr
0831 F536       627       mov Temp_refl, a
0833 A3         627       inc dptr ; 0x7f82
0834 E4         628       clr a
0835 93         628       movc a, @a+dptr
0836 F537       628       mov Time_refl, a
0838 A3         628       inc dptr ; 0x7f83
0839 22         629   ret
083A            630   
083A            631   Load_Defaults:
083A 753482     632       mov Temp_soak, #130 ; Soak Tmp Range is 130-170
083D 75353C     633       mov Time_soak, #0x3C ; Range 60-90 seconds
0840 7536DC     634       mov Temp_refl, #220 ; Range 220-240
0843 75371E     635       mov Time_refl, #0x1E ; Range 30-45 seconds
0846 22         636       ret 
0847            637   ;-------------------------------------------------------------------------------------------------------------------------------
0847            638   ;off state
0847            639   
0847            640   OFF_STATE:
0847            641       ;**CLEAR SCREEN**
0847 7401       642            mov a, #0x01
0849 120083     642            lcall ?WriteCommand
084C            643       ;OFF_STATE1:
084C            644       
084C 20C5FD     645       jb POWER_BUTTON, $ ; loop while the button is not pressed
084F C002       646            push AR2
0851 7A32       646            mov R2, #50
0853 120039     646            lcall ?Wait_Milli_Seconds
0856 D002       646            pop AR2 ; debounce time
0858 20C5EC     647            jb POWER_BUTTON, OFF_STATE ; it was a bounce, try again
085B 30C5FD     648            jnb POWER_BUTTON, $ ; loop while the button is pressed
085E 0209EA     649       ljmp main
0861 22         650   ret
0862            651   ;-------------------------------------------------------------------------------------------------------------------------------
0862            652   
0862            653   ;***CHECK TEMPERATURE BY READING VOLTAGE AND CONVERTING
0862            654   Check_Temp:
0862            655       
0862            656       ;jnb one_seconds_flag, Check_Temp_done
0862            657       ;clr one_seconds_flag
0862            658       
0862 C297       659       clr CE_ADC
0864 7801       660            mov R0, #00000001B ; Start bit:1
0866 12047B     661            lcall DO_SPI_G
0869 7880       662            mov R0, #10000000B ; Single ended, read channel 0
086B 12047B     663            lcall DO_SPI_G
086E E9         664            mov a, R1          ; R1 contains bits 8 and 9
086F 5403       665            anl a, #00000011B  ; We need only the two least significant bits
0871 F54A       666            mov Result+1, a    ; Save result high.
0873 7855       667            mov R0, #55H ; It doesn't matter what we transmit...
0875 12047B     668            lcall DO_SPI_G
0878 8949       669            mov Result+0, R1     ; R1 contains bits 0 to 7.  Save result low.
087A D297       670            setb CE_ADC
087C            671   
087C C002       672            push AR2
087E 7A0A       672            mov R2, #10
0880 120039     672            lcall ?Wait_Milli_Seconds
0883 D002       672            pop AR2
0885            673       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
0885 AE49       674            mov R6, Result+0
0887 AF4A       675            mov R7, Result+1
0889 22         676   ret
088A            677   
088A            678       ;Load_y(22)
088A            679       ;lcall add32
088A            680   
088A            681   ;Check_Temp_done_2:
088A            682       ;jnb one_seconds_flag, Check_Temp_done
088A            683       ;mov a, result+1
088A            684       ;Set_Cursor(1,14)
088A            685       ;lcall SendToLCD 
088A            686       ;Set_Cursor(1,14)
088A            687       ;mov a, x+0
088A            688       ;lcall SendToLCD
088A            689       ;mov Temp_oven, a
088A            690       
088A            691       ;mov a, States
088A            692       ;cjne a, #0, Display_Temp_BCD
088A            693       ;sjmp Send_Temp_Port
088A            694            
088A            695       ; The 4-bytes of x have the temperature in binary
088A            696   
088A            697       ;mov Temp_oven, x+0 ;save the temperature
088A            698   
088A            699   ;Display_Temp_BCD:
088A            700   ;        lcall hex2bcd ; converts binary in x to BCD in BCD
088A            701   
088A            702   ;    lcall Display_3_digit_BCD
088A            703   
088A            704   ;Send_Temp_Port:
088A            705   ;    Send_BCD(bcd+4)
088A            706   ;    Send_BCD(bcd+3)
088A            707   ;    Send_BCD(bcd+2)
088A            708   ;        Send_BCD(bcd+1)
088A            709   ;    Send_BCD(bcd+0);
088A            710   ;        mov a, #'\r'
088A            711   ;        lcall putchar
088A            712   ;        mov a, #'\n'
088A            713   ;        lcall putchar
088A            714   ;Check_Temp_done:
088A            715   ;ret
088A            716       
088A            717   ;***CALCULATES THE TEMPERATURE
088A            718   Average_Temp:
088A 753C00     719            mov x+0, #low (0 % 0x10000) 
088D 753D00     719            mov x+1, #high(0 % 0x10000) 
0890 753E00     719            mov x+2, #low (0 / 0x10000) 
0893 753F00     719            mov x+3, #high(0 / 0x10000) 
0896 7D64       720       mov R5, #100
0898            721   Ave_loop:
0898 120862     722       lcall Check_Temp
089B 754300     723       mov y+3, #0
089E 754200     724       mov y+2, #0
08A1 8F41       725       mov y+1, R7
08A3 8E40       726       mov y+0, R6
08A5 1201B5     727       lcall add32
08A8 120934     728       lcall Wait10us
08AB DDEB       729       djnz R5, Ave_loop
08AD 754064     730            mov y+0, #low (100 % 0x10000) 
08B0 754100     730            mov y+1, #high(100 % 0x10000) 
08B3 754200     730            mov y+2, #low (100 / 0x10000) 
08B6 754300     730            mov y+3, #high(100 / 0x10000) 
08B9 1202F7     731       lcall div32
08BC            732   
08BC            733       ;**INSERT MATH FUNCTIONS
08BC            734   
08BC 754000     735            mov y+0, #low (16384 % 0x10000) 
08BF 754140     735            mov y+1, #high(16384 % 0x10000) 
08C2 754200     735            mov y+2, #low (16384 / 0x10000) 
08C5 754300     735            mov y+3, #high(16384 / 0x10000)  ;6078; 2026
08C8 12026A     736            lcall mul32
08CB 7540AD     737            mov y+0, #low (84909 % 0x10000) 
08CE 75414B     737            mov y+1, #high(84909 % 0x10000) 
08D1 754201     737            mov y+2, #low (84909 / 0x10000) 
08D4 754300     737            mov y+3, #high(84909 / 0x10000)  ;14000; 7000
08D7 1202F7     738            lcall div32
08DA 754016     739            mov y+0, #low (22 % 0x10000) 
08DD 754100     739            mov y+1, #high(22 % 0x10000) 
08E0 754200     739            mov y+2, #low (22 / 0x10000) 
08E3 754300     739            mov y+3, #high(22 / 0x10000) 
08E6 1201B5     740       lcall add32
08E9 853C3B     741       mov Temp_oven, x+0
08EC            742   
08EC            743   Display_Temp_BCD:
08EC 1200F0     744            lcall hex2bcd ; converts binary in x to BCD in BCD
08EF            745   
08EF 1207BD     746       lcall Display_3_digit_BCD
08F2            747   
08F2            748   Send_Temp_Port:
08F2            749       ;Send_BCD(bcd+4)
08F2            750       ;Send_BCD(bcd+3)
08F2            751       ;Send_BCD(bcd+2)
08F2 C000       752       push ar0
08F4 A845       752       mov r0, bcd+1
08F6 1200DA     752       lcall ?Send_BCD
08F9 D000       752       pop ar0
08FB            752   
08FB C000       753       push ar0
08FD A844       753       mov r0, bcd+0
08FF 1200DA     753       lcall ?Send_BCD
0902 D000       753       pop ar0
0904            753   
0904 740D       754            mov a, #'\r'
0906 120505     755            lcall putchar
0909 740A       756            mov a, #'\n'
090B 120505     757            lcall putchar
090E            758   Check_Temp_done:
090E 22         759   ret    
090F            760   
090F            761   ;-------------------------------------------------------------------------------------------------------------------------------
090F            762   
090F            763   ;Time wait
090F            764   
090F            765   Wait_One_Second:
090F C002       766            push AR2
0911 7AFA       766            mov R2, #250
0913 120039     766            lcall ?Wait_Milli_Seconds
0916 D002       766            pop AR2
0918 C002       767            push AR2
091A 7AFA       767            mov R2, #250
091C 120039     767            lcall ?Wait_Milli_Seconds
091F D002       767            pop AR2
0921 C002       768            push AR2
0923 7AFA       768            mov R2, #250
0925 120039     768            lcall ?Wait_Milli_Seconds
0928 D002       768            pop AR2
092A C002       769            push AR2
092C 7AFA       769            mov R2, #250
092E 120039     769            lcall ?Wait_Milli_Seconds
0931 D002       769            pop AR2
0933 22         770   ret
0934            771   
0934            772   Wait10us:
0934 784A       773       mov R0, #74
0936 D8FE       774       djnz R0, $
0938 22         775   ret
0939            776   ; ==================================================================================================
0939            777   
0939            778   ;-------------------------------------;
0939            779   ; ISR for Timer 1.  Used to playback  ;
0939            780   ; the WAV file stored in the SPI      ;
0939            781   ; flash memory.                       ;
0939            782   ;-------------------------------------;
0939            783   Timer1_ISR:
0939            784            ; The registers used in the ISR must be saved in the stack
0939 C0E0       785            push acc
093B C0D0       786            push psw
093D            787            
093D            788            ; Check if the play counter is zero.  If so, stop playing sound.
093D E54B       789            mov a, w+0
093F 454C       790            orl a, w+1
0941 454D       791            orl a, w+2
0943 601C       792            jz stop_playing
0945            793            
0945            794            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0945 74FF       795            mov a, #0xff
0947 154B       796            dec w+0
0949 B54B07     797            cjne a, w+0, keep_playing
094C 154C       798            dec w+1
094E B54C02     799            cjne a, w+1, keep_playing
0951 154D       800            dec w+2
0953            801            
0953            802   keep_playing:
0953 D2A6       803            setb SPEAKER
0955 120494     804            lcall Send_SPI ; Read the next byte from the SPI Flash...
0958            805            ;mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
0958 2480       806            add a, #0x80
095A F5AD       807            mov DADH, a ; Output to DAC. DAC output is pin P2.3
095C 43A440     808            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
095F 800C       809            sjmp Timer1_ISR_Done
0961            810   
0961            811   stop_playing:
0961 C28E       812            clr TR1 ; Stop timer 1
0963 D2A5       813            setb FLASH_CE  ; Disable SPI Flash
0965 C2A6       814            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
0967 75AD80     815            mov DADH, #0x80 ; middle of range
096A 43A440     816            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
096D            817   
096D            818   Timer1_ISR_Done:         
096D D0D0       819            pop psw
096F D0E0       820            pop acc
0971 32         821            reti
0972            822   ; ==================================================================================================
0972            823   
0972            824   ;---------------------------------;
0972            825   ; Routine to initialize the ISR   ;
0972            826   ; for timer 2                     ;
0972            827   ;---------------------------------;
0972            828   Timer2_init:
0972 75C800     829       mov T2CON, #0
0975 75CDA9     830       mov TH2, #high(TIMER2_RELOAD)
0978 75CC9A     831       mov TL2, #low(TIMER2_RELOAD)
097B            832   
097B 75CBA9     833       mov RCAP2H, #high(TIMER2_RELOAD)
097E 75CA9A     834       mov RCAP2L, #low(TIMER2_RELOAD)
0981            835   
0981 E4         836       clr a
0982 F530       837       mov Count1ms+0, a
0984 F531       838       mov Count1ms+1, a
0986 F532       839       mov Count5sec , a
0988 D2AD       840       setb ET2
098A D2CA       841       setb TR2
098C C202       842       clr enable_clk
098E 22         843       ret
098F            844   
098F            845   ;---------------------------------;
098F            846   ; ISR for timer 2                 ;
098F            847   ;---------------------------------;
098F            848   Timer2_ISR:
098F C2CF       849       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0991 B290       850       cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0993            851            
0993            852            ; The two registers used in the ISR must be saved in the stack
0993 C0E0       853       push acc
0995 C0D0       854       push psw
0997            855            
0997            856            ; Increment the 16-bit one mili second counter
0997 0530       857            inc Count1ms+0    ; Increment the low 8-bits first
0999 E530       858            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
099B 7002       859            jnz Inc_Done
099D 0531       860            inc Count1ms+1
099F            861   
099F            862   Inc_Done:
099F            863   
099F            864   ;**Oven Power Output-------------------
099F            865       ; Do the PWM thing
099F            866            ; Check if Count1ms > pwm_ratio (this is a 16-bit compare)
099F C3         867            clr c
09A0 E54E       868            mov a, pwm_ratio+0
09A2 9530       869            subb a, Count1ms+0
09A4 E54F       870            mov a, pwm_ratio+1
09A6 9531       871            subb a, Count1ms+1
09A8            872            ; if Count1ms > pwm_ratio  the carry is set.  Just copy the carry to the pwm output pin:
09A8 9290       873            mov PWM_OUTPUT, c
09AA            874   ;**----------------------------------
09AA            875            ; Check if one second has passed
09AA E530       876            mov a, Count1ms+0
09AC B4E836     877            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
09AF E531       878            mov a, Count1ms+1
09B1 B40331     879            cjne a, #high(1000), Timer2_ISR_done
09B4            880            
09B4            881            ; 1000 milliseconds have passed.  Set a flag so the main program knows
09B4 D200       882            setb one_seconds_flag ; Let the main program know one second had passed
09B6            883       
09B6 0532       884       inc Count5sec
09B8 E532       885       mov a, Count5sec
09BA B40505     886       cjne a, #5, Set_5sec_flag_done
09BD D201       887       setb five_seconds_flag
09BF E4         888       clr a
09C0 F532       889       mov Count5sec, a
09C2            890       
09C2            891   Set_5sec_flag_done:
09C2 E4         892            clr a
09C3 F530       893            mov Count1ms+0, a
09C5 F531       894            mov Count1ms+1, a
09C7            895   
09C7 30021B     896       jnb enable_clk, Timer2_ISR_done ;if the clk is enabled, increment the second. Otherwise skip
09CA            897   ; Increment the run time counter and state time counter
09CA E538       898            mov a, Run_time_seconds
09CC 2401       899            add a, #0x01
09CE D4         900            da a
09CF F538       901       mov Run_time_seconds, a
09D1            902       ;check sec overflow
09D1 B4600A     903       cjne a, #0x60, Check_sec_overflow_done
09D4 753800     904       mov Run_time_seconds, #0x00
09D7 E539       905       mov a, Run_time_minutes ;inc min
09D9 2401       906       add a, #1
09DB D4         907       da a
09DC F539       908       mov Run_time_minutes, a
09DE            909   Check_sec_overflow_done:
09DE E53A       910            mov a, State_time
09E0 2401       911            add a, #0x01
09E2 D4         912            da a
09E3 F53A       913            mov State_time, a
09E5            914   Timer2_ISR_done:
09E5 D0D0       915            pop psw
09E7 D0E0       916            pop acc
09E9 32         917            reti
09EA            918   
09EA            919   
09EA            920   ; ==================================================================================================
09EA            921   
09EA            922   main:
09EA 75817F     923       mov SP, #0x7F
09ED 120972     924       lcall Timer2_Init
09F0            925       ;lcall INI_SPI
09F0 120088     926       lcall LCD_4BIT
09F3 1204ED     927       lcall InitSerialPort
09F6 120608     928       lcall INI_PLAYBACK_TEMP
09F9            929       ; In case you decide to use the pins of P0, configure the port in bidirectional mode. Can be ignored
09F9 75E600     930       mov P0M0, #0
09FC 75E700     931       mov P0M1, #0
09FF D2AF       932       setb EA   ;Enable global enterupt
0A01            933   
0A01 120811     934       lcall Load_Configuration
0A04            935   
0A04            936       ; ***play audio***
0A04 C28E       936       clr TR1 ; Stop Timer 1 ISR from playing previous request
0A06 D2A5       936       setb FLASH_CE
0A08 C2A6       936       clr SPEAKER ; Turn off speaker
0A0A            936       
0A0A C2A5       936       clr FLASH_CE ; Enable SPI Flash
0A0C 7403       936       mov a, #READ_BYTES
0A0E 120494     936       lcall Send_SPI
0A11            936       ; Set the initial position in memory where to start playing
0A11            936       
0A11 7401       936       mov a, #0x01 ; change initial position
0A13 120494     936       lcall Send_SPI
0A16 74F4       936       mov a, #0xf4 ; next memory position
0A18 120494     936       lcall Send_SPI
0A1B 7400       936       mov a, #0x00 ; next memory position
0A1D 120494     936       lcall Send_SPI
0A20 7401       936       mov a, #0x01 ; request first byte to send to DAC
0A22 120494     936       lcall Send_SPI
0A25            936       
0A25            936       ; How many bytes to play?
0A25 754D00     936       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0A28 754C1B     936       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
0A2B 754B58     936       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
0A2E            936       
0A2E            936       
0A2E D2A6       936       setb SPEAKER ;Turn on speaker
0A30 D28E       936       setb TR1 ;Start playback by enabling Timer1
0A32            937   
0A32            938       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0A32 754E00     939            mov pwm_ratio+0, #low(0)
0A35 754F00     940            mov pwm_ratio+1, #high(0)
0A38 753300     941       mov States, #0
0A3B            942       
0A3B            943   state0: ; idle
0A3B            944       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0A3B            945            ;mov pwm_ratio+0, #low(0)
0A3B            946            ;mov pwm_ratio+1, #high(0)
0A3B            947       ;mov States, #0
0A3B            948   
0A3B            949   ;***initial parameters displayed***
0A3B            950       
0A3B            951       ;Displays Soak Temp and Time
0A3B 120710     952       lcall State0_display
0A3E            953       ;check power on
0A3E 12057D     954       lcall CHECK_POWER
0A41            955       ; check the parameters being pressed
0A41 12050D     956       lcall CHECK_STIME
0A44 120529     957       lcall CHECK_STEMP
0A47 120545     958       lcall CHECK_RTIME
0A4A 120561     959       lcall CHECK_RTEMP
0A4D 1207DA     960       lcall Save_Configuration
0A50            961       
0A50            962       ;lcall Check_Temp
0A50            963       ;lcall PLAYBACK_TEMP
0A50            964   
0A50 2085E8     965       jb NEXT_STATE_BUTTON, state0
0A53 C002       966            push AR2
0A55 7A32       966            mov R2, #50
0A57 120039     966            lcall ?Wait_Milli_Seconds
0A5A D002       966            pop AR2 ; debounce time
0A5C 2085DC     967            jb NEXT_STATE_BUTTON, state0 ; if button not pressed, loop
0A5F 3085FD     968            jnb NEXT_STATE_BUTTON, $
0A62            969   state0_done:
0A62 753301     970       mov States, #1
0A65 753A00     971       mov State_time, #0
0A68 D202       972       setb enable_clk
0A6A            973      
0A6A            974        
0A6A            975   
0A6A            976   state1_beginning:
0A6A            977       
0A6A            978       ;Start Run Time
0A6A 753800     979       mov Run_time_seconds, #0 ; time starts at 0:00
0A6D 753900     980       mov Run_time_minutes, #0
0A70            981   
0A70            982       ;***clear the screen and set new display***
0A70 12066A     983       lcall Initialize_State_Display
0A73 C0E0       984            push acc
0A75 7407       984            mov a, #7
0A77 14         984            dec a
0A78 1200BD     984            lcall ?Set_Cursor_2 ; Select column and row
0A7B D0E0       984            pop acc
0A7D C083       985            push dph
0A7F C082       985            push dpl
0A81 C0E0       985            push acc
0A83 90044E     985            mov dptr, #Ramp2Soak
0A86 1200B2     985            lcall ?Send_Constant_String
0A89 D0E0       985            pop acc
0A8B D082       985            pop dpl
0A8D D083       985            pop dph; displays current state
0A8F            986   
0A8F            987       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0A8F 754EE8     988            mov pwm_ratio+0, #low(1000)
0A92 754F03     989            mov pwm_ratio+1, #high(1000)
0A95 8003       990       sjmp state1
0A97            991       
0A97            992   main_1:
0A97 0209EA     993            ljmp main
0A9A            994   
0A9A            995   state1: ; ramp to soak
0A9A            996       
0A9A            997       
0A9A            998       ;check power on
0A9A 12057D     999       lcall CHECK_POWER
0A9D           1000       ;Update Time and Temp
0A9D 1206E9    1001       lcall Update_Display
0AA0 12088A    1002       lcall Average_Temp
0AA3           1003   
0AA3           1004   Check_Temp_done1:
0AA3           1005      
0AA3           1006       ;check if temp is below 150 
0AA3           1007       
0AA3           1008       
0AA3           1009   
0AA3 E53B      1010       mov a, Temp_oven           
0AA5 9534      1011       subb a, Temp_soak
0AA7 500E      1012       jnc state1_done      ; if greater, jump to state 2
0AA9 600C      1013       jz state1_done       ; if equal to, jump to state 2
0AAB 4000      1014       jc Check_state1_time ; if less than, check state time
0AAD           1015   Check_state1_time:       ;safety
0AAD E53A      1016       mov a, State_time      
0AAF 943C      1017       subb a, #60
0AB1 50E4      1018       jnc main_1             ; if greater, restart
0AB3 60E2      1019       jz main_1              ; if equal to, restart
0AB5 40E3      1020       jc state1            ; if less than, go back to state1
0AB7           1021   ;*Checking moving to states with buttons---- 
0AB7           1022   ;*Will remove after proper temperature reading----
0AB7           1023   
0AB7           1024       ;jb NEXT_STATE_BUTTON, state1
0AB7           1025       ;Wait_Milli_Seconds(#50) ; debounce time
0AB7           1026            ;jb NEXT_STATE_BUTTON, state1 ; if button not pressed, loop
0AB7           1027            ;jnb NEXT_STATE_BUTTON, $ 
0AB7           1028   
0AB7           1029   state1_done:
0AB7 753302    1030       mov States, #2
0ABA           1031   
0ABA           1032   ; preheat/soak
0ABA           1033   state2_beginning: 
0ABA 753A00    1034       mov State_time, #0;x00 ;clear the state time
0ABD           1035       ;***clear the screen and set new display***
0ABD 12066A    1036       lcall Initialize_State_Display
0AC0 C0E0      1037            push acc
0AC2 7407      1037            mov a, #7
0AC4 14        1037            dec a
0AC5 1200BD    1037            lcall ?Set_Cursor_2 ; Select column and row
0AC8 D0E0      1037            pop acc
0ACA C083      1038            push dph
0ACC C082      1038            push dpl
0ACE C0E0      1038            push acc
0AD0 900458    1038            mov dptr, #Soak
0AD3 1200B2    1038            lcall ?Send_Constant_String
0AD6 D0E0      1038            pop acc
0AD8 D082      1038            pop dpl
0ADA D083      1038            pop dph ;displays current state
0ADC           1039   
0ADC           1040       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
0ADC 754EC8    1041            mov pwm_ratio+0, #low(200)
0ADF 754F00    1042            mov pwm_ratio+1, #high(000)
0AE2           1043   
0AE2           1044   state2:
0AE2           1045       ;check power on
0AE2 12057D    1046       lcall CHECK_POWER 
0AE5           1047       ;Update Time and Temp
0AE5 1206E9    1048       lcall Update_Display
0AE8 12088A    1049       lcall Average_Temp
0AEB           1050       
0AEB           1051       ; loop back to state2 if run time is less than soak time. If greater than jump to state3 cuz of overflow of time
0AEB           1052        
0AEB E53A      1053       mov a, State_time
0AED 9535      1054       subb a, Time_soak
0AEF 5002      1055       jnc state2_done
0AF1 40EF      1056       jc state2
0AF3           1057   
0AF3           1058   
0AF3           1059   ;*Checking moving to states with buttons---- 
0AF3           1060   ;*Will remove after proper temperature reading----
0AF3           1061   
0AF3           1062       ;jb NEXT_STATE_BUTTON, state2
0AF3           1063       ;Wait_Milli_Seconds(#50) ; debounce time
0AF3           1064            ;jb NEXT_STATE_BUTTON, state2 ; if button not pressed, loop
0AF3           1065            ;jnb NEXT_STATE_BUTTON, $ 
0AF3           1066       
0AF3           1067   state2_done:
0AF3 753A03    1068       mov State_time, #3
0AF6           1069   
0AF6           1070   ; ramp to peak
0AF6           1071   state3_beginning:
0AF6           1072       ;setb OVEN_POWER ;turn power on 100%
0AF6           1073   
0AF6           1074       ;***clear the screen and set new display***
0AF6 12066A    1075       lcall Initialize_State_Display
0AF9 C0E0      1076            push acc
0AFB 7407      1076            mov a, #7
0AFD 14        1076            dec a
0AFE 1200BD    1076            lcall ?Set_Cursor_2 ; Select column and row
0B01 D0E0      1076            pop acc
0B03 C083      1077            push dph
0B05 C082      1077            push dpl
0B07 C0E0      1077            push acc
0B09 90045D    1077            mov dptr, #Ramp2Peak
0B0C 1200B2    1077            lcall ?Send_Constant_String
0B0F D0E0      1077            pop acc
0B11 D082      1077            pop dpl
0B13 D083      1077            pop dph
0B15           1078   
0B15           1079       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0B15 754EE8    1080            mov pwm_ratio+0, #low(1000)
0B18 754F03    1081            mov pwm_ratio+1, #high(1000)
0B1B           1082   
0B1B           1083   state3: 
0B1B           1084       ;check power on
0B1B 12057D    1085       lcall CHECK_POWER
0B1E 12088A    1086       lcall Average_Temp
0B21           1087       
0B21           1088       
0B21           1089       ;Update Time and Temp
0B21 1206E9    1090       lcall Update_Display
0B24           1091       
0B24 E53B      1092       mov a, Temp_oven           
0B26 9536      1093       subb a, Temp_refl
0B28 5004      1094       jnc state3_done    ; if greater, jump to state 4
0B2A 6002      1095       jz state3_done ; if equal to, jump to state 4
0B2C 40ED      1096       jc state3 ; if less than, go back to state3
0B2E           1097       
0B2E           1098       ;jb NEXT_STATE_BUTTON, state3
0B2E           1099       ;Wait_Milli_Seconds(#50) ; debounce time
0B2E           1100            ;jb NEXT_STATE_BUTTON, state3 ; if button not pressed, loop
0B2E           1101            ;jnb NEXT_STATE_BUTTON, $
0B2E           1102   
0B2E           1103   state3_done:
0B2E 753A04    1104       mov State_time, #4
0B31           1105   
0B31           1106   ; reflow 
0B31           1107   state4_beginning:
0B31           1108       
0B31 753A00    1109       mov State_time, #0;x00 clear the state time
0B34           1110       ;***clear the screen and set new display***
0B34 12066A    1111       lcall Initialize_State_Display
0B37 C0E0      1112            push acc
0B39 7407      1112            mov a, #7
0B3B 14        1112            dec a
0B3C 1200BD    1112            lcall ?Set_Cursor_2 ; Select column and row
0B3F D0E0      1112            pop acc
0B41 C083      1113            push dph
0B43 C082      1113            push dpl
0B45 C0E0      1113            push acc
0B47 900467    1113            mov dptr, #Reflow
0B4A 1200B2    1113            lcall ?Send_Constant_String
0B4D D0E0      1113            pop acc
0B4F D082      1113            pop dpl
0B51 D083      1113            pop dph
0B53           1114   
0B53           1115       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
0B53 754EC8    1116            mov pwm_ratio+0, #low(200)
0B56 754F00    1117            mov pwm_ratio+1, #high(000)
0B59           1118   
0B59           1119   
0B59           1120   state4:
0B59           1121       ;check power on
0B59 12057D    1122       lcall CHECK_POWER
0B5C           1123       ;Update Time and Temp
0B5C 1206E9    1124       lcall Update_Display
0B5F 12088A    1125       lcall Average_Temp
0B62           1126       
0B62           1127       ; loop back to state2 if run time is less than soak time
0B62 E53A      1128       mov a, State_time
0B64 9537      1129       subb a, Time_refl
0B66 5002      1130       jnc state4_done
0B68 40EF      1131       jc state4
0B6A           1132   
0B6A           1133       ;*Checking moving to states with buttons---- 
0B6A           1134   ;*Will remove after proper temperature reading----
0B6A           1135   
0B6A           1136       ;jb NEXT_STATE_BUTTON, state4
0B6A           1137       ;Wait_Milli_Seconds(#50) ; debounce time
0B6A           1138            ;jb NEXT_STATE_BUTTON, state4 ; if button not pressed, loop
0B6A           1139            ;jnb NEXT_STATE_BUTTON, $ 
0B6A           1140   
0B6A           1141   state4_done: 
0B6A 753A00    1142       mov State_time, #0
0B6D 020B70    1143       ljmp state5_beginning 
0B70           1144   
0B70           1145   
0B70           1146   ; cooling
0B70           1147   state5_beginning: ; turn oven off
0B70 C287      1148       clr OVEN_POWER
0B72           1149   
0B72           1150   ;***clear the screen and set new display***
0B72 12066A    1151       lcall Initialize_State_Display
0B75 C083      1152            push dph
0B77 C082      1152            push dpl
0B79 C0E0      1152            push acc
0B7B 90046E    1152            mov dptr, #Cooling
0B7E 1200B2    1152            lcall ?Send_Constant_String
0B81 D0E0      1152            pop acc
0B83 D082      1152            pop dpl
0B85 D083      1152            pop dph
0B87           1153   
0B87           1154       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0B87 754E00    1155            mov pwm_ratio+0, #low(0)
0B8A 754F00    1156            mov pwm_ratio+1, #high(0)
0B8D           1157   
0B8D           1158   state5:
0B8D           1159       ;check power on
0B8D 12057D    1160       lcall CHECK_POWER
0B90           1161       
0B90           1162       ; update display
0B90 1206E9    1163       lcall Update_Display
0B93 12088A    1164       lcall Average_Temp
0B96           1165   
0B96 E53B      1166       mov a, Temp_oven
0B98 943C      1167       subb a, #60
0B9A 50F1      1168       JNC state5    ; if greater, jump back to state 5
0B9C 60EF      1169       JZ state5 ; if equal to, go back to state5
0B9E 4000      1170       JC state5_done ; if less than, go back to state 0
0BA0           1171   
0BA0           1172       ;*Checking moving to states with buttons---- 
0BA0           1173   ;*Will remove after proper temperature reading----
0BA0           1174   
0BA0           1175       ;jb NEXT_STATE_BUTTON, state5
0BA0           1176       ;Wait_Milli_Seconds(#50) ; debounce time
0BA0           1177            ;jb NEXT_STATE_BUTTON, state5 ; if button not pressed, loop
0BA0           1178            ;jnb NEXT_STATE_BUTTON, $ 
0BA0           1179   
0BA0           1180   state5_done:
0BA0 753A00    1181       mov State_time, #0
0BA3 753300    1182       mov States, #0
0BA6 0209EA    1183       ljmp main
0BA9           1184   
0BA9           1185   EN
