                  2   $LIST
0000              4   
0000              5   
0000              6   
0000              7   ;-------------------------------------------------------------------------------------------------------------------------------
0000              8   ;These EQU must match the wiring between the microcontroller and ADC
0000              9   CLK  EQU 22118400
0000             10   TIMER1_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             11   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             12   BAUD equ 115200
0000             13   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000             14   
0000             15   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             16   TIMER2_RELOAD EQU (65536-(CLK/TIMER2_RATE))
0000             17   
0000             18   ;shjfjdfs
0000             19   ;-------------------------------------------------------------------------------------------------------------------------------
0000             20   ;Button Pin Mapping
0000             21   NEXT_STATE_BUTTON  equ P1.3;0.5
0000             22   STIME_BUTTON    equ P1.4;0.2
0000             23   STEMP_BUTTON    equ P1.5;0.3
0000             24   RTIME_BUTTON    equ P1.6;0.4
0000             25   RTEMP_BUTTON    equ P1.7;0.6
0000             26   
0000             27   POWER_BUTTON    equ P4.5
0000             28   SHIFT_BUTTON    equ p0.4
0000             29   
0000             30   ;Output Pins
0000             31   OVEN_POWER      equ P0.7
0000             32   SPEAKER         equ P2.6
0000             33   
0000             34   PWM_OUTPUT    equ P1.0 ; Attach an LED (with 1k resistor in series) to P1.0
0000             35   
0000             36   FLASH_CE        equ P0.0
0000             37   
0000             38   ;Thermowire Pins
0000             39   CE_ADC    EQU  P0.0;1.7
0000             40   MY_MOSI   EQU  P0.1;1.6
0000             41   MY_MISO   EQU  P0.2;1.5
0000             42   MY_SCLK   EQU  P0.3;1.4 
0000             43   
0000             44   ; Commands supported by the SPI flash memory according to the datasheet
0000             45   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             46   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             47   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             48   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             49   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             50   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             51   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             52   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             53   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             54   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             55   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             56   
0000             57   ; These 'equ' must match the hardware wiring
0000             58   LCD_RS equ P3.2
0000             59   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
0000             60   LCD_E  equ P3.3
0000             61   LCD_D4 equ P3.4
0000             62   LCD_D5 equ P3.5
0000             63   LCD_D6 equ P3.6
0000             64   LCD_D7 equ P3.7
0000             65   
0000             66   ;-------------------------------------------------------------------------------------------------------------------------------
0000             67   
0000             68   org 0x0000
0000 0209DB      69       ljmp main
0003             70   
0003             71   ; External interrupt 0 vector (not used in this code)
0003             72   org 0x0003
0003 32          73            reti
0004             74   
0004             75   ; Timer/Counter 0 overflow interrupt vector
000B             76   org 0x000B
000B 32          77            reti
000C             78   
000C             79   ; External interrupt 1 vector (not used in this code)
0013             80   org 0x0013
0013 32          81            reti
0014             82   
0014             83   ; Timer/Counter 1 overflow interrupt vector
001B             84   org 0x001B
001B 02092A      85            ljmp Timer1_ISR
001E             86   
001E             87   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             88   org 0x0023 
0023 32          89            reti
0024             90            
0024             91   ; Timer/Counter 2 overflow interrupt vector
002B             92   org 0x002B
002B 020980      93       ljmp Timer2_ISR
002E             94   ;-------------------------------------------------------------------------------------------------------------------------------
002E             95   ; Place our variables here
0030             96   DSEG at 0x30 ; Before the state machine!
0030             97   Count1ms:         ds 2 ; Used to determine when one second has passed
0032             98   Count5sec:        ds 1
0033             99   States:           ds 1
0034            100   Temp_soak:        ds 1
0035            101   Time_soak:        ds 1
0036            102   Temp_refl:        ds 1
0037            103   Time_refl:        ds 1
0038            104   Run_time_seconds: ds 1
0039            105   Run_time_minutes: ds 1
003A            106   State_time:       ds 1
003B            107   Temp_oven:        ds 1
003C            108   x:                ds 4
0040            109   y:                ds 4
0044            110   bcd:              ds 5
0049            111   Result:           ds 2
004B            112   w:                ds 3
004E            113   pwm_ratio:        ds 2
0050            114   average_count:    ds 1
0051            115   
                117   $LIST
00F0            119   
                546   $LIST
                121   $LIST
0360            123   
                125   $LIST
03E7            127   
0000            128   bseg
0000            129   one_seconds_flag:  dbit 1
0001            130   five_seconds_flag: dbit 1
0002            131   enable_clk:        dbit 1
0003            132   mf:                dbit 1
0004            133   
03E7            134   cseg
03E7            135   
03E7            136   ;-------------------------------------------------------------------------------------------------------------------------------
03E7            137   ;***Messages To Display*** 
03E7            138   
03E7            139   ;shortened labels
03E7 53546D70   140   STemp:  db 'STmp:', 0
     3A00
03ED 53546D3A   141   STime:  db 'STm:', 0
     00
03F2 52546D70   142   RTemp:  db 'RTmp:', 0
     3A00
03F8 52546D3A   143   RTime:  db 'RTm:', 0
     00
03FD            144   
03FD            145   ;lables for runnning oven
03FD 53746174   146   state:     db 'State>' , 0
     653E00
0404 546D653E   147   time:      db 'Tme>' , 0
     00
0409 3A00       148   colon:     db ':', 0
040B 546D703E   149   temp:      db 'Tmp>', 0
     00
0410            150   
0410            151   ;labels for changin parameters
0410 5265666C   152   ReflowTemp:  db 'Reflow Temperature:', 0
     6F772054
     656D7065
     72617475
     72653A00
0424 5265666C   153   ReflowTime:  db 'Reflow Time:', 0
     6F772054
     696D653A
     00
0431 536F616B   154   SoakTime:    db 'Soak Time:', 0
     2054696D
     653A00
043C 536F616B   155   SoakTemp:    db 'Soak Temperature:', 0
     2054656D
     70657261
     74757265
     3A00
044E            156   
044E            157   
044E            158   ;Current State in Oven
044E 52616D70   159   Ramp2Soak: db 'Ramp-Soak' , 0
     2D536F61
     6B00
0458 536F616B   160   Soak:      db 'Soak' , 0
     00
045D 52616D70   161   Ramp2Peak: db 'Ramp-Peak' , 0
     2D506561
     6B00
0467 5265666C   162   Reflow:    db 'Reflow' , 0
     6F7700
046E 436F6F6C   163   Cooling:   db 'Cooling' , 0
     696E6700
0476            164   
0476            165   ;-------------------------------------------------------------------------------------------------------------------------------
0476            166   ;FXNS FOR THERMOWIRE
0476            167   
0476            168   ;initialize SPI 
0476            169   INI_SPI:
0476 D282       170            setb MY_MISO ; Make MISO an input pin
0478 C283       171            clr MY_SCLK           ; Mode 0,0 default
047A 22         172            ret
047B            173   DO_SPI_G:
047B C0E0       174            push acc
047D 7900       175            mov R1, #0 ; Received byte stored in R1
047F 7A08       176            mov R2, #8            ; Loop counter (8-bits)
0481            177   DO_SPI_G_LOOP:
0481 E8         178            mov a, R0             ; Byte to write is in R0
0482 33         179            rlc a                 ; Carry flag has bit to write
0483 F8         180            mov R0, a
0484 9281       181            mov MY_MOSI, c
0486 D283       182            setb MY_SCLK          ; Transmit
0488 A282       183            mov c, MY_MISO        ; Read received bit
048A E9         184            mov a, R1             ; Save received bit in R1
048B 33         185            rlc a
048C F9         186            mov R1, a
048D C283       187            clr MY_SCLK
048F DAF0       188            djnz R2, DO_SPI_G_LOOP
0491 D0E0       189            pop acc
0493 22         190   ret
0494            191   
0494            192   Send_SPI:
                193   	SPIBIT MAC
                194   	    ; Send/Receive bit %0
                195   		rlc a
                196   		mov MY_MOSI, c
                197   		setb MY_SCLK
                198   		mov c, MY_MISO
                199   		clr MY_SCLK
                200   		mov acc.0, c
                201   	ENDMAC
0494            202            
0494            203                ; Send/Receive bit 7
0494 33         203                    rlc a
0495 9281       203                    mov MY_MOSI, c
0497 D283       203                    setb MY_SCLK
0499 A282       203                    mov c, MY_MISO
049B C283       203                    clr MY_SCLK
049D 92E0       203                    mov acc.0, c
049F            204                ; Send/Receive bit 6
049F 33         204                    rlc a
04A0 9281       204                    mov MY_MOSI, c
04A2 D283       204                    setb MY_SCLK
04A4 A282       204                    mov c, MY_MISO
04A6 C283       204                    clr MY_SCLK
04A8 92E0       204                    mov acc.0, c
04AA            205                ; Send/Receive bit 5
04AA 33         205                    rlc a
04AB 9281       205                    mov MY_MOSI, c
04AD D283       205                    setb MY_SCLK
04AF A282       205                    mov c, MY_MISO
04B1 C283       205                    clr MY_SCLK
04B3 92E0       205                    mov acc.0, c
04B5            206                ; Send/Receive bit 4
04B5 33         206                    rlc a
04B6 9281       206                    mov MY_MOSI, c
04B8 D283       206                    setb MY_SCLK
04BA A282       206                    mov c, MY_MISO
04BC C283       206                    clr MY_SCLK
04BE 92E0       206                    mov acc.0, c
04C0            207                ; Send/Receive bit 3
04C0 33         207                    rlc a
04C1 9281       207                    mov MY_MOSI, c
04C3 D283       207                    setb MY_SCLK
04C5 A282       207                    mov c, MY_MISO
04C7 C283       207                    clr MY_SCLK
04C9 92E0       207                    mov acc.0, c
04CB            208                ; Send/Receive bit 2
04CB 33         208                    rlc a
04CC 9281       208                    mov MY_MOSI, c
04CE D283       208                    setb MY_SCLK
04D0 A282       208                    mov c, MY_MISO
04D2 C283       208                    clr MY_SCLK
04D4 92E0       208                    mov acc.0, c
04D6            209                ; Send/Receive bit 1
04D6 33         209                    rlc a
04D7 9281       209                    mov MY_MOSI, c
04D9 D283       209                    setb MY_SCLK
04DB A282       209                    mov c, MY_MISO
04DD C283       209                    clr MY_SCLK
04DF 92E0       209                    mov acc.0, c
04E1            210                ; Send/Receive bit 0
04E1 33         210                    rlc a
04E2 9281       210                    mov MY_MOSI, c
04E4 D283       210                    setb MY_SCLK
04E6 A282       210                    mov c, MY_MISO
04E8 C283       210                    clr MY_SCLK
04EA 92E0       210                    mov acc.0, c
04EC            211   
04EC 22         212   ret
04ED            213   
                214   Change_8bit_Variable MAC
                215       jb %0, %2
                216       Wait_Milli_Seconds(#50) ; de-bounce
                217       jb %0, %2
                218       jnb %0, $
                219       jb SHIFT_BUTTON, skip%Mb
                220       dec %1
                221       sjmp skip%Ma
                222       skip%Mb:
                223       inc %1
                224       skip%Ma:
                225   ENDMAC
04ED            226   
04ED            227   ;Change_8bit_Variable(MY_VARIABLE_BUTTON, my_variable, loop_c)
04ED            228   ;    Set_Cursor(2, 14)
04ED            229   ;    mov a, my_variable
04ED            230   ;    lcall SendToLCD
04ED            231   ;lcall Save_Configuration
04ED            232   
04ED            233   ;-------------------------------------------------------------------------------------------------------------------------------
04ED            234   ;***FXNS For Serial Port
04ED            235   
04ED            236   ; Configure the serial port and baud rate
04ED            237   InitSerialPort:
04ED            238       ; Since the reset button bounces, we need to wait a bit before
04ED            239       ; sending messages, otherwise we risk displaying gibberish!
04ED 79DE       240       mov R1, #222
04EF 78A6       241       mov R0, #166
04F1 D8FE       242       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
04F3 D9FA       243       djnz R1, $-4 ; 22.51519us*222=4.998ms
04F5            244       ; Now we can proceed with the configuration
04F5 438780     245            orl     PCON,#0x80
04F8 759852     246            mov     SCON,#0x52
04FB 759B00     247            mov     BDRCON,#0x00
04FE 759AF4     248            mov     BRL,#BRG_VAL
0501 759B1E     249            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0504 22         250   ret
0505            251   
0505            252   
0505            253   putchar:
0505 3099FD     254       jnb TI, putchar
0508 C299       255       clr TI
050A F599       256       mov SBUF, a
050C 22         257   ret
050D            258   
050D            259   ;-------------------------------------------------------------------------------------------------------------------------------
050D            260   ;***FXNS to CHECK BUTTONS
050D            261   
050D            262   CHECK_STIME:
050D            263   
050D            264       ;jb STIME_BUTTON, CHECK_STIME_END ; if button not pressed, stop checking
050D            265            ;Wait_Milli_Seconds(#50) ; debounce time
050D            266            ;jb STIME_BUTTON, CHECK_STIME_END ; if button not pressed, stop checking
050D            267            ;jnb STIME_BUTTON, $ ; loop while the button is pressed
050D            268       
050D            269       ;inc Time_soak
050D            270   
050D            271       ;mov a, Time_soak ;increment STime by 1
050D            272       ;add a, #0x01
050D            273       ;da a
050D            274       ;mov Time_soak, a
050D            275       ;cjne a, #0x5B, CHECK_STIME_END
050D            276       ;mov Time_soak, #0x3C
050D            277       ;lcall Save_Configuration
050D            278   
050D 209418     279       jb STIME_BUTTON, CHECK_STIME_END
0510 C002       279            push AR2
0512 7A32       279            mov R2, #50
0514 120039     279            lcall ?Wait_Milli_Seconds
0517 D002       279            pop AR2 ; de-bounce
0519 20940C     279       jb STIME_BUTTON, CHECK_STIME_END
051C 3094FD     279       jnb STIME_BUTTON, $
051F 208404     279       jb SHIFT_BUTTON, skip16b
0522 1535       279       dec Time_soak
0524 8002       279       sjmp skip16a
0526            279       skip16b:
0526 0535       279       inc Time_soak
0528            279       skip16a:
0528            280       ;mov a, Time_soak
0528            281       ;lcall SendToLCD
0528            282       ;lcall Save_Configuration
0528            283            
0528            284   CHECK_STIME_END:
0528 22         285   ret
0529            286   
0529            287   CHECK_STEMP:
0529            288   
0529            289       ;jb STEMP_BUTTON, CHECK_STEMP_END ; if button not pressed, stop checking
0529            290            ;Wait_Milli_Seconds(#50) ; debounce time
0529            291            ;jb STEMP_BUTTON, CHECK_STEMP_END ; if button not pressed, stop checking
0529            292            ;jnb STEMP_BUTTON, $ ; loop while the button is pressed
0529            293       
0529            294       ;mov a, Temp_soak ;increment STEMP by 5
0529            295       ;add a, #5
0529            296       ;da a
0529            297       ;mov Temp_soak, a
0529            298       ;cjne a, #175, CHECK_STEMP_END
0529            299       ;mov Temp_soak, #130
0529            300   
0529 209518     301       jb STEMP_BUTTON, CHECK_STEMP_END
052C C002       301            push AR2
052E 7A32       301            mov R2, #50
0530 120039     301            lcall ?Wait_Milli_Seconds
0533 D002       301            pop AR2 ; de-bounce
0535 20950C     301       jb STEMP_BUTTON, CHECK_STEMP_END
0538 3095FD     301       jnb STEMP_BUTTON, $
053B 208404     301       jb SHIFT_BUTTON, skip18b
053E 1534       301       dec Temp_soak
0540 8002       301       sjmp skip18a
0542            301       skip18b:
0542 0534       301       inc Temp_soak
0544            301       skip18a:
0544            302       ;lcall Save_Configuration
0544            303            
0544            304   CHECK_STEMP_END:
0544 22         305   ret
0545            306   
0545            307   CHECK_RTIME:
0545            308   
0545            309       ;jb RTIME_BUTTON, CHECK_RTIME_END ; if button not pressed, stop checking
0545            310            ;Wait_Milli_Seconds(#50) ; debounce time
0545            311            ;jb RTIME_BUTTON, CHECK_RTIME_END ; if button not pressed, stop checking
0545            312            ;jnb RTIME_BUTTON, $ ; loop while the button is pressed
0545            313       
0545            314       ;mov a, Time_refl ;increment RTime by 1
0545            315       ;add a, #0x01
0545            316       ;da a
0545            317       ;mov Time_refl, a
0545            318       ;cjne a, #0x3D, CHECK_RTIME_END
0545            319       ;mov Time_refl, #0x1E
0545            320       ;lcall Save_Configuration
0545 209618     321       jb RTIME_BUTTON, CHECK_RTIME_END
0548 C002       321            push AR2
054A 7A32       321            mov R2, #50
054C 120039     321            lcall ?Wait_Milli_Seconds
054F D002       321            pop AR2 ; de-bounce
0551 20960C     321       jb RTIME_BUTTON, CHECK_RTIME_END
0554 3096FD     321       jnb RTIME_BUTTON, $
0557 208404     321       jb SHIFT_BUTTON, skip20b
055A 1537       321       dec Time_refl
055C 8002       321       sjmp skip20a
055E            321       skip20b:
055E 0537       321       inc Time_refl
0560            321       skip20a:
0560            322   
0560            323   CHECK_RTIME_END:
0560 22         324   ret
0561            325   
0561            326   CHECK_RTEMP:
0561            327   
0561            328       ;jb RTEMP_BUTTON, CHECK_RTEMP_END ; if button not pressed, stop checking
0561            329            ;Wait_Milli_Seconds(#50) ; debounce time
0561            330            ;jb RTEMP_BUTTON, CHECK_RTEMP_END ; if button not pressed, stop checking
0561            331            ;jnb RTEMP_BUTTON, $ ; loop while the button is pressed
0561            332       
0561            333       ;mov a, Temp_refl ;increment RTemp by 5
0561            334       ;add a, #5
0561            335       ;da a
0561            336       ;mov Temp_refl, a
0561            337       ;cjne a, #255, CHECK_RTEMP_END
0561            338       ;mov Temp_refl, #220
0561            339       ;lcall Save_Configuration
0561            340   
0561 209718     341       jb RTEMP_BUTTON, CHECK_RTEMP_END
0564 C002       341            push AR2
0566 7A32       341            mov R2, #50
0568 120039     341            lcall ?Wait_Milli_Seconds
056B D002       341            pop AR2 ; de-bounce
056D 20970C     341       jb RTEMP_BUTTON, CHECK_RTEMP_END
0570 3097FD     341       jnb RTEMP_BUTTON, $
0573 208404     341       jb SHIFT_BUTTON, skip22b
0576 1536       341       dec Temp_refl
0578 8002       341       sjmp skip22a
057A            341       skip22b:
057A 0536       341       inc Temp_refl
057C            341       skip22a:
057C            342            
057C            343   CHECK_RTEMP_END:
057C 22         344   ret
057D            345   
057D            346   CHECK_POWER:
057D            347   
057D 20C512     348       jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
0580 C002       349            push AR2
0582 7A32       349            mov R2, #50
0584 120039     349            lcall ?Wait_Milli_Seconds
0587 D002       349            pop AR2 ; debounce time
0589 20C506     350            jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
058C 30C5FD     351            jnb POWER_BUTTON, $ ; loop while the button is pressed
058F 120876     352       lcall OFF_STATE
0592            353   
0592            354   CHECK_POWER_END:
0592 22         355   ret
0593            356   
0593            357   SOUND_FSM:
0593            358   state_0_sound:
0593            359   ;check if 5 seconds has passed, if yes go to state 1, if no exit function 
0593 300105     360       jnb five_seconds_flag, Sound_ret
0596 C201       361       clr five_seconds_flag
0598 02059C     362       ljmp state_1_sound
059B            363   Sound_ret:
059B 22         364       ret
059C            365   
059C            366   state_1_sound:
059C            367   ; check if temp is greater than 100, if yes go to state 2
059C            368   ; check if temp is less than 100, if yes go to state 4
059C E53B       369       mov a, Temp_oven
059E 9464       370       subb a, #100
05A0 5002       371       jnc state_2_sound
05A2 4026       372       jc state_4_sound
05A4            373   
05A4            374   state_2_sound:
05A4            375   ;divide temp by 100, if it is 1 play sound: "100", if it is 2 play sound: "200"
05A4            376   ; go to state_3_sound
05A4 75F064     377       mov b, #100
05A7 E53B       378       mov a, Temp_oven
05A9 84         379       div ab
05AA 9401       380       subb a, #1
05AC 600A       381       jz play_sound_1
05AE            382   
05AE 75F064     383       mov b, #100
05B1 E53B       384       mov a, Temp_oven
05B3 84         385       div ab
05B4 9402       386       subb a, #2
05B6 6000       387       jz play_sound_1
05B8            388      
05B8            389      play_sound_1: 
05B8 02060E     390       ljmp PLAYBACK_TEMP
05BB            391   
05BB 0205BE     392       ljmp state_3_sound
05BE            393   
05BE            394   
05BE            395   state_3_sound:
05BE            396   ; check remainder of temp, if it is 0, go back to state_0_sound
05BE            397   ; if not 0, go to state_4_sound
05BE            398   
05BE 75F064     399       mov b, #100
05C1 E53B       400       mov a, Temp_oven
05C3 84         401       div ab
05C4 E5F0       402       mov a, b
05C6 60CB       403       jz state_0_sound
05C8 7000       404       jnz state_4_sound
05CA            405   
05CA            406   state_4_sound:
05CA            407   ; if T % 100 greater or equal to 20, go to state_5_sound,
05CA 75F064     408       mov b, #100
05CD E53B       409       mov a, Temp_oven
05CF 84         410       div ab
05D0 E5F0       411       mov a, b 
05D2 9414       412       subb a, #20
05D4 5011       413       jnc state_5_sound
05D6 E4         414       clr a
05D7            415   ; if T % 100 is less than 10, go to state_6_sound
05D7 75F064     416       mov b, #100
05DA E53B       417       mov a, Temp_oven
05DC 84         418       div ab
05DD E5F0       419       mov a, b
05DF 940A       420       subb a, #10
05E1 401C       421       jc state_6_sound
05E3 E4         422       clr a
05E4            423   ; if T % 100 is greater than 10 and less than 20, go to state_7_sound
05E4 020605     424       ljmp state_7_sound
05E7            425       
05E7            426   
05E7            427   state_5_sound:
05E7            428   ; play number from 20 to 90 in decades (20, 30, 40, 50, 60, 70, 80, 90), based off remainder from temp divided by 100
05E7            429   ; if (T % 100) % 10 is not equal to 0, go to state_6_sound
05E7            430   ; if (T % 100) % 10 is equal to 0, go to state_8_sound
05E7            431   
05E7 E53B       432       mov a, Temp_oven
05E9 75F064     433       mov b, #100
05EC 84         434       div ab
05ED E5F0       435       mov a, b
05EF 75F00A     436       mov b, #10
05F2 84         437       div ab
05F3 E5F0       438       mov a, b
05F5 6002       439       jz play_sound
05F7 7006       440       jnz state_6_sound
05F9            441       
05F9            442   
05F9            443       play_sound:
05F9 02060E     444           ljmp PLAYBACK_TEMP
05FC 02060B     445           ljmp state_8_sound
05FF            446   
05FF            447   
05FF            448   state_6_sound:
05FF            449   ; play 1 - 9
05FF 02060E     450       ljmp PLAYBACK_TEMP
0602            451   ; go to state_8_sound
0602 02060B     452       ljmp state_8_sound
0605            453   
0605            454   
0605            455   state_7_sound:
0605            456   ; play 10 - 19
0605 02060E     457       ljmp PLAYBACK_TEMP
0608            458   ; go to state_8_sound 
0608 02060B     459       ljmp state_8_sound
060B            460   
060B            461   state_8_sound:
060B            462   ; go to state_0_sound
060B 020593     463       ljmp state_0_sound
060E            464   
060E            465   
060E            466   PLAYBACK_TEMP:
060E            467       ; ****INITIALIZATION****
060E            468       ; Configure SPI pins and turn off speaker
060E 53CECE     469            anl P2M0, #0b_1100_1110
0611 43CF31     470            orl P2M1, #0b_0011_0001
0614 D282       471            setb MY_MISO  ; Configured as input
0616 D280       472            setb FLASH_CE ; CS=1 for SPI flash memory
0618 C283       473            clr MY_SCLK   ; Rest state of SCLK=0
061A C2A6       474            clr SPEAKER   ; Turn off speaker.
061C            475            
061C            476            ; Configure timer 1
061C 53890F     477            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
061F 438910     478            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
0622 758DFC     479            mov TH1, #high(TIMER1_RELOAD)
0625 758B15     480            mov TL1, #low(TIMER1_RELOAD)
0628            481            ; Set autoreload value
0628 75F5FC     482            mov RH1, #high(TIMER1_RELOAD)
062B 75F315     483            mov RL1, #low(TIMER1_RELOAD)
062E            484   
062E            485            ;Enable the timer and interrupts
062E D2AB       486       setb ET1  ; Enable timer 1 interrupt
0630 D28E       487            setb TR1 ; Timer 1 is only enabled to play stored sound
0632            488   
0632            489            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
0632 75A5A0     490            mov DADI, #0b_1010_0000 ; ACON=1
0635 75A43A     491            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0638 75AD80     492            mov DADH, #0x80 ; Middle of scale
063B 75AC00     493            mov DADL, #0
063E 43A440     494            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
0641            495   
0641            496       ; ***play audio***
0641 C28E       497       clr TR1 ; Stop Timer 1 ISR from playing previous request
0643 D280       498       setb FLASH_CE 
0645 C2A6       499       clr SPEAKER ; Turn off speaker
0647            500   
0647 C280       501       clr FLASH_CE ; Enable SPI Flash
0649            502       ;mov READ_BYTES, #3
0649 7403       503       mov a, #READ_BYTES
064B 120494     504       lcall Send_SPI
064E            505       ; Set the initial position in memory where to start playing
064E            506       
064E 7402       507       mov a, #0x02 ; change initial position
0650 120494     508       lcall Send_SPI
0653 74D5       509       mov a, #0xd5 ; next memory position
0655 120494     510       lcall Send_SPI 
0658 742D       511       mov a, #0x2d ; next memory position
065A 120494     512       lcall Send_SPI
065D 7402       513       mov a, #0x02 ; request first byte to send to DAC
065F 120494     514       lcall Send_SPI
0662            515   
0662            516       ; How many bytes to play?
0662 754D00     517       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0665 754C39     518       mov w+1, #0x39 ; Load the middle byte of the number of bytes to play
0668 754B6A     519       mov w+0, #0x6a ; Load the low byte of the number of bytes to play
066B            520    
066B D2A6       521       setb SPEAKER ;Turn on speaker
066D D28E       522       setb TR1 ;Start playback by enabling Timer1 
066F 22         523       ret
0670            524       
0670            525   ;-------------------------------------------------------------------------------------------------------------------------------
0670            526   ;***LCD FXNS
0670            527   
                528   Display_lower_BCD mac
                529       push ar0
                530       mov r0, %0
                531       lcall ?Display_lower_BCD
                532       pop ar0
                533   endmac
0670            534   
0670            535   ?Display_lower_BCD:
0670 C0E0       536       push acc
0672            537       ; write least significant digit
0672 E8         538       mov a, r0
0673 540F       539       anl a, #0fh
0675 4430       540       orl a, #30h
0677 12007E     541       lcall ?WriteData
067A D0E0       542       pop acc
067C 22         543   ret
067D            544   
067D            545   
067D            546   SendToLCD:
067D 75F064     547       mov b, #100
0680 84         548       div ab
0681 4430       549       orl a, #0x30h ; Convert hundreds to ASCII
0683 12007E     550       lcall ?WriteData ; Send to LCD
0686 E5F0       551       mov a, b    ; Remainder is in register b
0688 75F00A     552       mov b, #10
068B 84         553       div ab
068C 4430       554       orl a, #0x30h ; Convert tens to ASCII
068E 12007E     555       lcall ?WriteData; Send to LCD
0691 E5F0       556       mov a, b
0693 4430       557       orl a, #0x30h ; Convert units to ASCII
0695 12007E     558       lcall ?WriteData; Send to LCD
0698 22         559   ret
0699            560   
0699            561   Initialize_State_Display:
0699            562   
0699            563       ;***clear the screen and set new display***
0699 7401       564            mov a, #0x01
069B 120083     564            lcall ?WriteCommand
069E C002       565            push AR2
06A0 7A02       565            mov R2, #2
06A2 120039     565            lcall ?Wait_Milli_Seconds
06A5 D002       565            pop AR2
06A7            566       
06A7 C0E0       567            push acc
06A9 7401       567            mov a, #1
06AB 14         567            dec a
06AC 1200BF     567            lcall ?Set_Cursor_1 ; Select column and row
06AF D0E0       567            pop acc
06B1 C083       568            push dph
06B3 C082       568            push dpl
06B5 C0E0       568            push acc
06B7 900404     568            mov dptr, #time
06BA 1200B2     568            lcall ?Send_Constant_String
06BD D0E0       568            pop acc
06BF D082       568            pop dpl
06C1 D083       568            pop dph
06C3            569            
06C3 C0E0       570            push acc
06C5 7406       570            mov a, #6
06C7 14         570            dec a
06C8 1200BF     570            lcall ?Set_Cursor_1 ; Select column and row
06CB D0E0       570            pop acc
06CD C083       571            push dph
06CF C082       571            push dpl
06D1 C0E0       571            push acc
06D3 900409     571            mov dptr, #colon
06D6 1200B2     571            lcall ?Send_Constant_String
06D9 D0E0       571            pop acc
06DB D082       571            pop dpl
06DD D083       571            pop dph
06DF            572      
06DF C0E0       573            push acc
06E1 740A       573            mov a, #10
06E3 14         573            dec a
06E4 1200BF     573            lcall ?Set_Cursor_1 ; Select column and row
06E7 D0E0       573            pop acc
06E9 C083       574            push dph
06EB C082       574            push dpl
06ED C0E0       574            push acc
06EF 90040B     574            mov dptr, #temp
06F2 1200B2     574            lcall ?Send_Constant_String
06F5 D0E0       574            pop acc
06F7 D082       574            pop dpl
06F9 D083       574            pop dph
06FB            575       
06FB C0E0       576            push acc
06FD 7401       576            mov a, #1
06FF 14         576            dec a
0700 1200BD     576            lcall ?Set_Cursor_2 ; Select column and row
0703 D0E0       576            pop acc
0705 C083       577            push dph
0707 C082       577            push dpl
0709 C0E0       577            push acc
070B 9003FD     577            mov dptr, #state
070E 1200B2     577            lcall ?Send_Constant_String
0711 D0E0       577            pop acc
0713 D082       577            pop dpl
0715 D083       577            pop dph
0717 22         578   ret
0718            579   
0718            580   Update_Display:
0718 C0E0       581            push acc
071A 7405       581            mov a, #5
071C 14         581            dec a
071D 1200BF     581            lcall ?Set_Cursor_1 ; Select column and row
0720 D0E0       581            pop acc
0722 C000       582       push ar0
0724 A839       582       mov r0, Run_time_minutes
0726 120670     582       lcall ?Display_lower_BCD
0729 D000       582       pop ar0
072B C0E0       583            push acc
072D 7407       583            mov a, #7
072F 14         583            dec a
0730 1200BF     583            lcall ?Set_Cursor_1 ; Select column and row
0733 D0E0       583            pop acc
0735 C000       584            push ar0
0737 A838       584            mov r0, Run_time_seconds
0739 1200C4     584            lcall ?Display_BCD
073C D000       584            pop ar0
073E            585       ;Set_Cursor(1,14)
073E            586       ;mov a, Temp_oven
073E            587       ;SendToLCD(Temp_oven)
073E 22         588   ret
073F            589   
073F            590   State0_display:
073F C0E0       591            push acc
0741 7401       591            mov a, #1
0743 14         591            dec a
0744 1200BF     591            lcall ?Set_Cursor_1 ; Select column and row
0747 D0E0       591            pop acc
0749 C083       592            push dph
074B C082       592            push dpl
074D C0E0       592            push acc
074F 9003E7     592            mov dptr, #STemp
0752 1200B2     592            lcall ?Send_Constant_String
0755 D0E0       592            pop acc
0757 D082       592            pop dpl
0759 D083       592            pop dph
075B C0E0       593            push acc
075D 7406       593            mov a, #6
075F 14         593            dec a
0760 1200BF     593            lcall ?Set_Cursor_1 ; Select column and row
0763 D0E0       593            pop acc
0765 E534       594       mov a, Temp_soak
0767 12067D     595       lcall SendToLCD
076A            596       
076A C0E0       597            push acc
076C 740A       597            mov a, #10
076E 14         597            dec a
076F 1200BF     597            lcall ?Set_Cursor_1 ; Select column and row
0772 D0E0       597            pop acc
0774 C083       598            push dph
0776 C082       598            push dpl
0778 C0E0       598            push acc
077A 9003ED     598            mov dptr, #STime
077D 1200B2     598            lcall ?Send_Constant_String
0780 D0E0       598            pop acc
0782 D082       598            pop dpl
0784 D083       598            pop dph
0786 C0E0       599            push acc
0788 740E       599            mov a, #14
078A 14         599            dec a
078B 1200BF     599            lcall ?Set_Cursor_1 ; Select column and row
078E D0E0       599            pop acc
0790 E535       600       mov a, Time_soak
0792 12067D     601            lcall SendToLCD
0795            602       ;Display_BCD(Time_soak)
0795            603   
0795            604       ;Displays Reflow Temp and Time
0795 C0E0       605            push acc
0797 7401       605            mov a, #1
0799 14         605            dec a
079A 1200BD     605            lcall ?Set_Cursor_2 ; Select column and row
079D D0E0       605            pop acc
079F C083       606            push dph
07A1 C082       606            push dpl
07A3 C0E0       606            push acc
07A5 9003F2     606            mov dptr, #RTemp
07A8 1200B2     606            lcall ?Send_Constant_String
07AB D0E0       606            pop acc
07AD D082       606            pop dpl
07AF D083       606            pop dph
07B1 C0E0       607            push acc
07B3 7406       607            mov a, #6
07B5 14         607            dec a
07B6 1200BD     607            lcall ?Set_Cursor_2 ; Select column and row
07B9 D0E0       607            pop acc
07BB E536       608       mov a, Temp_refl
07BD 12067D     609       lcall SendToLCD
07C0            610       
07C0 C0E0       611            push acc
07C2 740A       611            mov a, #10
07C4 14         611            dec a
07C5 1200BD     611            lcall ?Set_Cursor_2 ; Select column and row
07C8 D0E0       611            pop acc
07CA C083       612            push dph
07CC C082       612            push dpl
07CE C0E0       612            push acc
07D0 9003F8     612            mov dptr, #RTime
07D3 1200B2     612            lcall ?Send_Constant_String
07D6 D0E0       612            pop acc
07D8 D082       612            pop dpl
07DA D083       612            pop dph
07DC C0E0       613            push acc
07DE 740E       613            mov a, #14
07E0 14         613            dec a
07E1 1200BD     613            lcall ?Set_Cursor_2 ; Select column and row
07E4 D0E0       613            pop acc
07E6 E537       614       mov a, Time_refl
07E8 12067D     615            lcall SendToLCD
07EB 22         616   ret
07EC            617   
07EC            618   Display_3_digit_BCD:
07EC C0E0       619            push acc
07EE 740E       619            mov a, #14
07F0 14         619            dec a
07F1 1200BF     619            lcall ?Set_Cursor_1 ; Select column and row
07F4 D0E0       619            pop acc
07F6 C000       620       push ar0
07F8 A845       620       mov r0, bcd+1
07FA 120670     620       lcall ?Display_lower_BCD
07FD D000       620       pop ar0
07FF C000       621            push ar0
0801 A844       621            mov r0, bcd+0
0803 1200C4     621            lcall ?Display_BCD
0806 D000       621            pop ar0
0808 22         622   ret
0809            623   
0809            624   
0809            625   
0809            626   ;The following functions store and restore the values--------------------------------------------------------------------------
                627   loadbyte mac
                628       mov a, %0
                629       movx @dptr, a
                630       inc dptr
                631   endmac
0809            632   
0809            633   Save_Configuration:
0809 C0A8       634       push IE ; Save the current state of bit EA in the stack
080B C2AF       635       clr EA ; Disable interrupts
080D 75D108     636       mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
0810 907F80     637       mov dptr, #0x7f80 ; Last page of flash memory
0813            638       ; Save variables
0813 E534       639       mov a, temp_soak
0815 F0         639       movx @dptr, a
0816 A3         639       inc dptr ; @0x7f80
0817 E535       640       mov a, time_soak
0819 F0         640       movx @dptr, a
081A A3         640       inc dptr ; @0x7f81
081B E536       641       mov a, temp_refl
081D F0         641       movx @dptr, a
081E A3         641       inc dptr ; @0x7f82
081F E537       642       mov a, time_refl
0821 F0         642       movx @dptr, a
0822 A3         642       inc dptr ; @0x7f83
0823 7455       643       mov a, #0x55
0825 F0         643       movx @dptr, a
0826 A3         643       inc dptr ; First key value @0x7f84
0827 74AA       644       mov a, #0xAA
0829 F0         644       movx @dptr, a
082A A3         644       inc dptr ; Second key value @0x7f85
082B 75D100     645       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0) 
082E 43D240     646       orl EECON, #0b01000000 ; Enable auto-erase on next write sequence  
0831 75D150     647       mov FCON, #0x50 ; Write trigger first byte
0834 75D1A0     648       mov FCON, #0xA0 ; Write trigger second byte
0837            649       ; CPU idles until writing of flash completes.
0837 75D100     650       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
083A 53D2BF     651       anl EECON, #0b10111111 ; Disable auto-erase
083D D0A8       652       pop IE ; Restore the state of bit EA from the stack
083F 22         653   ret
0840            654   
                655   getbyte mac
                656       clr a
                657       movc a, @a+dptr
                658       mov %0, a
                659       inc dptr
                660   endmac
0840            661   
0840            662   Load_Configuration:
0840 907F84     663       mov dptr, #0x7f84 ; First key value location.
0843 E4         664       clr a
0844 93         664       movc a, @a+dptr
0845 F8         664       mov R0, a
0846 A3         664       inc dptr ; 0x7f84 should contain 0x55
0847 B8551F     665       cjne R0, #0x55, Load_Defaults
084A E4         666       clr a
084B 93         666       movc a, @a+dptr
084C F8         666       mov R0, a
084D A3         666       inc dptr ; 0x7f85 should contain 0xAA
084E B8AA18     667       cjne R0, #0xAA, Load_Defaults
0851            668   ; Keys are good.  Get stored values.
0851 907F80     669       mov dptr, #0x7f80
0854 E4         670       clr a
0855 93         670       movc a, @a+dptr
0856 F534       670       mov Temp_soak, a
0858 A3         670       inc dptr ; 0x7f80
0859 E4         671       clr a
085A 93         671       movc a, @a+dptr
085B F535       671       mov Time_soak, a
085D A3         671       inc dptr ; 0x7f81
085E E4         672       clr a
085F 93         672       movc a, @a+dptr
0860 F536       672       mov Temp_refl, a
0862 A3         672       inc dptr ; 0x7f82
0863 E4         673       clr a
0864 93         673       movc a, @a+dptr
0865 F537       673       mov Time_refl, a
0867 A3         673       inc dptr ; 0x7f83
0868 22         674   ret
0869            675   
0869            676   Load_Defaults:
0869 753482     677       mov Temp_soak, #130 ; Soak Tmp Range is 130-170
086C 75353C     678       mov Time_soak, #0x3C ; Range 60-90 seconds
086F 7536DC     679       mov Temp_refl, #220 ; Range 220-240
0872 75371E     680       mov Time_refl, #0x1E ; Range 30-45 seconds
0875 22         681       ret 
0876            682   ;-------------------------------------------------------------------------------------------------------------------------------
0876            683   ;off state
0876            684   
0876            685   OFF_STATE:
0876            686       ;**CLEAR SCREEN**
0876 7401       687            mov a, #0x01
0878 120083     687            lcall ?WriteCommand
087B            688       ;**TURN OFF OVEN
087B C287       689       clr OVEN_POWER
087D            690       ;OFF_STATE1:
087D            691       
087D 20C5FD     692       jb POWER_BUTTON, $ ; loop while the button is not pressed
0880 C002       693            push AR2
0882 7A32       693            mov R2, #50
0884 120039     693            lcall ?Wait_Milli_Seconds
0887 D002       693            pop AR2 ; debounce time
0889 20C5EA     694            jb POWER_BUTTON, OFF_STATE ; it was a bounce, try again
088C 30C5FD     695            jnb POWER_BUTTON, $ ; loop while the button is pressed
088F 0209DB     696       ljmp main
0892 22         697   ret
0893            698   ;-------------------------------------------------------------------------------------------------------------------------------
0893            699   
0893            700   ;***CHECK TEMPERATURE BY READING VOLTAGE AND CONVERTING
0893            701   Check_Temp:
0893            702       
0893 30006E     703       jnb one_seconds_flag, Check_Temp_done
0896 C200       704       clr one_seconds_flag
0898            705       
0898 C280       706       clr CE_ADC
089A 7801       707            mov R0, #00000001B ; Start bit:1
089C 12047B     708            lcall DO_SPI_G
089F 7880       709            mov R0, #10000000B ; Single ended, read channel 0
08A1 12047B     710            lcall DO_SPI_G
08A4 E9         711            mov a, R1          ; R1 contains bits 8 and 9
08A5 5403       712            anl a, #00000011B  ; We need only the two least significant bits
08A7 F54A       713            mov Result+1, a    ; Save result high.
08A9 7855       714            mov R0, #55H ; It doesn't matter what we transmit...
08AB 12047B     715            lcall DO_SPI_G
08AE 8949       716            mov Result, R1     ; R1 contains bits 0 to 7.  Save result low.
08B0 D280       717            setb CE_ADC
08B2            718   
08B2 C002       719            push AR2
08B4 7A0A       719            mov R2, #10
08B6 120039     719            lcall ?Wait_Milli_Seconds
08B9 D002       719            pop AR2
08BB            720       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
08BB 85493C     721            mov x+0, result+0
08BE 854A3D     722            mov x+1, result+1
08C1 753E00     723            mov x+2, #0
08C4 753F00     724            mov x+3, #0
08C7            725            
08C7            726       
08C7            727           ;Load_x(0)
08C7            728           ;mov a, #50
08C7            729       ;calculate_ave:     
08C7            730           ;mov y+0, result+0
08C7            731                ;mov y+1, result+1
08C7            732                ;mov y+2, #0
08C7            733                ;mov y+3, #0
08C7            734       ;djnz a, calculate_ave
08C7            735   
08C7            736   
08C7            737   
08C7            738   
08C7            739       ;Load_y(22)
08C7            740       ;lcall add32
08C7            741   
08C7            742   ;Check_Temp_done_2:
08C7            743       ;jnb one_seconds_flag, Check_Temp_done
08C7            744       ;mov a, result+1
08C7            745       ;Set_Cursor(1,14)
08C7            746       ;lcall SendToLCD 
08C7            747       ;Set_Cursor(1,14)
08C7            748       ;mov a, x+0
08C7            749       ;lcall SendToLCD
08C7            750       ;mov Temp_oven, a
08C7            751       
08C7            752       ;mov a, States
08C7            753       ;cjne a, #0, Display_Temp_BCD
08C7            754       ;sjmp Send_Temp_Port
08C7            755            
08C7            756       ; The 4-bytes of x have the temperature in binary
08C7            757   Display_Temp_BCD:
08C7 1200F0     758            lcall hex2bcd ; converts binary in x to BCD in BCD
08CA            759   
08CA 1207EC     760       lcall Display_3_digit_BCD
08CD            761   
08CD            762   Send_Temp_Port:
08CD C000       763       push ar0
08CF A848       763       mov r0, bcd+4
08D1 1200DA     763       lcall ?Send_BCD
08D4 D000       763       pop ar0
08D6            763   
08D6 C000       764       push ar0
08D8 A847       764       mov r0, bcd+3
08DA 1200DA     764       lcall ?Send_BCD
08DD D000       764       pop ar0
08DF            764   
08DF C000       765       push ar0
08E1 A846       765       mov r0, bcd+2
08E3 1200DA     765       lcall ?Send_BCD
08E6 D000       765       pop ar0
08E8            765   
08E8 C000       766       push ar0
08EA A845       766       mov r0, bcd+1
08EC 1200DA     766       lcall ?Send_BCD
08EF D000       766       pop ar0
08F1            766   
08F1 C000       767       push ar0
08F3 A844       767       mov r0, bcd+0
08F5 1200DA     767       lcall ?Send_BCD
08F8 D000       767       pop ar0
08FA            767   
08FA 740D       768            mov a, #'\r'
08FC 120505     769            lcall putchar
08FF 740A       770            mov a, #'\n'
0901 120505     771            lcall putchar
0904            772   Check_Temp_done:
0904 22         773       ret
0905            774       
0905            775   
0905            776   ;-------------------------------------------------------------------------------------------------------------------------------
0905            777   
0905            778   ;Time wait
0905            779   
0905            780   Wait_One_Second:
0905 C002       781            push AR2
0907 7AFA       781            mov R2, #250
0909 120039     781            lcall ?Wait_Milli_Seconds
090C D002       781            pop AR2
090E C002       782            push AR2
0910 7AFA       782            mov R2, #250
0912 120039     782            lcall ?Wait_Milli_Seconds
0915 D002       782            pop AR2
0917 C002       783            push AR2
0919 7AFA       783            mov R2, #250
091B 120039     783            lcall ?Wait_Milli_Seconds
091E D002       783            pop AR2
0920 C002       784            push AR2
0922 7AFA       784            mov R2, #250
0924 120039     784            lcall ?Wait_Milli_Seconds
0927 D002       784            pop AR2
0929 22         785   ret
092A            786   
092A            787   ; ==================================================================================================
092A            788   
092A            789   ;-------------------------------------;
092A            790   ; ISR for Timer 1.  Used to playback  ;
092A            791   ; the WAV file stored in the SPI      ;
092A            792   ; flash memory.                       ;
092A            793   ;-------------------------------------;
092A            794   Timer1_ISR:
092A            795            ; The registers used in the ISR must be saved in the stack
092A C0E0       796            push acc
092C C0D0       797            push psw
092E            798            
092E            799            ; Check if the play counter is zero.  If so, stop playing sound.
092E E54B       800            mov a, w+0
0930 454C       801            orl a, w+1
0932 454D       802            orl a, w+2
0934 601E       803            jz stop_playing
0936            804            
0936            805            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0936 74FF       806            mov a, #0xff
0938 154B       807            dec w+0
093A B54B07     808            cjne a, w+0, keep_playing
093D 154C       809            dec w+1
093F B54C02     810            cjne a, w+1, keep_playing
0942 154D       811            dec w+2
0944            812            
0944            813   keep_playing:
0944 D2A6       814            setb SPEAKER
0946 120494     815            lcall Send_SPI ; Read the next byte from the SPI Flash...
0949 F580       816            mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
094B 2480       817            add a, #0x80
094D F5AD       818            mov DADH, a ; Output to DAC. DAC output is pin P2.3
094F 43A440     819            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0952 800A       820            sjmp Timer1_ISR_Done
0954            821   
0954            822   stop_playing:
0954 C28E       823            clr TR1 ; Stop timer 1
0956            824            ;setb FLASH_CE  ; Disable SPI Flash
0956 C2A6       825            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
0958 75AD80     826            mov DADH, #0x80 ; middle of range
095B 43A440     827            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
095E            828   
095E            829   Timer1_ISR_Done:         
095E D0D0       830            pop psw
0960 D0E0       831            pop acc
0962 32         832            reti
0963            833   ; ==================================================================================================
0963            834   
0963            835   ;---------------------------------;
0963            836   ; Routine to initialize the ISR   ;
0963            837   ; for timer 2                     ;
0963            838   ;---------------------------------;
0963            839   Timer2_init:
0963 75C800     840       mov T2CON, #0
0966 75CDA9     841       mov TH2, #high(TIMER2_RELOAD)
0969 75CC9A     842       mov TL2, #low(TIMER2_RELOAD)
096C            843   
096C 75CBA9     844       mov RCAP2H, #high(TIMER2_RELOAD)
096F 75CA9A     845       mov RCAP2L, #low(TIMER2_RELOAD)
0972            846   
0972 E4         847       clr a
0973 F530       848       mov Count1ms+0, a
0975 F531       849       mov Count1ms+1, a
0977 F532       850       mov Count5sec , a
0979 D2AD       851       setb ET2
097B D2CA       852       setb TR2
097D C202       853       clr enable_clk
097F 22         854       ret
0980            855   
0980            856   ;---------------------------------;
0980            857   ; ISR for timer 2                 ;
0980            858   ;---------------------------------;
0980            859   Timer2_ISR:
0980 C2CF       860       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0982 B290       861       cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0984            862            
0984            863            ; The two registers used in the ISR must be saved in the stack
0984 C0E0       864       push acc
0986 C0D0       865       push psw
0988            866            
0988            867            ; Increment the 16-bit one mili second counter
0988 0530       868            inc Count1ms+0    ; Increment the low 8-bits first
098A E530       869            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
098C 7002       870            jnz Inc_Done
098E 0531       871            inc Count1ms+1
0990            872   
0990            873   Inc_Done:
0990            874   
0990            875   ;**Oven Power Output-------------------
0990            876       ; Do the PWM thing
0990            877            ; Check if Count1ms > pwm_ratio (this is a 16-bit compare)
0990 C3         878            clr c
0991 E54E       879            mov a, pwm_ratio+0
0993 9530       880            subb a, Count1ms+0
0995 E54F       881            mov a, pwm_ratio+1
0997 9531       882            subb a, Count1ms+1
0999            883            ; if Count1ms > pwm_ratio  the carry is set.  Just copy the carry to the pwm output pin:
0999 9290       884            mov PWM_OUTPUT, c
099B            885   ;**----------------------------------
099B            886            ; Check if one second has passed
099B E530       887            mov a, Count1ms+0
099D B4E836     888            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
09A0 E531       889            mov a, Count1ms+1
09A2 B40331     890            cjne a, #high(1000), Timer2_ISR_done
09A5            891            
09A5            892            ; 1000 milliseconds have passed.  Set a flag so the main program knows
09A5 D200       893            setb one_seconds_flag ; Let the main program know one second had passed
09A7            894       
09A7 0532       895       inc Count5sec
09A9 E532       896       mov a, Count5sec
09AB B40505     897       cjne a, #5, Set_5sec_flag_done
09AE D201       898       setb five_seconds_flag
09B0 E4         899       clr a
09B1 F532       900       mov Count5sec, a
09B3            901       
09B3            902   Set_5sec_flag_done:
09B3 E4         903            clr a
09B4 F530       904            mov Count1ms+0, a
09B6 F531       905            mov Count1ms+1, a
09B8            906   
09B8 30021B     907       jnb enable_clk, Timer2_ISR_done ;if the clk is enabled, increment the second. Otherwise skip
09BB            908   ; Increment the run time counter and state time counter
09BB E538       909            mov a, Run_time_seconds
09BD 2401       910            add a, #0x01
09BF D4         911            da a
09C0 F538       912       mov Run_time_seconds, a
09C2            913       ;check sec overflow
09C2 B4600A     914       cjne a, #0x60, Check_sec_overflow_done
09C5 753800     915       mov Run_time_seconds, #0x00
09C8 E539       916       mov a, Run_time_minutes ;inc min
09CA 2401       917       add a, #1
09CC D4         918       da a
09CD F539       919       mov Run_time_minutes, a
09CF            920   Check_sec_overflow_done:
09CF E53A       921            mov a, State_time
09D1 2401       922            add a, #0x01
09D3 D4         923            da a
09D4 F53A       924            mov State_time, a
09D6            925   Timer2_ISR_done:
09D6 D0D0       926            pop psw
09D8 D0E0       927            pop acc
09DA 32         928            reti
09DB            929   
09DB            930   
09DB            931   ; ==================================================================================================
09DB            932   
09DB            933   main:
09DB 75817F     934       mov SP, #0x7F
09DE 120963     935       lcall Timer2_Init
09E1            936       ;lcall INI_SPI
09E1 120088     937       lcall LCD_4BIT
09E4 1204ED     938       lcall InitSerialPort
09E7            939       ; In case you decide to use the pins of P0, configure the port in bidirectional mode. Can be ignored
09E7 75E600     940       mov P0M0, #0
09EA 75E700     941       mov P0M1, #0
09ED D2AF       942       setb EA   ;Enable global enterupt
09EF            943   
09EF 120840     944       lcall Load_Configuration
09F2            945   
09F2 12060E     946       lcall PLAYBACK_TEMP
09F5            947   
09F5            948       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
09F5 754E00     949            mov pwm_ratio+0, #low(0)
09F8 754F00     950            mov pwm_ratio+1, #high(0)
09FB 753300     951       mov States, #0
09FE            952       
09FE            953   state0: ; idle
09FE            954       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
09FE 754E00     955            mov pwm_ratio+0, #low(0)
0A01 754F00     956            mov pwm_ratio+1, #high(0)
0A04            957       ;mov States, #0
0A04            958   
0A04            959   ;***initial parameters displayed***
0A04            960       
0A04            961       ;Displays Soak Temp and Time
0A04 12073F     962       lcall State0_display
0A07            963       ;check power on
0A07 12057D     964       lcall CHECK_POWER
0A0A            965       ; check the parameters being pressed
0A0A 12050D     966       lcall CHECK_STIME
0A0D 120529     967       lcall CHECK_STEMP
0A10 120545     968       lcall CHECK_RTIME
0A13 120561     969       lcall CHECK_RTEMP
0A16 120809     970       lcall Save_Configuration
0A19            971       
0A19            972       ;lcall Check_Temp
0A19            973   
0A19            974   
0A19            975   
0A19            976   
0A19            977   
0A19 2093E2     978       jb NEXT_STATE_BUTTON, state0
0A1C C002       979            push AR2
0A1E 7A32       979            mov R2, #50
0A20 120039     979            lcall ?Wait_Milli_Seconds
0A23 D002       979            pop AR2 ; debounce time
0A25 2093D6     980            jb NEXT_STATE_BUTTON, state0 ; if button not pressed, loop
0A28 3093FD     981            jnb NEXT_STATE_BUTTON, $ 
0A2B            982   state0_done:
0A2B 753301     983       mov States, #1
0A2E 753A00     984       mov State_time, #0
0A31 D202       985       setb enable_clk
0A33            986      
0A33            987        
0A33            988   
0A33            989   state1_beginning:
0A33            990       
0A33            991       ;Start Run Time
0A33 753800     992       mov Run_time_seconds, #0 ; time starts at 0:00
0A36 753900     993       mov Run_time_minutes, #0
0A39            994   
0A39            995       ;***clear the screen and set new display***
0A39 120699     996       lcall Initialize_State_Display
0A3C C0E0       997            push acc
0A3E 7407       997            mov a, #7
0A40 14         997            dec a
0A41 1200BD     997            lcall ?Set_Cursor_2 ; Select column and row
0A44 D0E0       997            pop acc
0A46 C083       998            push dph
0A48 C082       998            push dpl
0A4A C0E0       998            push acc
0A4C 90044E     998            mov dptr, #Ramp2Soak
0A4F 1200B2     998            lcall ?Send_Constant_String
0A52 D0E0       998            pop acc
0A54 D082       998            pop dpl
0A56 D083       998            pop dph
0A58            998   ; displays current state
0A58            999   
0A58           1000       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0A58 754EE8    1001            mov pwm_ratio+0, #low(1000)
0A5B 754F03    1002            mov pwm_ratio+1, #high(1000)
0A5E           1003       
0A5E           1004   
0A5E           1005   state1: ; ramp to soak
0A5E           1006       
0A5E           1007       
0A5E           1008       ;check power on
0A5E 12057D    1009       lcall CHECK_POWER
0A61           1010       ;Update Time and Temp
0A61 120718    1011       lcall Update_Display
0A64           1012       ;lcall Check_Temp
0A64           1013   
0A64           1014       ;jnb one_seconds_flag, Check_Temp_done1
0A64           1015       ;clr one_seconds_flag
0A64           1016       
0A64 C280      1017       clr CE_ADC
0A66 7801      1018            mov R0, #00000001B ; Start bit:1
0A68 12047B    1019            lcall DO_SPI_G
0A6B 7880      1020            mov R0, #10000000B ; Single ended, read channel 0
0A6D 12047B    1021            lcall DO_SPI_G
0A70 E9        1022            mov a, R1          ; R1 contains bits 8 and 9
0A71 5403      1023            anl a, #00000011B  ; We need only the two least significant bits
0A73 F54A      1024            mov Result+1, a    ; Save result high.
0A75 7855      1025            mov R0, #55H ; It doesn't matter what we transmit...
0A77 12047B    1026            lcall DO_SPI_G
0A7A 8949      1027            mov Result, R1     ; R1 contains bits 0 to 7.  Save result low.
0A7C D280      1028            setb CE_ADC
0A7E           1029   
0A7E C002      1030            push AR2
0A80 7A0A      1030            mov R2, #10
0A82 120039    1030            lcall ?Wait_Milli_Seconds
0A85 D002      1030            pop AR2
0A87           1031       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
0A87 85493C    1032            mov x+0, result+0
0A8A 854A3D    1033            mov x+1, result+1
0A8D 753E00    1034            mov x+2, #0
0A90 753F00    1035            mov x+3, #0
0A93           1036            
0A93           1037       
0A93 753C00    1038            mov x+0, #low (0 % 0x10000) 
0A96 753D00    1038            mov x+1, #high(0 % 0x10000) 
0A99 753E00    1038            mov x+2, #low (0 / 0x10000) 
0A9C 753F00    1038            mov x+3, #high(0 / 0x10000) 
0A9F 755032    1039           mov average_count, #50
0AA2           1040       calculate_ave:     
0AA2 854940    1041           mov y+0, result+0
0AA5 854A41    1042                mov y+1, result+1
0AA8 754200    1043                mov y+2, #0
0AAB 754300    1044                mov y+3, #0
0AAE C002      1045            push AR2
0AB0 7A0A      1045            mov R2, #10
0AB2 120039    1045            lcall ?Wait_Milli_Seconds
0AB5 D002      1045            pop AR2
0AB7 D550E8    1046       djnz average_count, calculate_ave
0ABA 754064    1047            mov y+0, #low (100 % 0x10000) 
0ABD 754100    1047            mov y+1, #high(100 % 0x10000) 
0AC0 754200    1047            mov y+2, #low (100 / 0x10000) 
0AC3 754300    1047            mov y+3, #high(100 / 0x10000) 
0AC6 1202F7    1048       lcall div32
0AC9           1049   
0AC9           1050       ; Multiply by 410
0AC9 75409A    1051            mov y+0, #low (410 % 0x10000) 
0ACC 754101    1051            mov y+1, #high(410 % 0x10000) 
0ACF 754200    1051            mov y+2, #low (410 / 0x10000) 
0AD2 754300    1051            mov y+3, #high(410 / 0x10000) 
0AD5 12026A    1052            lcall mul32
0AD8           1053            ; Divide result by 1023
0AD8 7540FF    1054            mov y+0, #low (1023 % 0x10000) 
0ADB 754103    1054            mov y+1, #high(1023 % 0x10000) 
0ADE 754200    1054            mov y+2, #low (1023 / 0x10000) 
0AE1 754300    1054            mov y+3, #high(1023 / 0x10000) 
0AE4 1202F7    1055            lcall div32
0AE7           1056            ; Subtract 273 + 5 from result to get temperature while accounting for offset
0AE7 754016    1057            mov y+0, #low (278 % 0x10000) 
0AEA 754101    1057            mov y+1, #high(278 % 0x10000) 
0AED 754200    1057            mov y+2, #low (278 / 0x10000) 
0AF0 754300    1057            mov y+3, #high(278 / 0x10000) 
0AF3 1201D6    1058            lcall sub32
0AF6           1059   
0AF6           1060   
0AF6           1061   
0AF6           1062   
0AF6           1063       ;Load_y(22)
0AF6           1064       ;lcall add32
0AF6           1065   
0AF6           1066   ;Check_Temp_done_2:
0AF6           1067       ;jnb one_seconds_flag, Check_Temp_done
0AF6           1068       ;mov a, result+1
0AF6           1069       ;Set_Cursor(1,14)
0AF6           1070       ;lcall SendToLCD 
0AF6           1071       ;Set_Cursor(1,14)
0AF6           1072       ;mov a, x+0
0AF6           1073       ;lcall SendToLCD
0AF6           1074       ;mov Temp_oven, a
0AF6           1075       
0AF6           1076       ;mov a, States
0AF6           1077       ;cjne a, #0, Display_Temp_BCD
0AF6           1078       ;sjmp Send_Temp_Port
0AF6           1079            
0AF6           1080       ; The 4-bytes of x have the temperature in binary
0AF6           1081   Display_Temp_BCD1:
0AF6 1200F0    1082            lcall hex2bcd ; converts binary in x to BCD in BCD
0AF9           1083   
0AF9 1207EC    1084       lcall Display_3_digit_BCD
0AFC           1085   
0AFC 8003      1086   sjmp Send_Temp_Port1
0AFE           1087   
0AFE           1088   state1_1:
0AFE 020A5E    1089       ljmp state1
0B01           1090   
0B01           1091   Send_Temp_Port1:
0B01           1092       ;Send_BCD(bcd+4)
0B01           1093       ;Send_BCD(bcd+3)
0B01           1094       ;Send_BCD(bcd+2)
0B01 C000      1095       push ar0
0B03 A845      1095       mov r0, bcd+1
0B05 1200DA    1095       lcall ?Send_BCD
0B08 D000      1095       pop ar0
0B0A           1095   
0B0A C000      1096       push ar0
0B0C A844      1096       mov r0, bcd+0
0B0E 1200DA    1096       lcall ?Send_BCD
0B11 D000      1096       pop ar0
0B13           1096   
0B13 740D      1097            mov a, #'\r'
0B15 120505    1098            lcall putchar
0B18 740A      1099            mov a, #'\n'
0B1A 120505    1100            lcall putchar
0B1D           1101   Check_Temp_done1:
0B1D           1102       
0B1D           1103   
0B1D           1104       ; check if temp is below 150 
0B1D           1105       ;MOV A, Temp_soak           
0B1D           1106       ;SUBB A, Temp_soak       
0B1D           1107       ;JNC state1_done    ; if greater, jump to state 2
0B1D           1108       ;JZ state1_done ; if equal to, jump to state 2
0B1D           1109       ;JC state1 ; if less than, go back to state1
0B1D           1110   
0B1D           1111   ;*Checking moving to states with buttons---- 
0B1D           1112   ;*Will remove after proper temperature reading----
0B1D           1113   
0B1D 2093DE    1114       jb NEXT_STATE_BUTTON, state1_1
0B20 C002      1115            push AR2
0B22 7A32      1115            mov R2, #50
0B24 120039    1115            lcall ?Wait_Milli_Seconds
0B27 D002      1115            pop AR2 ; debounce time
0B29 2093D2    1116            jb NEXT_STATE_BUTTON, state1_1 ; if button not pressed, loop
0B2C 3093FD    1117            jnb NEXT_STATE_BUTTON, $ 
0B2F           1118   
0B2F           1119   state1_done:
0B2F 753302    1120       mov States, #2
0B32           1121       ;set State_time = 0
0B32 8000      1122       sjmp state2_beginning
0B34           1123   
0B34           1124   ;OFF_STATE2:
0B34           1125       ;ljmp OFF_STATE
0B34           1126   
0B34           1127   ; preheat/soak
0B34           1128   state2_beginning: 
0B34 753A00    1129       mov State_time, #0x00 ;clear the state time
0B37           1130       ;***clear the screen and set new display***
0B37 120699    1131       lcall Initialize_State_Display
0B3A C0E0      1132            push acc
0B3C 7407      1132            mov a, #7
0B3E 14        1132            dec a
0B3F 1200BD    1132            lcall ?Set_Cursor_2 ; Select column and row
0B42 D0E0      1132            pop acc
0B44 C083      1133            push dph
0B46 C082      1133            push dpl
0B48 C0E0      1133            push acc
0B4A 900458    1133            mov dptr, #Soak
0B4D 1200B2    1133            lcall ?Send_Constant_String
0B50 D0E0      1133            pop acc
0B52 D082      1133            pop dpl
0B54 D083      1133            pop dph ;displays current state
0B56           1134   
0B56           1135       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
0B56 754EC8    1136            mov pwm_ratio+0, #low(200)
0B59 754F00    1137            mov pwm_ratio+1, #high(000)
0B5C           1138   
0B5C           1139   state2:
0B5C           1140       ;check power on
0B5C 12057D    1141       lcall CHECK_POWER
0B5F           1142       
0B5F           1143       ;Update Time and Temp
0B5F 120718    1144       lcall Update_Display
0B62           1145   
0B62           1146       ;Set_Cursor(1,14)
0B62           1147       ;mov a, Temp_oven
0B62           1148       ;lcall SendToLCD
0B62           1149   
0B62           1150       ;on
0B62           1151       ;setb OVEN_POWER
0B62           1152       ;lcall Wait_One_Second
0B62           1153       ;off
0B62           1154       ;clr OVEN_POWER
0B62           1155       ;mov r5, #0
0B62           1156   ;four_sec_loop:
0B62           1157       ; loop back to state2 if run time is less than soak time
0B62           1158    ;   mov a, Time_soak
0B62           1159     ;  subb a, State_time
0B62           1160      ; cjne a, #0, state2
0B62           1161       ;Set_Cursor(1,5)
0B62           1162            ;Display_BCD(Run_time_minutes)
0B62           1163       ;Set_Cursor(1,7)
0B62           1164       ;Send_Constant_String(#colon)
0B62           1165       ;Set_Cursor(1,8)
0B62           1166       ;Display_BCD(Run_time_seconds)
0B62           1167       ;Wait_Milli_Seconds(#250)
0B62           1168       ;inc r5
0B62           1169       ;cjne r5, #16, four_sec_loop
0B62           1170           
0B62           1171       
0B62           1172       ; loop back to state2 if run time is less than soak time
0B62           1173       ;mov a, Time_soak
0B62           1174       ;subb a, State_time
0B62           1175       ;cjne a, #0, state2
0B62           1176   
0B62           1177   ;*Checking moving to states with buttons---- 
0B62           1178   ;*Will remove after proper temperature reading----
0B62           1179   
0B62 2093F7    1180       jb NEXT_STATE_BUTTON, state2
0B65 C002      1181            push AR2
0B67 7A32      1181            mov R2, #50
0B69 120039    1181            lcall ?Wait_Milli_Seconds
0B6C D002      1181            pop AR2 ; debounce time
0B6E 2093EB    1182            jb NEXT_STATE_BUTTON, state2 ; if button not pressed, loop
0B71 3093FD    1183            jnb NEXT_STATE_BUTTON, $ 
0B74           1184       
0B74           1185   state2_done:
0B74 753A00    1186       mov State_time, #0
0B77 020B7A    1187       ljmp state3_beginning
0B7A           1188   
0B7A           1189   ; ramp to peak
0B7A           1190   state3_beginning:
0B7A D287      1191       setb OVEN_POWER ;turn power on 100%
0B7C           1192   
0B7C           1193       ;***clear the screen and set new display***
0B7C 120699    1194       lcall Initialize_State_Display
0B7F C0E0      1195            push acc
0B81 7407      1195            mov a, #7
0B83 14        1195            dec a
0B84 1200BD    1195            lcall ?Set_Cursor_2 ; Select column and row
0B87 D0E0      1195            pop acc
0B89 C083      1196            push dph
0B8B C082      1196            push dpl
0B8D C0E0      1196            push acc
0B8F 90045D    1196            mov dptr, #Ramp2Peak
0B92 1200B2    1196            lcall ?Send_Constant_String
0B95 D0E0      1196            pop acc
0B97 D082      1196            pop dpl
0B99 D083      1196            pop dph
0B9B           1197   
0B9B           1198       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0B9B 754EE8    1199            mov pwm_ratio+0, #low(1000)
0B9E 754F03    1200            mov pwm_ratio+1, #high(1000)
0BA1           1201   
0BA1           1202   state3: 
0BA1           1203       ;check power on
0BA1 12057D    1204       lcall CHECK_POWER
0BA4           1205       
0BA4           1206       
0BA4           1207       ;Update Time and Temp
0BA4 120718    1208       lcall Update_Display
0BA7           1209       
0BA7           1210       ;mov a, Temp_oven
0BA7           1211       ;subb a, Temp_refl 
0BA7           1212       ;JNC state3_done    ; if greater, jump to state 4
0BA7           1213       ;JZ state3_done ; if equal to, jump to state 4
0BA7           1214       ;JC state3 ; if less than, go back to state3
0BA7           1215       
0BA7 2093F7    1216   jb NEXT_STATE_BUTTON, state3
0BAA C002      1217            push AR2
0BAC 7A32      1217            mov R2, #50
0BAE 120039    1217            lcall ?Wait_Milli_Seconds
0BB1 D002      1217            pop AR2 ; debounce time
0BB3 2093EB    1218            jb NEXT_STATE_BUTTON, state3 ; if button not pressed, loop
0BB6 3093FD    1219            jnb NEXT_STATE_BUTTON, $
0BB9           1220   
0BB9           1221   state3_done:
0BB9 753A00    1222       mov State_time, #0
0BBC 020BBF    1223       ljmp state4_beginning
0BBF           1224   
0BBF           1225   
0BBF           1226   ; reflow 
0BBF           1227   state4_beginning:
0BBF           1228       ;***clear the screen and set new display***
0BBF 120699    1229       lcall Initialize_State_Display
0BC2 C0E0      1230            push acc
0BC4 7407      1230            mov a, #7
0BC6 14        1230            dec a
0BC7 1200BD    1230            lcall ?Set_Cursor_2 ; Select column and row
0BCA D0E0      1230            pop acc
0BCC C083      1231            push dph
0BCE C082      1231            push dpl
0BD0 C0E0      1231            push acc
0BD2 900467    1231            mov dptr, #Reflow
0BD5 1200B2    1231            lcall ?Send_Constant_String
0BD8 D0E0      1231            pop acc
0BDA D082      1231            pop dpl
0BDC D083      1231            pop dph
0BDE           1232   
0BDE           1233       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
0BDE 754EC8    1234            mov pwm_ratio+0, #low(200)
0BE1 754F00    1235            mov pwm_ratio+1, #high(000)
0BE4           1236   
0BE4           1237   
0BE4           1238   state4:
0BE4           1239       ;check power on
0BE4 12057D    1240       lcall CHECK_POWER
0BE7           1241       ;Update Time and Temp
0BE7 120718    1242       lcall Update_Display
0BEA           1243   
0BEA           1244       ;on
0BEA           1245       ;setb OVEN_POWER
0BEA           1246       ;lcall Wait_One_Second
0BEA           1247       ;off
0BEA           1248       ;clr OVEN_POWER
0BEA           1249       ;mov r5, #0
0BEA           1250       ;four_sec_loop2:
0BEA           1251           ; loop back to state2 if run time is less than soak time
0BEA           1252       ;    mov a, Time_refl
0BEA           1253       ;    subb a, State_time
0BEA           1254       ;   cjne a, #0, state4
0BEA           1255       ;    Set_Cursor(1, 5)
0BEA           1256            ;    Display_BCD(Run_time_minutes)
0BEA           1257       ;    Set_Cursor(1,7)
0BEA           1258       ;    Display_BCD(Run_time_seconds)
0BEA           1259       ;    Wait_Milli_Seconds(#250)
0BEA           1260   
0BEA           1261       ;    inc r5
0BEA           1262       ;    cjne r5, #16, four_sec_loop2
0BEA           1263           
0BEA           1264       
0BEA           1265       ; loop back to state2 if run time is less than soak time
0BEA           1266       ;mov a, Time_refl
0BEA           1267       ;subb a, State_time
0BEA           1268       ;cjne a, #0, state4
0BEA           1269   
0BEA           1270       ;*Checking moving to states with buttons---- 
0BEA           1271   ;*Will remove after proper temperature reading----
0BEA           1272   
0BEA 2093F7    1273       jb NEXT_STATE_BUTTON, state4
0BED C002      1274            push AR2
0BEF 7A32      1274            mov R2, #50
0BF1 120039    1274            lcall ?Wait_Milli_Seconds
0BF4 D002      1274            pop AR2 ; debounce time
0BF6 2093EB    1275            jb NEXT_STATE_BUTTON, state4 ; if button not pressed, loop
0BF9 3093FD    1276            jnb NEXT_STATE_BUTTON, $ 
0BFC           1277   
0BFC           1278   state4_done: 
0BFC 753A00    1279       mov State_time, #0
0BFF 020C02    1280       ljmp state5_beginning 
0C02           1281   
0C02           1282   
0C02           1283   ; cooling
0C02           1284   state5_beginning: ; turn oven off
0C02 C287      1285       clr OVEN_POWER
0C04           1286   
0C04           1287   ;***clear the screen and set new display***
0C04 120699    1288       lcall Initialize_State_Display
0C07 C083      1289            push dph
0C09 C082      1289            push dpl
0C0B C0E0      1289            push acc
0C0D 90046E    1289            mov dptr, #Cooling
0C10 1200B2    1289            lcall ?Send_Constant_String
0C13 D0E0      1289            pop acc
0C15 D082      1289            pop dpl
0C17 D083      1289            pop dph
0C19           1290   
0C19           1291       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0C19 754E00    1292            mov pwm_ratio+0, #low(0)
0C1C 754F00    1293            mov pwm_ratio+1, #high(0)
0C1F           1294   
0C1F           1295   state5:
0C1F           1296       ;check power on
0C1F 12057D    1297       lcall CHECK_POWER
0C22           1298       
0C22           1299       ; update display
0C22 120718    1300       lcall Update_Display
0C25           1301   
0C25           1302       ;mov a, Temp_oven
0C25           1303       ;subb a, #60
0C25           1304       ;JNC state5    ; if greater, jump back to state 5
0C25           1305       ;JZ state5 ; if equal to, go back to state5
0C25           1306       ;JC state5_done ; if less than, go back to state 0
0C25           1307   
0C25           1308       ;*Checking moving to states with buttons---- 
0C25           1309   ;*Will remove after proper temperature reading----
0C25           1310   
0C25 2093F7    1311       jb NEXT_STATE_BUTTON, state5
0C28 C002      1312            push AR2
0C2A 7A32      1312            mov R2, #50
0C2C 120039    1312            lcall ?Wait_Milli_Seconds
0C2F D002      1312            pop AR2 ; debounce time
0C31 2093EB    1313            jb NEXT_STATE_BUTTON, state5 ; if button not pressed, loop
0C34 3093FD    1314            jnb NEXT_STATE_BUTTON, $ 
0C37           1315   
0C37           1316   state5_done:
0C37 753A00    1317       mov State_time, #0
0C3A 753300    1318       mov States, #0
0C3D 0209DB    1319       ljmp main
0C40           1320   
0C40           1321   EN
