                  2   $LIST
0000              4   
0000              5   
0000              6   ;-------------------------------------------------------------------------------------------------------------------------------
0000              7   ;These EQU must match the wiring between the microcontroller and ADC
0000              8   CLK  EQU 22118400
0000              9   TIMER1_RATE    EQU 25000 ;22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             10   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             11   BAUD equ 115200
0000             12   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000             13   
0000             14   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             15   TIMER2_RELOAD EQU (65536-(CLK/TIMER2_RATE))
0000             16   
0000             17   ;shjfjdfs
0000             18   ;-------------------------------------------------------------------------------------------------------------------------------
0000             19   ;Button Pin Mapping
0000             20   NEXT_STATE_BUTTON  equ P0.5
0000             21   STIME_BUTTON    equ P0.2
0000             22   STEMP_BUTTON    equ P0.3
0000             23   RTIME_BUTTON    equ P0.4
0000             24   RTEMP_BUTTON    equ P0.6 ;0.6
0000             25   PROFILE_BUTTON  equ P0.0
0000             26   
0000             27   POWER_BUTTON    equ P4.5
0000             28   SHIFT_BUTTON    equ P0.1
0000             29   
0000             30   ;Output Pins
0000             31   SPEAKER         equ P2.6
0000             32   
0000             33   PWM_OUTPUT      equ P1.0 ; Attach an LED (with 1k resistor in series) to P1.0
0000             34   SPAN_ENG_BUTTON equ P0.7;0.7
0000             35   FAN             equ P1.1
0000             36   
0000             37   
0000             38   ;FLASH pins
0000             39   MY_MOSI_SOUND EQU P2.4
0000             40   MY_MISO_SOUND EQU P2.1
0000             41   MY_SCLK_SOUND EQU P2.0
0000             42   FLASH_CE      EQU P2.5
0000             43   
0000             44   ;Thermowire Pins
0000             45   CE_ADC    EQU  P1.7
0000             46   MY_MOSI   EQU  P1.6
0000             47   MY_MISO   EQU  P1.5
0000             48   MY_SCLK   EQU  P1.4 
0000             49   
0000             50   ; Commands supported by the SPI flash memory according to the datasheet
0000             51   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             52   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             53   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             54   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             55   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             56   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             57   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             58   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             59   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             60   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             61   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             62   
0000             63   ; These 'equ' must match the hardware wiring
0000             64   LCD_RS equ P3.2
0000             65   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
0000             66   LCD_E  equ P3.3
0000             67   LCD_D4 equ P3.4
0000             68   LCD_D5 equ P3.5
0000             69   LCD_D6 equ P3.6
0000             70   LCD_D7 equ P3.7
0000             71   
0000             72   ;-------------------------------------------------------------------------------------------------------------------------------
0000             73   
0000             74   org 0x0000
0000 0211F4      75       ljmp main
0003             76   
0003             77   ; External interrupt 0 vector (not used in this code)
0003             78   org 0x0003
0003 32          79            reti
0004             80   
0004             81   ; Timer/Counter 0 overflow interrupt vector
000B             82   org 0x000B
000B 32          83            reti
000C             84   
000C             85   ; External interrupt 1 vector (not used in this code)
0013             86   org 0x0013
0013 32          87            reti
0014             88   
0014             89   ; Timer/Counter 1 overflow interrupt vector
001B             90   org 0x001B
001B 021148      91            ljmp Timer1_ISR
001E             92   
001E             93   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             94   org 0x0023 
0023 32          95            reti
0024             96            
0024             97   ; Timer/Counter 2 overflow interrupt vector
002B             98   org 0x002B
002B 02119E      99       ljmp Timer2_ISR
002E            100   ;-------------------------------------------------------------------------------------------------------------------------------
002E            101   ; Place our variables here
0030            102   DSEG at 0x30 ; Before the state machine!
0030            103   Count1ms:         ds 2 ; Used to determine when one second has passed
0032            104   Count5sec:        ds 1
0033            105   States:           ds 1
0034            106   Temp_soak:        ds 1
0035            107   Time_soak:        ds 1
0036            108   Temp_refl:        ds 1
0037            109   Time_refl:        ds 1
0038            110   Run_time_seconds: ds 1
0039            111   Run_time_minutes: ds 1
003A            112   State_time:       ds 1
003B            113   Temp_oven:        ds 1
003C            114   KTemp_oven:       ds 1
003D            115   x:                ds 4
0041            116   y:                ds 4
0045            117   bcd:              ds 5
004A            118   Result:           ds 2
004C            119   w:                ds 3
004F            120   pwm_ratio:        ds 2
0051            121   average_count:    ds 1
0052            122   K_or_C:           ds 1
0053            123   Profile:          ds 1 ; Select profile1 if equ 0, 2 if equ 1
0054            124   
                126   $LIST
00F0            128   
                546   $LIST
                130   $LIST
0360            132   
0360            133   ;$NOLIST
0360            134   ;$INCLUDE(sound_for_project1_index.asm)
0360            135   ;$LIST
0360            136   
0000            137   bseg
0000            138   one_seconds_flag:  dbit 1
0001            139   five_seconds_flag: dbit 1
0002            140   enable_clk:        dbit 1
0003            141   mf:                dbit 1
0004            142   SPAN_ENG:          dbit 1
0005            143   ;sound_flag: dbit 1
0005            144   
0360            145   cseg
0360            146   
0360            147   ;-------------------------------------------------------------------------------------------------------------------------------
0360            148   ;***Messages To Display*** 
0360            149   
0360            150   ;shortened labels
0360 53546D70   151   STemp:  db 'STmp:', 0
     3A00
0366 53546D3A   152   STime:  db 'STm:', 0
     00
036B 52546D70   153   RTemp:  db 'RTmp:', 0
     3A00
0371 52546D3A   154   RTime:  db 'RTm:', 0
     00
0376            155   
0376            156   ;lables for runnning oven
0376 53746174   157   state:     db 'State>' , 0
     653E00
037D 546D653E   158   time:      db 'Tme>' , 0
     00
0382 3A00       159   colon:     db ':', 0
0384 546D703E   160   temp:      db 'Tmp>', 0
     00
0389            161   
0389            162   ;labels for changin parameters
0389 5265666C   163   ReflowTemp:  db 'Reflow Temperature:', 0
     6F772054
     656D7065
     72617475
     72653A00
039D 5265666C   164   ReflowTime:  db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03AA 536F616B   165   SoakTime:    db 'Soak Time:', 0
     2054696D
     653A00
03B5 536F616B   166   SoakTemp:    db 'Soak Temperature:', 0
     2054656D
     70657261
     74757265
     3A00
03C7            167   
03C7            168   
03C7            169   ;Current State in Oven
03C7 52616D70   170   Ramp2Soak: db 'Ramp-Soak' , 0
     2D536F61
     6B00
03D1 536F616B   171   Soak:      db 'Soak' , 0
     00
03D6 52616D70   172   Ramp2Peak: db 'Ramp-Peak' , 0
     2D506561
     6B00
03E0 5265666C   173   Reflow:    db 'Reflow' , 0
     6F7700
03E7 436F6F6C   174   Cooling:   db 'Cooling' , 0
     696E6700
03EF            175   
03EF            176   ;-------------------------------------------------------------------------------------------------------------------------------
03EF            177   ;FXNS FOR THERMOWIRE
03EF            178   
03EF            179   ;initialize SPI 
03EF            180   INI_SPI:
03EF D295       181            setb MY_MISO          ; Make MISO an input pin
03F1 C294       182            clr MY_SCLK           ; Mode 0,0 default
03F3 22         183            ret
03F4            184   DO_SPI_G:
03F4 C0E0       185            push acc
03F6 7900       186            mov R1, #0            ; Received byte stored in R1
03F8 7A08       187            mov R2, #8            ; Loop counter (8-bits)
03FA            188   DO_SPI_G_LOOP:
03FA E8         189            mov a, R0             ; Byte to write is in R0
03FB 33         190            rlc a                 ; Carry flag has bit to write
03FC F8         191            mov R0, a
03FD 9296       192            mov MY_MOSI, c
03FF D294       193            setb MY_SCLK          ; Transmit
0401 A295       194            mov c, MY_MISO        ; Read received bit
0403 E9         195            mov a, R1             ; Save received bit in R1
0404 33         196            rlc a
0405 F9         197            mov R1, a
0406 C294       198            clr MY_SCLK
0408 DAF0       199            djnz R2, DO_SPI_G_LOOP
040A D0E0       200            pop acc
040C 22         201   ret
040D            202   
040D            203   Send_SPI:
                204   	SPIBIT MAC
                205   	    ; Send/Receive bit %0
                206   		rlc a
                207   		mov MY_MOSI_SOUND, c
                208   		setb MY_SCLK_SOUND
                209   		mov c, MY_MISO_SOUND
                210   		clr MY_SCLK_SOUND
                211   		mov acc.0, c
                212   	ENDMAC
040D            213            
040D            214                ; Send/Receive bit 7
040D 33         214                    rlc a
040E 92A4       214                    mov MY_MOSI_SOUND, c
0410 D2A0       214                    setb MY_SCLK_SOUND
0412 A2A1       214                    mov c, MY_MISO_SOUND
0414 C2A0       214                    clr MY_SCLK_SOUND
0416 92E0       214                    mov acc.0, c
0418            215                ; Send/Receive bit 6
0418 33         215                    rlc a
0419 92A4       215                    mov MY_MOSI_SOUND, c
041B D2A0       215                    setb MY_SCLK_SOUND
041D A2A1       215                    mov c, MY_MISO_SOUND
041F C2A0       215                    clr MY_SCLK_SOUND
0421 92E0       215                    mov acc.0, c
0423            216                ; Send/Receive bit 5
0423 33         216                    rlc a
0424 92A4       216                    mov MY_MOSI_SOUND, c
0426 D2A0       216                    setb MY_SCLK_SOUND
0428 A2A1       216                    mov c, MY_MISO_SOUND
042A C2A0       216                    clr MY_SCLK_SOUND
042C 92E0       216                    mov acc.0, c
042E            217                ; Send/Receive bit 4
042E 33         217                    rlc a
042F 92A4       217                    mov MY_MOSI_SOUND, c
0431 D2A0       217                    setb MY_SCLK_SOUND
0433 A2A1       217                    mov c, MY_MISO_SOUND
0435 C2A0       217                    clr MY_SCLK_SOUND
0437 92E0       217                    mov acc.0, c
0439            218                ; Send/Receive bit 3
0439 33         218                    rlc a
043A 92A4       218                    mov MY_MOSI_SOUND, c
043C D2A0       218                    setb MY_SCLK_SOUND
043E A2A1       218                    mov c, MY_MISO_SOUND
0440 C2A0       218                    clr MY_SCLK_SOUND
0442 92E0       218                    mov acc.0, c
0444            219                ; Send/Receive bit 2
0444 33         219                    rlc a
0445 92A4       219                    mov MY_MOSI_SOUND, c
0447 D2A0       219                    setb MY_SCLK_SOUND
0449 A2A1       219                    mov c, MY_MISO_SOUND
044B C2A0       219                    clr MY_SCLK_SOUND
044D 92E0       219                    mov acc.0, c
044F            220                ; Send/Receive bit 1
044F 33         220                    rlc a
0450 92A4       220                    mov MY_MOSI_SOUND, c
0452 D2A0       220                    setb MY_SCLK_SOUND
0454 A2A1       220                    mov c, MY_MISO_SOUND
0456 C2A0       220                    clr MY_SCLK_SOUND
0458 92E0       220                    mov acc.0, c
045A            221                ; Send/Receive bit 0
045A 33         221                    rlc a
045B 92A4       221                    mov MY_MOSI_SOUND, c
045D D2A0       221                    setb MY_SCLK_SOUND
045F A2A1       221                    mov c, MY_MISO_SOUND
0461 C2A0       221                    clr MY_SCLK_SOUND
0463 92E0       221                    mov acc.0, c
0465            222   
0465 22         223   ret
0466            224   
                225   Change_8bit_Variable MAC
                226       jb %0, %2
                227       Wait_Milli_Seconds(#50) ; de-bounce
                228       jb %0, %2
                229       jnb %0, $
                230       jb SHIFT_BUTTON, skip%Mb
                231       dec %1
                232       sjmp skip%Ma
                233       skip%Mb:
                234       inc %1
                235       skip%Ma:
                236       mov a, Profile
                237       cjne a, #0, skip%Mc
                238       lcall Save_Configuration1
                239       sjmp skip%Md
                240       skip%Mc:
                241       lcall Save_Configuration2
                242       skip%Md:
                243   ENDMAC
0466            244   
0466            245   
0466            246   
0466            247   ;Change_8bit_Variable(MY_VARIABLE_BUTTON, my_variable, loop_c)
0466            248   ;    Set_Cursor(2, 14)
0466            249   ;    mov a, my_variable
0466            250   ;    lcall SendToLCD
0466            251   ;lcall Save_Configuration
0466            252   
0466            253   ;-------------------------------------------------------------------------------------------------------------------------------
0466            254   ;***FXNS For Serial Port
0466            255   
0466            256   ; Configure the serial port and baud rate
0466            257   InitSerialPort:
0466            258       ; Since the reset button bounces, we need to wait a bit before
0466            259       ; sending messages, otherwise we risk displaying gibberish!
0466 79DE       260       mov R1, #222
0468 78A6       261       mov R0, #166
046A D8FE       262       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
046C D9FA       263       djnz R1, $-4 ; 22.51519us*222=4.998ms
046E            264       ; Now we can proceed with the configuration
046E 438780     265            orl     PCON,#0x80
0471 759852     266            mov     SCON,#0x52
0474 759B00     267            mov     BDRCON,#0x00
0477 759AF4     268            mov     BRL,#BRG_VAL
047A 759B1E     269            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
047D 22         270   ret
047E            271   
047E            272   
047E            273   putchar:
047E 3099FD     274       jnb TI, putchar
0481 C299       275       clr TI
0483 F599       276       mov SBUF, a
0485 22         277   ret
0486            278   
0486            279   ;-------------------------------------------------------------------------------------------------------------------------------
0486            280   ;***FXNS to CHECK BUTTONS
0486            281   
0486            282   CHECK_STIME:
0486            283   
0486 208225     284       jb STIME_BUTTON, CHECK_STIME_END
0489 C002       284            push AR2
048B 7A32       284            mov R2, #50
048D 120039     284            lcall ?Wait_Milli_Seconds
0490 D002       284            pop AR2 ; de-bounce
0492 208219     284       jb STIME_BUTTON, CHECK_STIME_END
0495 3082FD     284       jnb STIME_BUTTON, $
0498 208104     284       jb SHIFT_BUTTON, skip16b
049B 1535       284       dec Time_soak
049D 8002       284       sjmp skip16a
049F            284       skip16b:
049F 0535       284       inc Time_soak
04A1            284       skip16a:
04A1 E553       284       mov a, Profile
04A3 B40005     284       cjne a, #0, skip16c
04A6 120F69     284       lcall Save_Configuration1
04A9 8003       284       sjmp skip16d
04AB            284       skip16c:
04AB 120FA0     284       lcall Save_Configuration2
04AE            284       skip16d:
04AE            285            
04AE            286   CHECK_STIME_END:
04AE 22         287   ret
04AF            288   
04AF            289   CHECK_STEMP:
04AF 208325     290       jb STEMP_BUTTON, CHECK_STEMP_END
04B2 C002       290            push AR2
04B4 7A32       290            mov R2, #50
04B6 120039     290            lcall ?Wait_Milli_Seconds
04B9 D002       290            pop AR2 ; de-bounce
04BB 208319     290       jb STEMP_BUTTON, CHECK_STEMP_END
04BE 3083FD     290       jnb STEMP_BUTTON, $
04C1 208104     290       jb SHIFT_BUTTON, skip18b
04C4 1534       290       dec Temp_soak
04C6 8002       290       sjmp skip18a
04C8            290       skip18b:
04C8 0534       290       inc Temp_soak
04CA            290       skip18a:
04CA E553       290       mov a, Profile
04CC B40005     290       cjne a, #0, skip18c
04CF 120F69     290       lcall Save_Configuration1
04D2 8003       290       sjmp skip18d
04D4            290       skip18c:
04D4 120FA0     290       lcall Save_Configuration2
04D7            290       skip18d:
04D7            291       ;lcall Save_Configuration
04D7            292            
04D7            293   CHECK_STEMP_END:
04D7 22         294   ret
04D8            295   
04D8            296   CHECK_RTIME:
04D8 208425     297       jb RTIME_BUTTON, CHECK_RTIME_END
04DB C002       297            push AR2
04DD 7A32       297            mov R2, #50
04DF 120039     297            lcall ?Wait_Milli_Seconds
04E2 D002       297            pop AR2 ; de-bounce
04E4 208419     297       jb RTIME_BUTTON, CHECK_RTIME_END
04E7 3084FD     297       jnb RTIME_BUTTON, $
04EA 208104     297       jb SHIFT_BUTTON, skip20b
04ED 1537       297       dec Time_refl
04EF 8002       297       sjmp skip20a
04F1            297       skip20b:
04F1 0537       297       inc Time_refl
04F3            297       skip20a:
04F3 E553       297       mov a, Profile
04F5 B40005     297       cjne a, #0, skip20c
04F8 120F69     297       lcall Save_Configuration1
04FB 8003       297       sjmp skip20d
04FD            297       skip20c:
04FD 120FA0     297       lcall Save_Configuration2
0500            297       skip20d:
0500            298   CHECK_RTIME_END:
0500 22         299   ret
0501            300   
0501            301   CHECK_RTEMP:
0501 208625     302       jb RTEMP_BUTTON, CHECK_RTEMP_END
0504 C002       302            push AR2
0506 7A32       302            mov R2, #50
0508 120039     302            lcall ?Wait_Milli_Seconds
050B D002       302            pop AR2 ; de-bounce
050D 208619     302       jb RTEMP_BUTTON, CHECK_RTEMP_END
0510 3086FD     302       jnb RTEMP_BUTTON, $
0513 208104     302       jb SHIFT_BUTTON, skip22b
0516 1536       302       dec Temp_refl
0518 8002       302       sjmp skip22a
051A            302       skip22b:
051A 0536       302       inc Temp_refl
051C            302       skip22a:
051C E553       302       mov a, Profile
051E B40005     302       cjne a, #0, skip22c
0521 120F69     302       lcall Save_Configuration1
0524 8003       302       sjmp skip22d
0526            302       skip22c:
0526 120FA0     302       lcall Save_Configuration2
0529            302       skip22d:
0529            303   CHECK_RTEMP_END:
0529 22         304   ret
052A            305   
052A            306   CHECK_POWER:
052A 20C518     307       jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
052D C002       308            push AR2
052F 7A32       308            mov R2, #50
0531 120039     308            lcall ?Wait_Milli_Seconds
0534 D002       308            pop AR2 ; debounce time
0536 20C50C     309            jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
0539 30C5FD     310            jnb POWER_BUTTON, $ ; loop while the button is pressed
053C 754F00     311       mov pwm_ratio+0, #low(0)
053F 755000     312            mov pwm_ratio+1, #high(0)
0542 121043     313       lcall OFF_STATE
0545            314   CHECK_POWER_END:
0545 22         315   ret
0546            316   
0546            317   CHECK_PROFILE:
0546 208022     318       jb PROFILE_BUTTON, CHECK_PROFILE_END
0549 C002       319            push AR2
054B 7A32       319            mov R2, #50
054D 120039     319            lcall ?Wait_Milli_Seconds
0550 D002       319            pop AR2 ; de-bounce
0552 208016     320       jb PROFILE_BUTTON, CHECK_PROFILE_END
0555 3080FD     321       jnb PROFILE_BUTTON, $
0558 E553       322       mov a, Profile
055A B40008     323       cjne a, #0, To_Profile1
055D 121000     324       lcall Load_Configuration2
0560 755301     325       mov Profile, #1
0563 8006       326       sjmp CHECK_PROFILE_END
0565            327   To_Profile1:
0565 120FD7     328       lcall Load_Configuration1
0568 755300     329       mov Profile, #0
056B            330   CHECK_PROFILE_END:
056B 22         331   ret
056C            332   
056C            333   
056C            334   ; Playback MACRO for sound --------------------------------------------------
056C            335   
                336   PLAYBACK_TEMP MAC
                337       ; ***play audio***
                338       ;cjne sound_flag, #0, $
                339       lcall Wait_Half_Second
                340       clr TR1 ; Stop Timer 1 ISR from playing previous request
                341       setb FLASH_CE
                342       ;setb sound_flag ; sound starts
                343       clr SPEAKER ; Turn off speaker
                344       clr FLASH_CE ; Enable SPI Flash
                345       mov a, #READ_BYTES
                346       lcall Send_SPI
                347       ; Set the initial position in memory where to start playing
                348       
                349       mov a, %0 ; change initial position
                350       lcall Send_SPI
                351       mov a, %1 ; next memory position
                352       lcall Send_SPI
                353       mov a, %2 ; next memory position
                354       lcall Send_SPI
                355       mov a, %0 ; request first byte to send to DAC
                356       lcall Send_SPI
                357       
                358       ; How many bytes to play?
                359       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
                360       mov w+1, %3 ; Load the middle byte of the number of bytes to play
                361       mov w+0, %4 ; Load the low byte of the number of bytes to play
                362       
                363       
                364       setb SPEAKER ;Turn on speaker
                365       setb TR1 ;Start playback by enabling Timer1
                366       ;clr sound_flag ; sound ends
                367   ENDMAC
056C            368   
056C            369   
                370   PLAYBACK_MUSIC MAC
                371       ; ***play audio***
                372       ;cjne sound_flag, #0, $
                373       
                374       clr TR1 ; Stop Timer 1 ISR from playing previous request
                375       setb FLASH_CE
                376       ;setb sound_flag ; sound starts
                377       clr SPEAKER ; Turn off speaker
                378       clr FLASH_CE ; Enable SPI Flash
                379       mov a, #READ_BYTES
                380       lcall Send_SPI
                381       ; Set the initial position in memory where to start playing
                382       
                383       mov a, %0 ; change initial position
                384       lcall Send_SPI
                385       mov a, %1 ; next memory position
                386       lcall Send_SPI
                387       mov a, %2 ; next memory position
                388       lcall Send_SPI
                389       mov a, %0 ; request first byte to send to DAC
                390       lcall Send_SPI
                391       
                392       ; How many bytes to play?
                393       mov w+2, #0x02 ; Load the high byte of the number of bytes to play
                394       mov w+1, %3 ; Load the middle byte of the number of bytes to play
                395       mov w+0, %4 ; Load the low byte of the number of bytes to play
                396       
                397       
                398       setb SPEAKER ;Turn on speaker
                399       setb TR1 ;Start playback by enabling Timer1
                400       ;clr sound_flag ; sound ends
                401   ENDMAC
056C            402   
056C            403   CHECK_SPAN_OR_ENGL:
056C            404   
056C 208742     405       jb SPAN_ENG_BUTTON, CHECK_SPAN_OR_ENGL_END ; if button not pressed, stop checking
056F C002       406            push AR2
0571 7A32       406            mov R2, #50
0573 120039     406            lcall ?Wait_Milli_Seconds
0576 D002       406            pop AR2 ; debounce time
0578 208736     407            jb SPAN_ENG_BUTTON, CHECK_SPAN_OR_ENGL_END ; if button not pressed, stop checking
057B 3087FD     408            jnb SPAN_ENG_BUTTON, $ ; loop while the button is pressed
057E            409       
057E            410       ; ***play audio***
057E            410       ;cjne sound_flag, #0, $
057E 121130     410       lcall Wait_Half_Second
0581 C28E       410       clr TR1 ; Stop Timer 1 ISR from playing previous request
0583 D2A5       410       setb FLASH_CE
0585            410       ;setb sound_flag ; sound starts
0585 C2A6       410       clr SPEAKER ; Turn off speaker
0587 C2A5       410       clr FLASH_CE ; Enable SPI Flash
0589 7403       410       mov a, #READ_BYTES
058B 12040D     410       lcall Send_SPI
058E            410       ; Set the initial position in memory where to start playing
058E            410       
058E 7401       410       mov a, #0x01 ; change initial position
0590 12040D     410       lcall Send_SPI
0593 7493       410       mov a, #0x93 ; next memory position
0595 12040D     410       lcall Send_SPI
0598 7484       410       mov a, #0x84 ; next memory position
059A 12040D     410       lcall Send_SPI
059D 7401       410       mov a, #0x01 ; request first byte to send to DAC
059F 12040D     410       lcall Send_SPI
05A2            410       
05A2            410       ; How many bytes to play?
05A2 754E00     410       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
05A5 754D17     410       mov w+1, #0x17 ; Load the middle byte of the number of bytes to play
05A8 754C70     410       mov w+0, #0x70 ; Load the low byte of the number of bytes to play
05AB            410       
05AB            410       
05AB D2A6       410       setb SPEAKER ;Turn on speaker
05AD D28E       410       setb TR1 ;Start playback by enabling Timer1
05AF            410       ;clr sound_flag ; sound ends ;one
05AF B204       411       cpl SPAN_ENG
05B1            412       ;mov a, K_or_C
05B1            413       ;anl a,
05B1            414       ;anl a, #00000001B  ; We need only the two least significant bits
05B1            415   
05B1            416   
05B1            417   CHECK_SPAN_OR_ENGL_END:
05B1 22         418   ret
05B2            419   ;****ENGLISH SOUND FSM--------------------------------------------------------
05B2            420   
05B2            421   SOUND_FSM:
05B2            422   state_0_sound:
05B2            423   ;check if 5 seconds has passed, if yes go to state 1, if no exit function 
05B2 300104     424       jnb five_seconds_flag, Sound_ret
05B5 C201       425       clr five_seconds_flag
05B7 8001       426       sjmp state_1_sound
05B9            427   Sound_ret:
05B9 22         428       ret
05BA            429   
05BA            430   state_1_sound:
05BA            431   ; check if temp is greater than or equal to 100, if yes go to state 2
05BA            432   ; check if temp is less than 100, if yes go to state 4
05BA E53B       433       mov a, Temp_oven
05BC 9464       434       subb a, #100
05BE 5002       435       jnc state_2_sound_hop
05C0 4002       436       jc state_4_sound_hop
05C2            437   
05C2            438       state_2_sound_hop:
05C2 8003       439           sjmp state_2_sound
05C4            440   
05C4            441       state_4_sound_hop:
05C4 0206C0     442           ljmp state_4_sound
05C7            443   
05C7            444   state_2_sound:
05C7            445   ;divide temp by 100, if it is 1 play sound: "100", if it is 2 play sound: "200"
05C7            446   ; go to state_3_sound
05C7 75F064     447       mov b, #100
05CA E53B       448       mov a, Temp_oven
05CC 84         449       div ab
05CD 9401       450       subb a, #1
05CF 600A       451       jz play_sound_100
05D1            452   
05D1 75F064     453       mov b, #100
05D4 E53B       454       mov a, Temp_oven
05D6 84         455       div ab
05D7 9402       456       subb a, #2
05D9 6065       457       jz play_sound_200
05DB            458      
05DB            459       play_sound_100: 
05DB            460       ; ***play audio***
05DB            460       ;cjne sound_flag, #0, $
05DB 121130     460       lcall Wait_Half_Second
05DE C28E       460       clr TR1 ; Stop Timer 1 ISR from playing previous request
05E0 D2A5       460       setb FLASH_CE
05E2            460       ;setb sound_flag ; sound starts
05E2 C2A6       460       clr SPEAKER ; Turn off speaker
05E4 C2A5       460       clr FLASH_CE ; Enable SPI Flash
05E6 7403       460       mov a, #READ_BYTES
05E8 12040D     460       lcall Send_SPI
05EB            460       ; Set the initial position in memory where to start playing
05EB            460       
05EB 7401       460       mov a, #0x01 ; change initial position
05ED 12040D     460       lcall Send_SPI
05F0 7493       460       mov a, #0x93 ; next memory position
05F2 12040D     460       lcall Send_SPI
05F5 7484       460       mov a, #0x84 ; next memory position
05F7 12040D     460       lcall Send_SPI
05FA 7401       460       mov a, #0x01 ; request first byte to send to DAC
05FC 12040D     460       lcall Send_SPI
05FF            460       
05FF            460       ; How many bytes to play?
05FF 754E00     460       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0602 754D36     460       mov w+1, #0x36 ; Load the middle byte of the number of bytes to play
0605 754CB0     460       mov w+0, #0xb0 ; Load the low byte of the number of bytes to play
0608            460       
0608            460       
0608 D2A6       460       setb SPEAKER ;Turn on speaker
060A D28E       460       setb TR1 ;Start playback by enabling Timer1
060C            460       ;clr sound_flag ; sound ends ;one
060C            461       ; ***play audio***
060C            461       ;cjne sound_flag, #0, $
060C 121130     461       lcall Wait_Half_Second
060F C28E       461       clr TR1 ; Stop Timer 1 ISR from playing previous request
0611 D2A5       461       setb FLASH_CE
0613            461       ;setb sound_flag ; sound starts
0613 C2A6       461       clr SPEAKER ; Turn off speaker
0615 C2A5       461       clr FLASH_CE ; Enable SPI Flash
0617 7403       461       mov a, #READ_BYTES
0619 12040D     461       lcall Send_SPI
061C            461       ; Set the initial position in memory where to start playing
061C            461       
061C 7405       461       mov a, #0x05 ; change initial position
061E 12040D     461       lcall Send_SPI
0621 7409       461       mov a, #0x09 ; next memory position
0623 12040D     461       lcall Send_SPI
0626 7410       461       mov a, #0x10 ; next memory position
0628 12040D     461       lcall Send_SPI
062B 7405       461       mov a, #0x05 ; request first byte to send to DAC
062D 12040D     461       lcall Send_SPI
0630            461       
0630            461       ; How many bytes to play?
0630 754E00     461       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0633 754D27     461       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0636 754C10     461       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0639            461       
0639            461       
0639 D2A6       461       setb SPEAKER ;Turn on speaker
063B D28E       461       setb TR1 ;Start playback by enabling Timer1
063D            461       ;clr sound_flag ; sound ends ;hundred
063D 0206A5     462           ljmp state_3_sound
0640            463   
0640            464       play_sound_200:
0640            465       ; ***play audio***
0640            465       ;cjne sound_flag, #0, $
0640 121130     465       lcall Wait_Half_Second
0643 C28E       465       clr TR1 ; Stop Timer 1 ISR from playing previous request
0645 D2A5       465       setb FLASH_CE
0647            465       ;setb sound_flag ; sound starts
0647 C2A6       465       clr SPEAKER ; Turn off speaker
0649 C2A5       465       clr FLASH_CE ; Enable SPI Flash
064B 7403       465       mov a, #READ_BYTES
064D 12040D     465       lcall Send_SPI
0650            465       ; Set the initial position in memory where to start playing
0650            465       
0650 7401       465       mov a, #0x01 ; change initial position
0652 12040D     465       lcall Send_SPI
0655 74C7       465       mov a, #0xc7 ; next memory position
0657 12040D     465       lcall Send_SPI
065A 7414       465       mov a, #0x14 ; next memory position
065C 12040D     465       lcall Send_SPI
065F 7401       465       mov a, #0x01 ; request first byte to send to DAC
0661 12040D     465       lcall Send_SPI
0664            465       
0664            465       ; How many bytes to play?
0664 754E00     465       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0667 754D13     465       mov w+1, #0x13 ; Load the middle byte of the number of bytes to play
066A 754C88     465       mov w+0, #0x88 ; Load the low byte of the number of bytes to play
066D            465       
066D            465       
066D D2A6       465       setb SPEAKER ;Turn on speaker
066F D28E       465       setb TR1 ;Start playback by enabling Timer1
0671            465       ;clr sound_flag ; sound ends ;two
0671            466       ; ***play audio***
0671            466       ;cjne sound_flag, #0, $
0671 121130     466       lcall Wait_Half_Second
0674 C28E       466       clr TR1 ; Stop Timer 1 ISR from playing previous request
0676 D2A5       466       setb FLASH_CE
0678            466       ;setb sound_flag ; sound starts
0678 C2A6       466       clr SPEAKER ; Turn off speaker
067A C2A5       466       clr FLASH_CE ; Enable SPI Flash
067C 7403       466       mov a, #READ_BYTES
067E 12040D     466       lcall Send_SPI
0681            466       ; Set the initial position in memory where to start playing
0681            466       
0681 7405       466       mov a, #0x05 ; change initial position
0683 12040D     466       lcall Send_SPI
0686 7409       466       mov a, #0x09 ; next memory position
0688 12040D     466       lcall Send_SPI
068B 7410       466       mov a, #0x10 ; next memory position
068D 12040D     466       lcall Send_SPI
0690 7405       466       mov a, #0x05 ; request first byte to send to DAC
0692 12040D     466       lcall Send_SPI
0695            466       
0695            466       ; How many bytes to play?
0695 754E00     466       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0698 754D27     466       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
069B 754C10     466       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
069E            466       
069E            466       
069E D2A6       466       setb SPEAKER ;Turn on speaker
06A0 D28E       466       setb TR1 ;Start playback by enabling Timer1
06A2            466       ;clr sound_flag ; sound ends ;hundred
06A2 0206A5     467           ljmp state_3_sound
06A5            468   
06A5            469   state_3_sound:
06A5            470   ; check remainder of temp, if it is 0, exit
06A5            471   ; if not 0, go to state_4_sound
06A5            472   
06A5            473   
06A5 75F064     474       mov b, #100
06A8 E53B       475       mov a, Temp_oven
06AA 95F0       476       subb a, b
06AC E5F0       477       mov a, b
06AE 600D       478       jz state_3_sound_hop
06B0            479       
06B0 75F0C8     480       mov b, #200
06B3 E53B       481       mov a, Temp_oven
06B5 95F0       482       subb a, b
06B7 E5F0       483       mov a, b
06B9 6002       484       jz state_3_sound_hop
06BB            485   
06BB 8003       486       sjmp state_4_sound
06BD            487   
06BD            488       state_3_sound_hop:
06BD 0205B9     489           ljmp Sound_ret
06C0            490   
06C0            491   state_4_sound:
06C0            492   ; if T % 100 greater or equal to 20, go to state_5_sound,
06C0 75F064     493       mov b, #100
06C3 E53B       494       mov a, Temp_oven
06C5 84         495       div ab
06C6            496       ;mov R0, b
06C6 E5F0       497       mov a, b 
06C8            498   
06C8            499   
06C8 9414       500       subb a, #20
06CA 5027       501       jnc state_5_sound
06CC 6025       502       jz state_5_sound
06CE E4         503       clr a
06CF            504   ; if T % 100 is less than 10, go to state_6_sound
06CF 75F064     505       mov b, #100
06D2 E53B       506       mov a, Temp_oven
06D4 84         507       div ab
06D5 E5F0       508       mov a, b
06D7 940A       509       subb a, #10
06D9 4015       510       jc state_6_sound_hop0
06DB            511       
06DB            512       ;mov a, b
06DB            513       
06DB            514       ; ubb a, #0
06DB            515       ;jc state_6_sound_hop0
06DB            516       ;clr a
06DB            517   ; if T % 100 is greater than or equal to 10 and less than 20, go to state_7_sound
06DB            518   
06DB 75F064     519       mov b, #100
06DE E53B       520       mov a, Temp_oven
06E0 84         521       div ab
06E1 E5F0       522       mov a, b
06E3 940A       523       subb a, #10
06E5 6000       524       jz and_branch
06E7            525   
06E7            526       and_branch:
06E7 E5F0       527           mov a, b
06E9 9414       528           subb a, #20
06EB 4000       529           jc state_7_sound_hop0
06ED            530       
06ED            531       state_7_sound_hop0:
06ED 020AB4     532           ljmp state_7_sound
06F0            533   
06F0            534       state_6_sound_hop0:
06F0 0208B4     535           ljmp state_6_sound
06F3            536       
06F3            537   
06F3            538   state_5_sound:
06F3            539   ; play number from 20 to 90 in decades (20, 30, 40, 50, 60, 70, 80, 90), based off remainder from temp divided by 100
06F3            540   ; if (T % 100) % 10 is not equal to 0, go to state_6_sound
06F3            541   ; if (T % 100) % 10 is equal to 0, go to state_8_sound
06F3            542   
06F3            543       play_sound:
06F3            544           ;ljmp PLAYBACK_TEMP
06F3 E53B       545           mov a, Temp_oven
06F5 75F064     546           mov b, #100
06F8 84         547           div ab
06F9 E5F0       548           mov a, b
06FB 75F00A     549           mov b, #10
06FE 84         550           div ab
06FF B40234     551           cjne a, #2, play_30
0702            552           ;mov    
0702            553   
0702            554           play_20:
0702            555       ; ***play audio***
0702            555       ;cjne sound_flag, #0, $
0702 121130     555       lcall Wait_Half_Second
0705 C28E       555       clr TR1 ; Stop Timer 1 ISR from playing previous request
0707 D2A5       555       setb FLASH_CE
0709            555       ;setb sound_flag ; sound starts
0709 C2A6       555       clr SPEAKER ; Turn off speaker
070B C2A5       555       clr FLASH_CE ; Enable SPI Flash
070D 7403       555       mov a, #READ_BYTES
070F 12040D     555       lcall Send_SPI
0712            555       ; Set the initial position in memory where to start playing
0712            555       
0712 7403       555       mov a, #0x03 ; change initial position
0714 12040D     555       lcall Send_SPI
0717 74EF       555       mov a, #0xef ; next memory position
0719 12040D     555       lcall Send_SPI
071C 74D0       555       mov a, #0xd0 ; next memory position
071E 12040D     555       lcall Send_SPI
0721 7403       555       mov a, #0x03 ; request first byte to send to DAC
0723 12040D     555       lcall Send_SPI
0726            555       
0726            555       ; How many bytes to play?
0726 754E00     555       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0729 754D27     555       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
072C 754C10     555       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
072F            555       
072F            555       
072F D2A6       555       setb SPEAKER ;Turn on speaker
0731 D28E       555       setb TR1 ;Start playback by enabling Timer1
0733            555       ;clr sound_flag ; sound ends
0733            556               ;lcall Wait_One_Second
0733 0208B1     557               ljmp state_6_sound_hop1
0736            558   
0736            559           play_30:
0736            560               
0736 B40334     561               cjne a, #3, play_40   
0739            562       ; ***play audio***
0739            562       ;cjne sound_flag, #0, $
0739 121130     562       lcall Wait_Half_Second
073C C28E       562       clr TR1 ; Stop Timer 1 ISR from playing previous request
073E D2A5       562       setb FLASH_CE
0740            562       ;setb sound_flag ; sound starts
0740 C2A6       562       clr SPEAKER ; Turn off speaker
0742 C2A5       562       clr FLASH_CE ; Enable SPI Flash
0744 7403       562       mov a, #READ_BYTES
0746 12040D     562       lcall Send_SPI
0749            562       ; Set the initial position in memory where to start playing
0749            562       
0749 7404       562       mov a, #0x04 ; change initial position
074B 12040D     562       lcall Send_SPI
074E 7416       562       mov a, #0x16 ; next memory position
0750 12040D     562       lcall Send_SPI
0753 74E0       562       mov a, #0xe0 ; next memory position
0755 12040D     562       lcall Send_SPI
0758 7404       562       mov a, #0x04 ; request first byte to send to DAC
075A 12040D     562       lcall Send_SPI
075D            562       
075D            562       ; How many bytes to play?
075D 754E00     562       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0760 754D23     562       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
0763 754C28     562       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0766            562       
0766            562       
0766 D2A6       562       setb SPEAKER ;Turn on speaker
0768 D28E       562       setb TR1 ;Start playback by enabling Timer1
076A            562       ;clr sound_flag ; sound ends
076A 0208B1     563               ljmp state_6_sound_hop1
076D            564   
076D            565           play_40:
076D            566               
076D B40434     567               cjne a, #4, play_50  
0770            568       ; ***play audio***
0770            568       ;cjne sound_flag, #0, $
0770 121130     568       lcall Wait_Half_Second
0773 C28E       568       clr TR1 ; Stop Timer 1 ISR from playing previous request
0775 D2A5       568       setb FLASH_CE
0777            568       ;setb sound_flag ; sound starts
0777 C2A6       568       clr SPEAKER ; Turn off speaker
0779 C2A5       568       clr FLASH_CE ; Enable SPI Flash
077B 7403       568       mov a, #READ_BYTES
077D 12040D     568       lcall Send_SPI
0780            568       ; Set the initial position in memory where to start playing
0780            568       
0780 7404       568       mov a, #0x04 ; change initial position
0782 12040D     568       lcall Send_SPI
0785 743D       568       mov a, #0x3d ; next memory position
0787 12040D     568       lcall Send_SPI
078A 74F0       568       mov a, #0xf0 ; next memory position
078C 12040D     568       lcall Send_SPI
078F 7404       568       mov a, #0x04 ; request first byte to send to DAC
0791 12040D     568       lcall Send_SPI
0794            568       
0794            568       ; How many bytes to play?
0794 754E00     568       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0797 754D1F     568       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
079A 754C40     568       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
079D            568       
079D            568       
079D D2A6       568       setb SPEAKER ;Turn on speaker
079F D28E       568       setb TR1 ;Start playback by enabling Timer1
07A1            568       ;clr sound_flag ; sound ends
07A1 0208B1     569               ljmp state_6_sound_hop1
07A4            570   
07A4            571           play_50:
07A4            572              
07A4 B40534     573               cjne a, #5, play_60  
07A7            574       ; ***play audio***
07A7            574       ;cjne sound_flag, #0, $
07A7 121130     574       lcall Wait_Half_Second
07AA C28E       574       clr TR1 ; Stop Timer 1 ISR from playing previous request
07AC D2A5       574       setb FLASH_CE
07AE            574       ;setb sound_flag ; sound starts
07AE C2A6       574       clr SPEAKER ; Turn off speaker
07B0 C2A5       574       clr FLASH_CE ; Enable SPI Flash
07B2 7403       574       mov a, #READ_BYTES
07B4 12040D     574       lcall Send_SPI
07B7            574       ; Set the initial position in memory where to start playing
07B7            574       
07B7 7404       574       mov a, #0x04 ; change initial position
07B9 12040D     574       lcall Send_SPI
07BC 7451       574       mov a, #0x51 ; next memory position
07BE 12040D     574       lcall Send_SPI
07C1 7478       574       mov a, #0x78 ; next memory position
07C3 12040D     574       lcall Send_SPI
07C6 7404       574       mov a, #0x04 ; request first byte to send to DAC
07C8 12040D     574       lcall Send_SPI
07CB            574       
07CB            574       ; How many bytes to play?
07CB 754E00     574       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
07CE 754D23     574       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
07D1 754C28     574       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
07D4            574       
07D4            574       
07D4 D2A6       574       setb SPEAKER ;Turn on speaker
07D6 D28E       574       setb TR1 ;Start playback by enabling Timer1
07D8            574       ;clr sound_flag ; sound ends
07D8 0208B1     575               ljmp state_6_sound_hop1
07DB            576   
07DB            577           play_60:
07DB            578               
07DB B40634     579               cjne a, #6, play_70  
07DE            580       ; ***play audio***
07DE            580       ;cjne sound_flag, #0, $
07DE 121130     580       lcall Wait_Half_Second
07E1 C28E       580       clr TR1 ; Stop Timer 1 ISR from playing previous request
07E3 D2A5       580       setb FLASH_CE
07E5            580       ;setb sound_flag ; sound starts
07E5 C2A6       580       clr SPEAKER ; Turn off speaker
07E7 C2A5       580       clr FLASH_CE ; Enable SPI Flash
07E9 7403       580       mov a, #READ_BYTES
07EB 12040D     580       lcall Send_SPI
07EE            580       ; Set the initial position in memory where to start playing
07EE            580       
07EE 7404       580       mov a, #0x04 ; change initial position
07F0 12040D     580       lcall Send_SPI
07F3 7474       580       mov a, #0x74 ; next memory position
07F5 12040D     580       lcall Send_SPI
07F8 74A0       580       mov a, #0xa0 ; next memory position
07FA 12040D     580       lcall Send_SPI
07FD 7404       580       mov a, #0x04 ; request first byte to send to DAC
07FF 12040D     580       lcall Send_SPI
0802            580       
0802            580       ; How many bytes to play?
0802 754E00     580       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0805 754D27     580       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0808 754C10     580       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
080B            580       
080B            580       
080B D2A6       580       setb SPEAKER ;Turn on speaker
080D D28E       580       setb TR1 ;Start playback by enabling Timer1
080F            580       ;clr sound_flag ; sound ends
080F 0208B1     581               ljmp state_6_sound_hop1
0812            582   
0812            583           play_70:
0812            584              
0812 B40734     585               cjne a, #7, play_80  
0815            586       ; ***play audio***
0815            586       ;cjne sound_flag, #0, $
0815 121130     586       lcall Wait_Half_Second
0818 C28E       586       clr TR1 ; Stop Timer 1 ISR from playing previous request
081A D2A5       586       setb FLASH_CE
081C            586       ;setb sound_flag ; sound starts
081C C2A6       586       clr SPEAKER ; Turn off speaker
081E C2A5       586       clr FLASH_CE ; Enable SPI Flash
0820 7403       586       mov a, #READ_BYTES
0822 12040D     586       lcall Send_SPI
0825            586       ; Set the initial position in memory where to start playing
0825            586       
0825 7404       586       mov a, #0x04 ; change initial position
0827 12040D     586       lcall Send_SPI
082A 749B       586       mov a, #0x9b ; next memory position
082C 12040D     586       lcall Send_SPI
082F 74B0       586       mov a, #0xb0 ; next memory position
0831 12040D     586       lcall Send_SPI
0834 7404       586       mov a, #0x04 ; request first byte to send to DAC
0836 12040D     586       lcall Send_SPI
0839            586       
0839            586       ; How many bytes to play?
0839 754E00     586       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
083C 754D32     586       mov w+1, #0x32 ; Load the middle byte of the number of bytes to play
083F 754CC8     586       mov w+0, #0xc8 ; Load the low byte of the number of bytes to play
0842            586       
0842            586       
0842 D2A6       586       setb SPEAKER ;Turn on speaker
0844 D28E       586       setb TR1 ;Start playback by enabling Timer1
0846            586       ;clr sound_flag ; sound ends
0846 0208B1     587               ljmp state_6_sound_hop1
0849            588   
0849            589           play_80:
0849            590               
0849 B40834     591               cjne a, #8, play_90  
084C            592       ; ***play audio***
084C            592       ;cjne sound_flag, #0, $
084C 121130     592       lcall Wait_Half_Second
084F C28E       592       clr TR1 ; Stop Timer 1 ISR from playing previous request
0851 D2A5       592       setb FLASH_CE
0853            592       ;setb sound_flag ; sound starts
0853 C2A6       592       clr SPEAKER ; Turn off speaker
0855 C2A5       592       clr FLASH_CE ; Enable SPI Flash
0857 7403       592       mov a, #READ_BYTES
0859 12040D     592       lcall Send_SPI
085C            592       ; Set the initial position in memory where to start playing
085C            592       
085C 7404       592       mov a, #0x04 ; change initial position
085E 12040D     592       lcall Send_SPI
0861 74C6       592       mov a, #0xc6 ; next memory position
0863 12040D     592       lcall Send_SPI
0866 74A8       592       mov a, #0xa8 ; next memory position
0868 12040D     592       lcall Send_SPI
086B 7404       592       mov a, #0x04 ; request first byte to send to DAC
086D 12040D     592       lcall Send_SPI
0870            592       
0870            592       ; How many bytes to play?
0870 754E00     592       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0873 754D23     592       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
0876 754C28     592       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0879            592       
0879            592       
0879 D2A6       592       setb SPEAKER ;Turn on speaker
087B D28E       592       setb TR1 ;Start playback by enabling Timer1
087D            592       ;clr sound_flag ; sound ends
087D 0208B1     593               ljmp state_6_sound_hop1
0880            594   
0880            595           play_90:
0880            596       ; ***play audio***
0880            596       ;cjne sound_flag, #0, $
0880 121130     596       lcall Wait_Half_Second
0883 C28E       596       clr TR1 ; Stop Timer 1 ISR from playing previous request
0885 D2A5       596       setb FLASH_CE
0887            596       ;setb sound_flag ; sound starts
0887 C2A6       596       clr SPEAKER ; Turn off speaker
0889 C2A5       596       clr FLASH_CE ; Enable SPI Flash
088B 7403       596       mov a, #READ_BYTES
088D 12040D     596       lcall Send_SPI
0890            596       ; Set the initial position in memory where to start playing
0890            596       
0890 7404       596       mov a, #0x04 ; change initial position
0892 12040D     596       lcall Send_SPI
0895 74ED       596       mov a, #0xed ; next memory position
0897 12040D     596       lcall Send_SPI
089A 74B8       596       mov a, #0xb8 ; next memory position
089C 12040D     596       lcall Send_SPI
089F 7404       596       mov a, #0x04 ; request first byte to send to DAC
08A1 12040D     596       lcall Send_SPI
08A4            596       
08A4            596       ; How many bytes to play?
08A4 754E00     596       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
08A7 754D1F     596       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
08AA 754C40     596       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
08AD            596       
08AD            596       
08AD D2A6       596       setb SPEAKER ;Turn on speaker
08AF D28E       596       setb TR1 ;Start playback by enabling Timer1
08B1            596       ;clr sound_flag ; sound ends
08B1            597   
08B1            598       state_6_sound_hop1:
08B1 0208B4     599           ljmp state_6_sound
08B4            600           
08B4            601       ;state_8_hop0:
08B4            602           ;ljmp state_6_sound ;state_8_sound
08B4            603   
08B4            604   
08B4            605   state_6_sound:
08B4            606   ; play 1 - 9
08B4            607       ;ljmp PLAYBACK_TEMP
08B4 75F064     608       mov b, #100
08B7 E53B       609       mov a, Temp_oven
08B9 84         610       div ab
08BA E5F0       611       mov a, b
08BC 75F00A     612       mov b, #10
08BF 84         613       div ab
08C0 E5F0       614       mov a, b
08C2            615       
08C2 B40003     616       cjne a, #0x00, play_1
08C5 020AB1     617       ljmp state_8_hop1
08C8            618   
08C8            619       play_1:
08C8 B40134     620           cjne a, #0x01, play_2
08CB            621       ; ***play audio***
08CB            621       ;cjne sound_flag, #0, $
08CB 121130     621       lcall Wait_Half_Second
08CE C28E       621       clr TR1 ; Stop Timer 1 ISR from playing previous request
08D0 D2A5       621       setb FLASH_CE
08D2            621       ;setb sound_flag ; sound starts
08D2 C2A6       621       clr SPEAKER ; Turn off speaker
08D4 C2A5       621       clr FLASH_CE ; Enable SPI Flash
08D6 7403       621       mov a, #READ_BYTES
08D8 12040D     621       lcall Send_SPI
08DB            621       ; Set the initial position in memory where to start playing
08DB            621       
08DB 7401       621       mov a, #0x01 ; change initial position
08DD 12040D     621       lcall Send_SPI
08E0 7493       621       mov a, #0x93 ; next memory position
08E2 12040D     621       lcall Send_SPI
08E5 7484       621       mov a, #0x84 ; next memory position
08E7 12040D     621       lcall Send_SPI
08EA 7401       621       mov a, #0x01 ; request first byte to send to DAC
08EC 12040D     621       lcall Send_SPI
08EF            621       
08EF            621       ; How many bytes to play?
08EF 754E00     621       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
08F2 754D36     621       mov w+1, #0x36 ; Load the middle byte of the number of bytes to play
08F5 754CB0     621       mov w+0, #0xb0 ; Load the low byte of the number of bytes to play
08F8            621       
08F8            621       
08F8 D2A6       621       setb SPEAKER ;Turn on speaker
08FA D28E       621       setb TR1 ;Start playback by enabling Timer1
08FC            621       ;clr sound_flag ; sound ends 
08FC 020AB1     622           ljmp state_8_hop1
08FF            623   
08FF            624       play_2:
08FF B40234     625           cjne a, #0x02, play_3
0902            626       ; ***play audio***
0902            626       ;cjne sound_flag, #0, $
0902 121130     626       lcall Wait_Half_Second
0905 C28E       626       clr TR1 ; Stop Timer 1 ISR from playing previous request
0907 D2A5       626       setb FLASH_CE
0909            626       ;setb sound_flag ; sound starts
0909 C2A6       626       clr SPEAKER ; Turn off speaker
090B C2A5       626       clr FLASH_CE ; Enable SPI Flash
090D 7403       626       mov a, #READ_BYTES
090F 12040D     626       lcall Send_SPI
0912            626       ; Set the initial position in memory where to start playing
0912            626       
0912 7401       626       mov a, #0x01 ; change initial position
0914 12040D     626       lcall Send_SPI
0917 74C7       626       mov a, #0xc7 ; next memory position
0919 12040D     626       lcall Send_SPI
091C 7414       626       mov a, #0x14 ; next memory position
091E 12040D     626       lcall Send_SPI
0921 7401       626       mov a, #0x01 ; request first byte to send to DAC
0923 12040D     626       lcall Send_SPI
0926            626       
0926            626       ; How many bytes to play?
0926 754E00     626       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0929 754D13     626       mov w+1, #0x13 ; Load the middle byte of the number of bytes to play
092C 754C88     626       mov w+0, #0x88 ; Load the low byte of the number of bytes to play
092F            626       
092F            626       
092F D2A6       626       setb SPEAKER ;Turn on speaker
0931 D28E       626       setb TR1 ;Start playback by enabling Timer1
0933            626       ;clr sound_flag ; sound ends
0933 020AB1     627           ljmp state_8_hop1
0936            628   
0936            629       play_3:
0936 B40334     630           cjne a, #0x03, play_4
0939            631       ; ***play audio***
0939            631       ;cjne sound_flag, #0, $
0939 121130     631       lcall Wait_Half_Second
093C C28E       631       clr TR1 ; Stop Timer 1 ISR from playing previous request
093E D2A5       631       setb FLASH_CE
0940            631       ;setb sound_flag ; sound starts
0940 C2A6       631       clr SPEAKER ; Turn off speaker
0942 C2A5       631       clr FLASH_CE ; Enable SPI Flash
0944 7403       631       mov a, #READ_BYTES
0946 12040D     631       lcall Send_SPI
0949            631       ; Set the initial position in memory where to start playing
0949            631       
0949 7401       631       mov a, #0x01 ; change initial position
094B 12040D     631       lcall Send_SPI
094E 74D6       631       mov a, #0xd6 ; next memory position
0950 12040D     631       lcall Send_SPI
0953 7468       631       mov a, #0x68 ; next memory position
0955 12040D     631       lcall Send_SPI
0958 7401       631       mov a, #0x01 ; request first byte to send to DAC
095A 12040D     631       lcall Send_SPI
095D            631       
095D            631       ; How many bytes to play?
095D 754E00     631       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0960 754D23     631       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
0963 754C28     631       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0966            631       
0966            631       
0966 D2A6       631       setb SPEAKER ;Turn on speaker
0968 D28E       631       setb TR1 ;Start playback by enabling Timer1
096A            631       ;clr sound_flag ; sound ends
096A 020AB1     632           ljmp state_8_hop1
096D            633   
096D            634       play_4:
096D B40434     635           cjne a, #0x04, play_5
0970            636       ; ***play audio***
0970            636       ;cjne sound_flag, #0, $
0970 121130     636       lcall Wait_Half_Second
0973 C28E       636       clr TR1 ; Stop Timer 1 ISR from playing previous request
0975 D2A5       636       setb FLASH_CE
0977            636       ;setb sound_flag ; sound starts
0977 C2A6       636       clr SPEAKER ; Turn off speaker
0979 C2A5       636       clr FLASH_CE ; Enable SPI Flash
097B 7403       636       mov a, #READ_BYTES
097D 12040D     636       lcall Send_SPI
0980            636       ; Set the initial position in memory where to start playing
0980            636       
0980 7401       636       mov a, #0x01 ; change initial position
0982 12040D     636       lcall Send_SPI
0985 74F4       636       mov a, #0xf4 ; next memory position
0987 12040D     636       lcall Send_SPI
098A 7400       636       mov a, #0x00 ; next memory position
098C 12040D     636       lcall Send_SPI
098F 7401       636       mov a, #0x01 ; request first byte to send to DAC
0991 12040D     636       lcall Send_SPI
0994            636       
0994            636       ; How many bytes to play?
0994 754E00     636       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0997 754D1B     636       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
099A 754C58     636       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
099D            636       
099D            636       
099D D2A6       636       setb SPEAKER ;Turn on speaker
099F D28E       636       setb TR1 ;Start playback by enabling Timer1
09A1            636       ;clr sound_flag ; sound ends
09A1 020AB1     637           ljmp state_8_hop1
09A4            638   
09A4            639       play_5:
09A4 B40534     640           cjne a, #0x05, play_6
09A7            641       ; ***play audio***
09A7            641       ;cjne sound_flag, #0, $
09A7 121130     641       lcall Wait_Half_Second
09AA C28E       641       clr TR1 ; Stop Timer 1 ISR from playing previous request
09AC D2A5       641       setb FLASH_CE
09AE            641       ;setb sound_flag ; sound starts
09AE C2A6       641       clr SPEAKER ; Turn off speaker
09B0 C2A5       641       clr FLASH_CE ; Enable SPI Flash
09B2 7403       641       mov a, #READ_BYTES
09B4 12040D     641       lcall Send_SPI
09B7            641       ; Set the initial position in memory where to start playing
09B7            641       
09B7 7402       641       mov a, #0x02 ; change initial position
09B9 12040D     641       lcall Send_SPI
09BC 7407       641       mov a, #0x07 ; next memory position
09BE 12040D     641       lcall Send_SPI
09C1 7488       641       mov a, #0x88 ; next memory position
09C3 12040D     641       lcall Send_SPI
09C6 7402       641       mov a, #0x02 ; request first byte to send to DAC
09C8 12040D     641       lcall Send_SPI
09CB            641       
09CB            641       ; How many bytes to play?
09CB 754E00     641       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
09CE 754D1B     641       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
09D1 754C58     641       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
09D4            641       
09D4            641       
09D4 D2A6       641       setb SPEAKER ;Turn on speaker
09D6 D28E       641       setb TR1 ;Start playback by enabling Timer1
09D8            641       ;clr sound_flag ; sound ends
09D8 020AB1     642           ljmp state_8_hop1
09DB            643   
09DB            644       play_6:
09DB B40634     645           cjne a, #0x06, play_7
09DE            646       ; ***play audio***
09DE            646       ;cjne sound_flag, #0, $
09DE 121130     646       lcall Wait_Half_Second
09E1 C28E       646       clr TR1 ; Stop Timer 1 ISR from playing previous request
09E3 D2A5       646       setb FLASH_CE
09E5            646       ;setb sound_flag ; sound starts
09E5 C2A6       646       clr SPEAKER ; Turn off speaker
09E7 C2A5       646       clr FLASH_CE ; Enable SPI Flash
09E9 7403       646       mov a, #READ_BYTES
09EB 12040D     646       lcall Send_SPI
09EE            646       ; Set the initial position in memory where to start playing
09EE            646       
09EE 7402       646       mov a, #0x02 ; change initial position
09F0 12040D     646       lcall Send_SPI
09F3 7426       646       mov a, #0x26 ; next memory position
09F5 12040D     646       lcall Send_SPI
09F8 74C8       646       mov a, #0xc8 ; next memory position
09FA 12040D     646       lcall Send_SPI
09FD 7402       646       mov a, #0x02 ; request first byte to send to DAC
09FF 12040D     646       lcall Send_SPI
0A02            646       
0A02            646       ; How many bytes to play?
0A02 754E00     646       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0A05 754D1F     646       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0A08 754C40     646       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0A0B            646       
0A0B            646       
0A0B D2A6       646       setb SPEAKER ;Turn on speaker
0A0D D28E       646       setb TR1 ;Start playback by enabling Timer1
0A0F            646       ;clr sound_flag ; sound ends
0A0F 020AB1     647           ljmp state_8_hop1
0A12            648   
0A12            649       play_7:
0A12 B40734     650           cjne a, #0x07, play_8
0A15            651       ; ***play audio***
0A15            651       ;cjne sound_flag, #0, $
0A15 121130     651       lcall Wait_Half_Second
0A18 C28E       651       clr TR1 ; Stop Timer 1 ISR from playing previous request
0A1A D2A5       651       setb FLASH_CE
0A1C            651       ;setb sound_flag ; sound starts
0A1C C2A6       651       clr SPEAKER ; Turn off speaker
0A1E C2A5       651       clr FLASH_CE ; Enable SPI Flash
0A20 7403       651       mov a, #READ_BYTES
0A22 12040D     651       lcall Send_SPI
0A25            651       ; Set the initial position in memory where to start playing
0A25            651       
0A25 7402       651       mov a, #0x02 ; change initial position
0A27 12040D     651       lcall Send_SPI
0A2A 7436       651       mov a, #0x36 ; next memory position
0A2C 12040D     651       lcall Send_SPI
0A2F 7468       651       mov a, #0x68 ; next memory position
0A31 12040D     651       lcall Send_SPI
0A34 7402       651       mov a, #0x02 ; request first byte to send to DAC
0A36 12040D     651       lcall Send_SPI
0A39            651       
0A39            651       ; How many bytes to play?
0A39 754E00     651       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0A3C 754D23     651       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
0A3F 754C28     651       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0A42            651       
0A42            651       
0A42 D2A6       651       setb SPEAKER ;Turn on speaker
0A44 D28E       651       setb TR1 ;Start playback by enabling Timer1
0A46            651       ;clr sound_flag ; sound ends
0A46 020AB1     652           ljmp state_8_hop1
0A49            653   
0A49            654       play_8:
0A49 B40834     655           cjne a, #0x08, play_9
0A4C            656       ; ***play audio***
0A4C            656       ;cjne sound_flag, #0, $
0A4C 121130     656       lcall Wait_Half_Second
0A4F C28E       656       clr TR1 ; Stop Timer 1 ISR from playing previous request
0A51 D2A5       656       setb FLASH_CE
0A53            656       ;setb sound_flag ; sound starts
0A53 C2A6       656       clr SPEAKER ; Turn off speaker
0A55 C2A5       656       clr FLASH_CE ; Enable SPI Flash
0A57 7403       656       mov a, #READ_BYTES
0A59 12040D     656       lcall Send_SPI
0A5C            656       ; Set the initial position in memory where to start playing
0A5C            656       
0A5C 7402       656       mov a, #0x02 ; change initial position
0A5E 12040D     656       lcall Send_SPI
0A61 7457       656       mov a, #0x57 ; next memory position
0A63 12040D     656       lcall Send_SPI
0A66 749C       656       mov a, #0x9c ; next memory position
0A68 12040D     656       lcall Send_SPI
0A6B 7402       656       mov a, #0x02 ; request first byte to send to DAC
0A6D 12040D     656       lcall Send_SPI
0A70            656       
0A70            656       ; How many bytes to play?
0A70 754E00     656       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0A73 754D1B     656       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
0A76 754C58     656       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
0A79            656       
0A79            656       
0A79 D2A6       656       setb SPEAKER ;Turn on speaker
0A7B D28E       656       setb TR1 ;Start playback by enabling Timer1
0A7D            656       ;clr sound_flag ; sound ends
0A7D 020AB1     657           ljmp state_8_hop1
0A80            658   
0A80            659       play_9:
0A80            660       ; ***play audio***
0A80            660       ;cjne sound_flag, #0, $
0A80 121130     660       lcall Wait_Half_Second
0A83 C28E       660       clr TR1 ; Stop Timer 1 ISR from playing previous request
0A85 D2A5       660       setb FLASH_CE
0A87            660       ;setb sound_flag ; sound starts
0A87 C2A6       660       clr SPEAKER ; Turn off speaker
0A89 C2A5       660       clr FLASH_CE ; Enable SPI Flash
0A8B 7403       660       mov a, #READ_BYTES
0A8D 12040D     660       lcall Send_SPI
0A90            660       ; Set the initial position in memory where to start playing
0A90            660       
0A90 7402       660       mov a, #0x02 ; change initial position
0A92 12040D     660       lcall Send_SPI
0A95 7469       660       mov a, #0x69 ; next memory position
0A97 12040D     660       lcall Send_SPI
0A9A 7430       660       mov a, #0x30 ; next memory position
0A9C 12040D     660       lcall Send_SPI
0A9F 7402       660       mov a, #0x02 ; request first byte to send to DAC
0AA1 12040D     660       lcall Send_SPI
0AA4            660       
0AA4            660       ; How many bytes to play?
0AA4 754E00     660       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0AA7 754D1F     660       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0AAA 754C40     660       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0AAD            660       
0AAD            660       
0AAD D2A6       660       setb SPEAKER ;Turn on speaker
0AAF D28E       660       setb TR1 ;Start playback by enabling Timer1
0AB1            660       ;clr sound_flag ; sound ends
0AB1            661   
0AB1            662   state_8_hop1:
0AB1            663   ; go to state_8_sound
0AB1 020CDF     664       ljmp state_8_sound
0AB4            665   
0AB4            666   
0AB4            667   state_7_sound:
0AB4            668   ; play 10 - 19
0AB4            669       ;ljmp PLAYBACK_TEMP
0AB4 75F064     670       mov b, #100
0AB7 E53B       671       mov a, Temp_oven
0AB9 84         672       div ab
0ABA E5F0       673       mov a, b
0ABC B40A34     674       cjne a, #0x0a, play_11
0ABF            675       
0ABF            676       ; ***play audio***
0ABF            676       ;cjne sound_flag, #0, $
0ABF 121130     676       lcall Wait_Half_Second
0AC2 C28E       676       clr TR1 ; Stop Timer 1 ISR from playing previous request
0AC4 D2A5       676       setb FLASH_CE
0AC6            676       ;setb sound_flag ; sound starts
0AC6 C2A6       676       clr SPEAKER ; Turn off speaker
0AC8 C2A5       676       clr FLASH_CE ; Enable SPI Flash
0ACA 7403       676       mov a, #READ_BYTES
0ACC 12040D     676       lcall Send_SPI
0ACF            676       ; Set the initial position in memory where to start playing
0ACF            676       
0ACF 7402       676       mov a, #0x02 ; change initial position
0AD1 12040D     676       lcall Send_SPI
0AD4 7484       676       mov a, #0x84 ; next memory position
0AD6 12040D     676       lcall Send_SPI
0AD9 7488       676       mov a, #0x88 ; next memory position
0ADB 12040D     676       lcall Send_SPI
0ADE 7402       676       mov a, #0x02 ; request first byte to send to DAC
0AE0 12040D     676       lcall Send_SPI
0AE3            676       
0AE3            676       ; How many bytes to play?
0AE3 754E00     676       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0AE6 754D17     676       mov w+1, #0x17 ; Load the middle byte of the number of bytes to play
0AE9 754C70     676       mov w+0, #0x70 ; Load the low byte of the number of bytes to play
0AEC            676       
0AEC            676       
0AEC D2A6       676       setb SPEAKER ;Turn on speaker
0AEE D28E       676       setb TR1 ;Start playback by enabling Timer1
0AF0            676       ;clr sound_flag ; sound ends
0AF0 020CDC     677       ljmp state_8_hop2
0AF3            678   
0AF3            679       play_11:
0AF3 B40B34     680           cjne a, #0x0b, play_12
0AF6            681       ; ***play audio***
0AF6            681       ;cjne sound_flag, #0, $
0AF6 121130     681       lcall Wait_Half_Second
0AF9 C28E       681       clr TR1 ; Stop Timer 1 ISR from playing previous request
0AFB D2A5       681       setb FLASH_CE
0AFD            681       ;setb sound_flag ; sound starts
0AFD C2A6       681       clr SPEAKER ; Turn off speaker
0AFF C2A5       681       clr FLASH_CE ; Enable SPI Flash
0B01 7403       681       mov a, #READ_BYTES
0B03 12040D     681       lcall Send_SPI
0B06            681       ; Set the initial position in memory where to start playing
0B06            681       
0B06 7402       681       mov a, #0x02 ; change initial position
0B08 12040D     681       lcall Send_SPI
0B0B 749B       681       mov a, #0x9b ; next memory position
0B0D 12040D     681       lcall Send_SPI
0B10 74F8       681       mov a, #0xf8 ; next memory position
0B12 12040D     681       lcall Send_SPI
0B15 7402       681       mov a, #0x02 ; request first byte to send to DAC
0B17 12040D     681       lcall Send_SPI
0B1A            681       
0B1A            681       ; How many bytes to play?
0B1A 754E00     681       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0B1D 754D1F     681       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0B20 754C40     681       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0B23            681       
0B23            681       
0B23 D2A6       681       setb SPEAKER ;Turn on speaker
0B25 D28E       681       setb TR1 ;Start playback by enabling Timer1
0B27            681       ;clr sound_flag ; sound ends
0B27 020CDC     682           ljmp state_8_hop2
0B2A            683   
0B2A            684       play_12:
0B2A B40C34     685           cjne a, #0x0c, play_13
0B2D            686       ; ***play audio***
0B2D            686       ;cjne sound_flag, #0, $
0B2D 121130     686       lcall Wait_Half_Second
0B30 C28E       686       clr TR1 ; Stop Timer 1 ISR from playing previous request
0B32 D2A5       686       setb FLASH_CE
0B34            686       ;setb sound_flag ; sound starts
0B34 C2A6       686       clr SPEAKER ; Turn off speaker
0B36 C2A5       686       clr FLASH_CE ; Enable SPI Flash
0B38 7403       686       mov a, #READ_BYTES
0B3A 12040D     686       lcall Send_SPI
0B3D            686       ; Set the initial position in memory where to start playing
0B3D            686       
0B3D 7402       686       mov a, #0x02 ; change initial position
0B3F 12040D     686       lcall Send_SPI
0B42 74B7       686       mov a, #0xb7 ; next memory position
0B44 12040D     686       lcall Send_SPI
0B47 7450       686       mov a, #0x50 ; next memory position
0B49 12040D     686       lcall Send_SPI
0B4C 7402       686       mov a, #0x02 ; request first byte to send to DAC
0B4E 12040D     686       lcall Send_SPI
0B51            686       
0B51            686       ; How many bytes to play?
0B51 754E00     686       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0B54 754D1F     686       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0B57 754C40     686       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0B5A            686       
0B5A            686       
0B5A D2A6       686       setb SPEAKER ;Turn on speaker
0B5C D28E       686       setb TR1 ;Start playback by enabling Timer1
0B5E            686       ;clr sound_flag ; sound ends
0B5E 020CDC     687           ljmp state_8_hop2
0B61            688   
0B61            689       play_13:
0B61 B40D34     690           cjne a, #0x0d, play_14
0B64            691       ; ***play audio***
0B64            691       ;cjne sound_flag, #0, $
0B64 121130     691       lcall Wait_Half_Second
0B67 C28E       691       clr TR1 ; Stop Timer 1 ISR from playing previous request
0B69 D2A5       691       setb FLASH_CE
0B6B            691       ;setb sound_flag ; sound starts
0B6B C2A6       691       clr SPEAKER ; Turn off speaker
0B6D C2A5       691       clr FLASH_CE ; Enable SPI Flash
0B6F 7403       691       mov a, #READ_BYTES
0B71 12040D     691       lcall Send_SPI
0B74            691       ; Set the initial position in memory where to start playing
0B74            691       
0B74 7402       691       mov a, #0x02 ; change initial position
0B76 12040D     691       lcall Send_SPI
0B79 74CE       691       mov a, #0xce ; next memory position
0B7B 12040D     691       lcall Send_SPI
0B7E 74C0       691       mov a, #0xc0 ; next memory position
0B80 12040D     691       lcall Send_SPI
0B83 7402       691       mov a, #0x02 ; request first byte to send to DAC
0B85 12040D     691       lcall Send_SPI
0B88            691       
0B88            691       ; How many bytes to play?
0B88 754E00     691       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0B8B 754D2E     691       mov w+1, #0x2e ; Load the middle byte of the number of bytes to play
0B8E 754CE0     691       mov w+0, #0xe0 ; Load the low byte of the number of bytes to play
0B91            691       
0B91            691       
0B91 D2A6       691       setb SPEAKER ;Turn on speaker
0B93 D28E       691       setb TR1 ;Start playback by enabling Timer1
0B95            691       ;clr sound_flag ; sound ends
0B95 020CDC     692           ljmp state_8_hop2
0B98            693   
0B98            694       play_14:
0B98 B40E34     695           cjne a, #0x0e, play_15
0B9B            696       ; ***play audio***
0B9B            696       ;cjne sound_flag, #0, $
0B9B 121130     696       lcall Wait_Half_Second
0B9E C28E       696       clr TR1 ; Stop Timer 1 ISR from playing previous request
0BA0 D2A5       696       setb FLASH_CE
0BA2            696       ;setb sound_flag ; sound starts
0BA2 C2A6       696       clr SPEAKER ; Turn off speaker
0BA4 C2A5       696       clr FLASH_CE ; Enable SPI Flash
0BA6 7403       696       mov a, #READ_BYTES
0BA8 12040D     696       lcall Send_SPI
0BAB            696       ; Set the initial position in memory where to start playing
0BAB            696       
0BAB 7402       696       mov a, #0x02 ; change initial position
0BAD 12040D     696       lcall Send_SPI
0BB0 74F5       696       mov a, #0xf5 ; next memory position
0BB2 12040D     696       lcall Send_SPI
0BB5 74D0       696       mov a, #0xd0 ; next memory position
0BB7 12040D     696       lcall Send_SPI
0BBA 7402       696       mov a, #0x02 ; request first byte to send to DAC
0BBC 12040D     696       lcall Send_SPI
0BBF            696       
0BBF            696       ; How many bytes to play?
0BBF 754E00     696       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0BC2 754D36     696       mov w+1, #0x36 ; Load the middle byte of the number of bytes to play
0BC5 754CB0     696       mov w+0, #0xb0 ; Load the low byte of the number of bytes to play
0BC8            696       
0BC8            696       
0BC8 D2A6       696       setb SPEAKER ;Turn on speaker
0BCA D28E       696       setb TR1 ;Start playback by enabling Timer1
0BCC            696       ;clr sound_flag ; sound ends
0BCC 020CDC     697           ljmp state_8_hop2
0BCF            698   
0BCF            699       play_15:
0BCF B40F34     700           cjne a, #0x0f, play_16
0BD2            701       ; ***play audio***
0BD2            701       ;cjne sound_flag, #0, $
0BD2 121130     701       lcall Wait_Half_Second
0BD5 C28E       701       clr TR1 ; Stop Timer 1 ISR from playing previous request
0BD7 D2A5       701       setb FLASH_CE
0BD9            701       ;setb sound_flag ; sound starts
0BD9 C2A6       701       clr SPEAKER ; Turn off speaker
0BDB C2A5       701       clr FLASH_CE ; Enable SPI Flash
0BDD 7403       701       mov a, #READ_BYTES
0BDF 12040D     701       lcall Send_SPI
0BE2            701       ; Set the initial position in memory where to start playing
0BE2            701       
0BE2 7403       701       mov a, #0x03 ; change initial position
0BE4 12040D     701       lcall Send_SPI
0BE7 7428       701       mov a, #0x28 ; next memory position
0BE9 12040D     701       lcall Send_SPI
0BEC 7498       701       mov a, #0x98 ; next memory position
0BEE 12040D     701       lcall Send_SPI
0BF1 7403       701       mov a, #0x03 ; request first byte to send to DAC
0BF3 12040D     701       lcall Send_SPI
0BF6            701       
0BF6            701       ; How many bytes to play?
0BF6 754E00     701       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0BF9 754D23     701       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
0BFC 754C28     701       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0BFF            701       
0BFF            701       
0BFF D2A6       701       setb SPEAKER ;Turn on speaker
0C01 D28E       701       setb TR1 ;Start playback by enabling Timer1
0C03            701       ;clr sound_flag ; sound ends
0C03 020CDC     702           ljmp state_8_hop2
0C06            703   
0C06            704       play_16:
0C06 B41034     705           cjne a, #0x10, play_17
0C09            706       ; ***play audio***
0C09            706       ;cjne sound_flag, #0, $
0C09 121130     706       lcall Wait_Half_Second
0C0C C28E       706       clr TR1 ; Stop Timer 1 ISR from playing previous request
0C0E D2A5       706       setb FLASH_CE
0C10            706       ;setb sound_flag ; sound starts
0C10 C2A6       706       clr SPEAKER ; Turn off speaker
0C12 C2A5       706       clr FLASH_CE ; Enable SPI Flash
0C14 7403       706       mov a, #READ_BYTES
0C16 12040D     706       lcall Send_SPI
0C19            706       ; Set the initial position in memory where to start playing
0C19            706       
0C19 7403       706       mov a, #0x03 ; change initial position
0C1B 12040D     706       lcall Send_SPI
0C1E 7447       706       mov a, #0x47 ; next memory position
0C20 12040D     706       lcall Send_SPI
0C23 74D8       706       mov a, #0xd8 ; next memory position
0C25 12040D     706       lcall Send_SPI
0C28 7403       706       mov a, #0x03 ; request first byte to send to DAC
0C2A 12040D     706       lcall Send_SPI
0C2D            706       
0C2D            706       ; How many bytes to play?
0C2D 754E00     706       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0C30 754D32     706       mov w+1, #0x32 ; Load the middle byte of the number of bytes to play
0C33 754CC8     706       mov w+0, #0xc8 ; Load the low byte of the number of bytes to play
0C36            706       
0C36            706       
0C36 D2A6       706       setb SPEAKER ;Turn on speaker
0C38 D28E       706       setb TR1 ;Start playback by enabling Timer1
0C3A            706       ;clr sound_flag ; sound ends
0C3A 020CDC     707           ljmp state_8_hop2
0C3D            708   
0C3D            709       play_17:
0C3D B41134     710           cjne a, #0x11, play_18
0C40            711       ; ***play audio***
0C40            711       ;cjne sound_flag, #0, $
0C40 121130     711       lcall Wait_Half_Second
0C43 C28E       711       clr TR1 ; Stop Timer 1 ISR from playing previous request
0C45 D2A5       711       setb FLASH_CE
0C47            711       ;setb sound_flag ; sound starts
0C47 C2A6       711       clr SPEAKER ; Turn off speaker
0C49 C2A5       711       clr FLASH_CE ; Enable SPI Flash
0C4B 7403       711       mov a, #READ_BYTES
0C4D 12040D     711       lcall Send_SPI
0C50            711       ; Set the initial position in memory where to start playing
0C50            711       
0C50 7403       711       mov a, #0x03 ; change initial position
0C52 12040D     711       lcall Send_SPI
0C55 7476       711       mov a, #0x76 ; next memory position
0C57 12040D     711       lcall Send_SPI
0C5A 74B8       711       mov a, #0xb8 ; next memory position
0C5C 12040D     711       lcall Send_SPI
0C5F 7403       711       mov a, #0x03 ; request first byte to send to DAC
0C61 12040D     711       lcall Send_SPI
0C64            711       
0C64            711       ; How many bytes to play?
0C64 754E00     711       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0C67 754D2E     711       mov w+1, #0x2e ; Load the middle byte of the number of bytes to play
0C6A 754C20     711       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
0C6D            711       
0C6D            711       
0C6D D2A6       711       setb SPEAKER ;Turn on speaker
0C6F D28E       711       setb TR1 ;Start playback by enabling Timer1
0C71            711       ;clr sound_flag ; sound ends
0C71 020CDC     712           ljmp state_8_hop2
0C74            713   
0C74            714       play_18:
0C74 B41234     715           cjne a, #0x12, play_19
0C77            716       ; ***play audio***
0C77            716       ;cjne sound_flag, #0, $
0C77 121130     716       lcall Wait_Half_Second
0C7A C28E       716       clr TR1 ; Stop Timer 1 ISR from playing previous request
0C7C D2A5       716       setb FLASH_CE
0C7E            716       ;setb sound_flag ; sound starts
0C7E C2A6       716       clr SPEAKER ; Turn off speaker
0C80 C2A5       716       clr FLASH_CE ; Enable SPI Flash
0C82 7403       716       mov a, #READ_BYTES
0C84 12040D     716       lcall Send_SPI
0C87            716       ; Set the initial position in memory where to start playing
0C87            716       
0C87 7403       716       mov a, #0x03 ; change initial position
0C89 12040D     716       lcall Send_SPI
0C8C 74A1       716       mov a, #0xa1 ; next memory position
0C8E 12040D     716       lcall Send_SPI
0C91 74B0       716       mov a, #0xb0 ; next memory position
0C93 12040D     716       lcall Send_SPI
0C96 7403       716       mov a, #0x03 ; request first byte to send to DAC
0C98 12040D     716       lcall Send_SPI
0C9B            716       
0C9B            716       ; How many bytes to play?
0C9B 754E00     716       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0C9E 754D27     716       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0CA1 754C10     716       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0CA4            716       
0CA4            716       
0CA4 D2A6       716       setb SPEAKER ;Turn on speaker
0CA6 D28E       716       setb TR1 ;Start playback by enabling Timer1
0CA8            716       ;clr sound_flag ; sound ends
0CA8 020CDC     717           ljmp state_8_hop2
0CAB            718   
0CAB            719       play_19:
0CAB            720       ; ***play audio***
0CAB            720       ;cjne sound_flag, #0, $
0CAB 121130     720       lcall Wait_Half_Second
0CAE C28E       720       clr TR1 ; Stop Timer 1 ISR from playing previous request
0CB0 D2A5       720       setb FLASH_CE
0CB2            720       ;setb sound_flag ; sound starts
0CB2 C2A6       720       clr SPEAKER ; Turn off speaker
0CB4 C2A5       720       clr FLASH_CE ; Enable SPI Flash
0CB6 7403       720       mov a, #READ_BYTES
0CB8 12040D     720       lcall Send_SPI
0CBB            720       ; Set the initial position in memory where to start playing
0CBB            720       
0CBB 7403       720       mov a, #0x03 ; change initial position
0CBD 12040D     720       lcall Send_SPI
0CC0 74C8       720       mov a, #0xc8 ; next memory position
0CC2 12040D     720       lcall Send_SPI
0CC5 74C0       720       mov a, #0xc0 ; next memory position
0CC7 12040D     720       lcall Send_SPI
0CCA 7403       720       mov a, #0x03 ; request first byte to send to DAC
0CCC 12040D     720       lcall Send_SPI
0CCF            720       
0CCF            720       ; How many bytes to play?
0CCF 754E00     720       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0CD2 754D27     720       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0CD5 754C10     720       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0CD8            720       
0CD8            720       
0CD8 D2A6       720       setb SPEAKER ;Turn on speaker
0CDA D28E       720       setb TR1 ;Start playback by enabling Timer1
0CDC            720       ;clr sound_flag ; sound ends
0CDC            721   
0CDC            722       state_8_hop2:
0CDC            723       ; go to state_8_sound
0CDC 020CDF     724           ljmp state_8_sound
0CDF            725   
0CDF            726   state_8_sound:
0CDF            727   ; go to state_0_sound
0CDF 0205B9     728       ljmp Sound_ret
0CE2            729   
0CE2            730   
0CE2            731   INI_PLAYBACK_TEMP:
0CE2            732       ; ****INITIALIZATION****
0CE2            733       ; Configure SPI pins and turn off speaker
0CE2            734            ;anl P2M0, #0b_1100_1110
0CE2 43CE90     735       orl P2M0, #0b_1001_0000
0CE5            736       ;orl P2M0, #0b_0011_0001
0CE5            737            ;orl P2M1, #0b_0011_0001
0CE5 43CF90     738       orl P2M1, #0b_1001_0000
0CE8 D2A1       739            setb MY_MISO_SOUND  ; Configured as input
0CEA D2A5       740            setb FLASH_CE ; CS=1 for SPI flash memory
0CEC C2A0       741            clr MY_SCLK_SOUND   ; Rest state of SCLK=0
0CEE C2A6       742            clr SPEAKER   ; Turn off speaker.
0CF0            743            
0CF0            744            ; Configure timer 1
0CF0 53890F     745            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
0CF3 438910     746            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
0CF6 758DFC     747            mov TH1, #high(TIMER1_RELOAD)
0CF9 758B8C     748            mov TL1, #low(TIMER1_RELOAD)
0CFC            749            ; Set autoreload value
0CFC 75F5FC     750            mov RH1, #high(TIMER1_RELOAD)
0CFF 75F38C     751            mov RL1, #low(TIMER1_RELOAD)
0D02            752   
0D02            753            ;Enable the timer and interrupts
0D02 D2AB       754       setb ET1  ; Enable timer 1 interrupt
0D04 D28E       755            setb TR1 ; Timer 1 is only enabled to play stored sound
0D06            756   
0D06            757            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
0D06 75A5A0     758            mov DADI, #0b_1010_0000 ; ACON=1
0D09 75A43A     759            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0D0C 75AD80     760            mov DADH, #0x80 ; Middle of scale
0D0F 75AC00     761            mov DADL, #0
0D12 43A440     762            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
0D15            763       check_DAC_init:
0D15 E5A4       764            mov a, DADC
0D17 20E6FB     765            jb acc.6, check_DAC_init ; Wait for DAC to finish
0D1A            766            
0D1A 22         767   ret
0D1B            768   
0D1B            769       
0D1B            770   ;-------------------------------------------------------------------------------------------------------------------------------
0D1B            771   ;***LCD FXNS
0D1B            772   
                773   Display_lower_BCD mac
                774       push ar0
                775       mov r0, %0
                776       lcall ?Display_lower_BCD
                777       pop ar0
                778   endmac
0D1B            779   
0D1B            780   ?Display_lower_BCD:
0D1B C0E0       781       push acc
0D1D            782       ; write least significant digit
0D1D E8         783       mov a, r0
0D1E 540F       784       anl a, #0fh
0D20 4430       785       orl a, #30h
0D22 12007E     786       lcall ?WriteData
0D25 D0E0       787       pop acc
0D27 22         788   ret
0D28            789   
0D28            790   
0D28            791   SendToLCD:
0D28 75F064     792       mov b, #100
0D2B 84         793       div ab
0D2C 4430       794       orl a, #0x30h ; Convert hundreds to ASCII
0D2E 12007E     795       lcall ?WriteData ; Send to LCD
0D31 E5F0       796       mov a, b    ; Remainder is in register b
0D33 75F00A     797       mov b, #10
0D36 84         798       div ab
0D37 4430       799       orl a, #0x30h ; Convert tens to ASCII
0D39 12007E     800       lcall ?WriteData; Send to LCD
0D3C E5F0       801       mov a, b
0D3E 4430       802       orl a, #0x30h ; Convert units to ASCII
0D40 12007E     803       lcall ?WriteData; Send to LCD
0D43 22         804   ret
0D44            805   
0D44            806   Initialize_State_Display:
0D44            807   
0D44            808       ;***clear the screen and set new display***
0D44 7401       809            mov a, #0x01
0D46 120083     809            lcall ?WriteCommand
0D49 C002       810            push AR2
0D4B 7A02       810            mov R2, #2
0D4D 120039     810            lcall ?Wait_Milli_Seconds
0D50 D002       810            pop AR2
0D52            811       
0D52 C0E0       812            push acc
0D54 7401       812            mov a, #1
0D56 14         812            dec a
0D57 1200BF     812            lcall ?Set_Cursor_1 ; Select column and row
0D5A D0E0       812            pop acc
0D5C C083       813            push dph
0D5E C082       813            push dpl
0D60 C0E0       813            push acc
0D62 90037D     813            mov dptr, #time
0D65 1200B2     813            lcall ?Send_Constant_String
0D68 D0E0       813            pop acc
0D6A D082       813            pop dpl
0D6C D083       813            pop dph
0D6E            814            
0D6E C0E0       815            push acc
0D70 7406       815            mov a, #6
0D72 14         815            dec a
0D73 1200BF     815            lcall ?Set_Cursor_1 ; Select column and row
0D76 D0E0       815            pop acc
0D78 C083       816            push dph
0D7A C082       816            push dpl
0D7C C0E0       816            push acc
0D7E 900382     816            mov dptr, #colon
0D81 1200B2     816            lcall ?Send_Constant_String
0D84 D0E0       816            pop acc
0D86 D082       816            pop dpl
0D88 D083       816            pop dph
0D8A            817      
0D8A C0E0       818            push acc
0D8C 740A       818            mov a, #10
0D8E 14         818            dec a
0D8F 1200BF     818            lcall ?Set_Cursor_1 ; Select column and row
0D92 D0E0       818            pop acc
0D94 C083       819            push dph
0D96 C082       819            push dpl
0D98 C0E0       819            push acc
0D9A 900384     819            mov dptr, #temp
0D9D 1200B2     819            lcall ?Send_Constant_String
0DA0 D0E0       819            pop acc
0DA2 D082       819            pop dpl
0DA4 D083       819            pop dph
0DA6            820       
0DA6 C0E0       821            push acc
0DA8 7401       821            mov a, #1
0DAA 14         821            dec a
0DAB 1200BD     821            lcall ?Set_Cursor_2 ; Select column and row
0DAE D0E0       821            pop acc
0DB0 C083       822            push dph
0DB2 C082       822            push dpl
0DB4 C0E0       822            push acc
0DB6 900376     822            mov dptr, #state
0DB9 1200B2     822            lcall ?Send_Constant_String
0DBC D0E0       822            pop acc
0DBE D082       822            pop dpl
0DC0 D083       822            pop dph
0DC2 22         823   ret
0DC3            824   
0DC3            825   Update_Display:
0DC3 C0E0       826            push acc
0DC5 7405       826            mov a, #5
0DC7 14         826            dec a
0DC8 1200BF     826            lcall ?Set_Cursor_1 ; Select column and row
0DCB D0E0       826            pop acc
0DCD C000       827       push ar0
0DCF A839       827       mov r0, Run_time_minutes
0DD1 120D1B     827       lcall ?Display_lower_BCD
0DD4 D000       827       pop ar0
0DD6 C0E0       828            push acc
0DD8 7407       828            mov a, #7
0DDA 14         828            dec a
0DDB 1200BF     828            lcall ?Set_Cursor_1 ; Select column and row
0DDE D0E0       828            pop acc
0DE0 C000       829            push ar0
0DE2 A838       829            mov r0, Run_time_seconds
0DE4 1200C4     829            lcall ?Display_BCD
0DE7 D000       829            pop ar0
0DE9            830       ;Set_Cursor(1,14)
0DE9            831       ;mov a, Temp_oven
0DE9            832       ;SendToLCD(Temp_oven)
0DE9 22         833   ret
0DEA            834   
0DEA            835   State0_display:
0DEA C0E0       836            push acc
0DEC 7401       836            mov a, #1
0DEE 14         836            dec a
0DEF 1200BF     836            lcall ?Set_Cursor_1 ; Select column and row
0DF2 D0E0       836            pop acc
0DF4 C083       837            push dph
0DF6 C082       837            push dpl
0DF8 C0E0       837            push acc
0DFA 900360     837            mov dptr, #STemp
0DFD 1200B2     837            lcall ?Send_Constant_String
0E00 D0E0       837            pop acc
0E02 D082       837            pop dpl
0E04 D083       837            pop dph
0E06 C0E0       838            push acc
0E08 7406       838            mov a, #6
0E0A 14         838            dec a
0E0B 1200BF     838            lcall ?Set_Cursor_1 ; Select column and row
0E0E D0E0       838            pop acc
0E10 E534       839       mov a, Temp_soak
0E12 120D28     840       lcall SendToLCD
0E15            841       
0E15 C0E0       842            push acc
0E17 740A       842            mov a, #10
0E19 14         842            dec a
0E1A 1200BF     842            lcall ?Set_Cursor_1 ; Select column and row
0E1D D0E0       842            pop acc
0E1F C083       843            push dph
0E21 C082       843            push dpl
0E23 C0E0       843            push acc
0E25 900366     843            mov dptr, #STime
0E28 1200B2     843            lcall ?Send_Constant_String
0E2B D0E0       843            pop acc
0E2D D082       843            pop dpl
0E2F D083       843            pop dph
0E31 C0E0       844            push acc
0E33 740E       844            mov a, #14
0E35 14         844            dec a
0E36 1200BF     844            lcall ?Set_Cursor_1 ; Select column and row
0E39 D0E0       844            pop acc
0E3B E535       845       mov a, Time_soak
0E3D 120D28     846            lcall SendToLCD
0E40            847       ;Display_BCD(Time_soak)
0E40            848   
0E40            849       ;Displays Reflow Temp and Time
0E40 C0E0       850            push acc
0E42 7401       850            mov a, #1
0E44 14         850            dec a
0E45 1200BD     850            lcall ?Set_Cursor_2 ; Select column and row
0E48 D0E0       850            pop acc
0E4A C083       851            push dph
0E4C C082       851            push dpl
0E4E C0E0       851            push acc
0E50 90036B     851            mov dptr, #RTemp
0E53 1200B2     851            lcall ?Send_Constant_String
0E56 D0E0       851            pop acc
0E58 D082       851            pop dpl
0E5A D083       851            pop dph
0E5C C0E0       852            push acc
0E5E 7406       852            mov a, #6
0E60 14         852            dec a
0E61 1200BD     852            lcall ?Set_Cursor_2 ; Select column and row
0E64 D0E0       852            pop acc
0E66 E536       853       mov a, Temp_refl
0E68 120D28     854       lcall SendToLCD
0E6B            855       
0E6B C0E0       856            push acc
0E6D 740A       856            mov a, #10
0E6F 14         856            dec a
0E70 1200BD     856            lcall ?Set_Cursor_2 ; Select column and row
0E73 D0E0       856            pop acc
0E75 C083       857            push dph
0E77 C082       857            push dpl
0E79 C0E0       857            push acc
0E7B 900371     857            mov dptr, #RTime
0E7E 1200B2     857            lcall ?Send_Constant_String
0E81 D0E0       857            pop acc
0E83 D082       857            pop dpl
0E85 D083       857            pop dph
0E87 C0E0       858            push acc
0E89 740E       858            mov a, #14
0E8B 14         858            dec a
0E8C 1200BD     858            lcall ?Set_Cursor_2 ; Select column and row
0E8F D0E0       858            pop acc
0E91 E537       859       mov a, Time_refl
0E93 120D28     860            lcall SendToLCD
0E96 22         861   ret
0E97            862   
0E97            863   Display_3_digit_BCD:
0E97 C0E0       864            push acc
0E99 740E       864            mov a, #14
0E9B 14         864            dec a
0E9C 1200BF     864            lcall ?Set_Cursor_1 ; Select column and row
0E9F D0E0       864            pop acc
0EA1 C000       865       push ar0
0EA3 A846       865       mov r0, bcd+1
0EA5 120D1B     865       lcall ?Display_lower_BCD
0EA8 D000       865       pop ar0
0EAA C000       866            push ar0
0EAC A845       866            mov r0, bcd+0
0EAE 1200C4     866            lcall ?Display_BCD
0EB1 D000       866            pop ar0
0EB3 22         867   ret
0EB4            868   
0EB4            869   Animation:
0EB4 740F       870            mov a, #0x0f
0EB6 120083     870            lcall ?WriteCommand ;display cursor
0EB9            871   
0EB9            872       ;name ; Move cursor to line 1 column 1
0EB9 7480       873            mov a, #0x80
0EBB 120083     873            lcall ?WriteCommand
0EBE 7457       874            mov a, #'W'
0EC0 12007E     874            lcall ?WriteData
0EC3 C002       875            push AR2
0EC5 7AFA       875            mov R2, #250
0EC7 120039     875            lcall ?Wait_Milli_Seconds
0ECA D002       875            pop AR2
0ECC 7465       876            mov a, #'e'
0ECE 12007E     876            lcall ?WriteData
0ED1 C002       877            push AR2
0ED3 7AFA       877            mov R2, #250
0ED5 120039     877            lcall ?Wait_Milli_Seconds
0ED8 D002       877            pop AR2
0EDA 746C       878            mov a, #'l'
0EDC 12007E     878            lcall ?WriteData
0EDF C002       879            push AR2
0EE1 7AFA       879            mov R2, #250
0EE3 120039     879            lcall ?Wait_Milli_Seconds
0EE6 D002       879            pop AR2
0EE8 7463       880            mov a, #'c'
0EEA 12007E     880            lcall ?WriteData
0EED C002       881            push AR2
0EEF 7AFA       881            mov R2, #250
0EF1 120039     881            lcall ?Wait_Milli_Seconds
0EF4 D002       881            pop AR2
0EF6 746F       882            mov a, #'o'
0EF8 12007E     882            lcall ?WriteData
0EFB C002       883            push AR2
0EFD 7AFA       883            mov R2, #250
0EFF 120039     883            lcall ?Wait_Milli_Seconds
0F02 D002       883            pop AR2
0F04 746D       884            mov a, #'m'
0F06 12007E     884            lcall ?WriteData
0F09 C002       885            push AR2
0F0B 7AFA       885            mov R2, #250
0F0D 120039     885            lcall ?Wait_Milli_Seconds
0F10 D002       885            pop AR2
0F12 7465       886            mov a, #'e'
0F14 12007E     886            lcall ?WriteData
0F17 C002       887            push AR2
0F19 7AFA       887            mov R2, #250
0F1B 120039     887            lcall ?Wait_Milli_Seconds
0F1E D002       887            pop AR2
0F20 7421       888            mov a, #'!'
0F22 12007E     888            lcall ?WriteData
0F25 C002       889            push AR2
0F27 7AFA       889            mov R2, #250
0F29 120039     889            lcall ?Wait_Milli_Seconds
0F2C D002       889            pop AR2
0F2E 7420       890            mov a, #' '
0F30 12007E     890            lcall ?WriteData
0F33 C002       891            push AR2
0F35 7AFA       891            mov R2, #250
0F37 120039     891            lcall ?Wait_Milli_Seconds
0F3A D002       891            pop AR2
0F3C 7460       892            mov a, #96
0F3E 12007E     892            lcall ?WriteData
0F41 C002       893            push AR2
0F43 7AFA       893            mov R2, #250
0F45 120039     893            lcall ?Wait_Milli_Seconds
0F48 D002       893            pop AR2
0F4A 74EF       894            mov a, #239
0F4C 12007E     894            lcall ?WriteData
0F4F C002       895            push AR2
0F51 7AFA       895            mov R2, #250
0F53 120039     895            lcall ?Wait_Milli_Seconds
0F56 D002       895            pop AR2
0F58 742F       896            mov a, #47
0F5A 12007E     896            lcall ?WriteData
0F5D 12110B     897       lcall Wait_One_Second
0F60 12110B     898       lcall Wait_One_Second
0F63 740C       899            mov a, #0x0c
0F65 120083     899            lcall ?WriteCommand ;clear cursor
0F68 22         900   ret
0F69            901   
0F69            902   ;The following functions store and restore the values--------------------------------------------------------------------------
                903   loadbyte mac
                904       mov a, %0
                905       movx @dptr, a
                906       inc dptr
                907   endmac
0F69            908   
0F69            909   Save_Configuration1:
0F69 C0A8       910       push IE ; Save the current state of bit EA in the stack
0F6B C2AF       911       clr EA ; Disable interrupts
0F6D 75D108     912       mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
0F70 907F80     913       mov dptr, #0x7f80 ; Last page of flash memory
0F73            914       ; Save variables
0F73 E534       915       mov a, temp_soak
0F75 F0         915       movx @dptr, a
0F76 A3         915       inc dptr ; @0x7f80
0F77 E535       916       mov a, time_soak
0F79 F0         916       movx @dptr, a
0F7A A3         916       inc dptr ; @0x7f81
0F7B E536       917       mov a, temp_refl
0F7D F0         917       movx @dptr, a
0F7E A3         917       inc dptr ; @0x7f82
0F7F E537       918       mov a, time_refl
0F81 F0         918       movx @dptr, a
0F82 A3         918       inc dptr ; @0x7f83
0F83 7455       919       mov a, #0x55
0F85 F0         919       movx @dptr, a
0F86 A3         919       inc dptr ; First key value @0x7f84
0F87 74AA       920       mov a, #0xAA
0F89 F0         920       movx @dptr, a
0F8A A3         920       inc dptr ; Second key value @0x7f85
0F8B 75D100     921       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0) 
0F8E 43D240     922       orl EECON, #0b01000000 ; Enable auto-erase on next write sequence  
0F91 75D150     923       mov FCON, #0x50 ; Write trigger first byte
0F94 75D1A0     924       mov FCON, #0xA0 ; Write trigger second byte
0F97            925       ; CPU idles until writing of flash completes.
0F97 75D100     926       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
0F9A 53D2BF     927       anl EECON, #0b10111111 ; Disable auto-erase
0F9D D0A8       928       pop IE ; Restore the state of bit EA from the stack
0F9F 22         929   ret
0FA0            930   
0FA0            931   Save_Configuration2:
0FA0 C0A8       932       push IE ; Save the current state of bit EA in the stack
0FA2 C2AF       933       clr EA ; Disable interrupts
0FA4 75D108     934       mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
0FA7 907F00     935       mov dptr, #0x7f00 ; Second Last page of flash memory
0FAA            936       ; Save variables
0FAA E534       937       mov a, temp_soak
0FAC F0         937       movx @dptr, a
0FAD A3         937       inc dptr ; @0x7f00
0FAE E535       938       mov a, time_soak
0FB0 F0         938       movx @dptr, a
0FB1 A3         938       inc dptr ; @0x7f01
0FB2 E536       939       mov a, temp_refl
0FB4 F0         939       movx @dptr, a
0FB5 A3         939       inc dptr ; @0x7f02
0FB6 E537       940       mov a, time_refl
0FB8 F0         940       movx @dptr, a
0FB9 A3         940       inc dptr ; @0x7f03
0FBA 7444       941       mov a, #0x44
0FBC F0         941       movx @dptr, a
0FBD A3         941       inc dptr ; First key value @0x7f04
0FBE 74BB       942       mov a, #0xBB
0FC0 F0         942       movx @dptr, a
0FC1 A3         942       inc dptr ; Second key value @0x7f05
0FC2 75D100     943       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0) 
0FC5 43D240     944       orl EECON, #0b01000000 ; Enable auto-erase on next write sequence  
0FC8 75D150     945       mov FCON, #0x50 ; Write trigger first byte
0FCB 75D1A0     946       mov FCON, #0xA0 ; Write trigger second byte
0FCE            947       ; CPU idles until writing of flash completes.
0FCE 75D100     948       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
0FD1 53D2BF     949       anl EECON, #0b10111111 ; Disable auto-erase
0FD4 D0A8       950       pop IE ; Restore the state of bit EA from the stack
0FD6 22         951   ret
0FD7            952   
                953   getbyte mac
                954       clr a
                955       movc a, @a+dptr
                956       mov %0, a
                957       inc dptr
                958   endmac
0FD7            959   
0FD7            960   Load_Configuration1:
0FD7 907F84     961       mov dptr, #0x7f84 ; First key value location.
0FDA E4         962       clr a
0FDB 93         962       movc a, @a+dptr
0FDC F8         962       mov R0, a
0FDD A3         962       inc dptr ; 0x7f84 should contain 0x55
0FDE B85548     963       cjne R0, #0x55, Load_Defaults1
0FE1 E4         964       clr a
0FE2 93         964       movc a, @a+dptr
0FE3 F8         964       mov R0, a
0FE4 A3         964       inc dptr ; 0x7f85 should contain 0xAA
0FE5 B8AA41     965       cjne R0, #0xAA, Load_Defaults1
0FE8            966   ; Keys are good.  Get stored values.
0FE8 907F80     967       mov dptr, #0x7f80
0FEB E4         968       clr a
0FEC 93         968       movc a, @a+dptr
0FED F534       968       mov Temp_soak, a
0FEF A3         968       inc dptr ; 0x7f80
0FF0 E4         969       clr a
0FF1 93         969       movc a, @a+dptr
0FF2 F535       969       mov Time_soak, a
0FF4 A3         969       inc dptr ; 0x7f81
0FF5 E4         970       clr a
0FF6 93         970       movc a, @a+dptr
0FF7 F536       970       mov Temp_refl, a
0FF9 A3         970       inc dptr ; 0x7f82
0FFA E4         971       clr a
0FFB 93         971       movc a, @a+dptr
0FFC F537       971       mov Time_refl, a
0FFE A3         971       inc dptr ; 0x7f83
0FFF 22         972   ret
1000            973   
1000            974   Load_Configuration2:
1000 907F04     975       mov dptr, #0x7f04 ; First key value location.
1003 E4         976       clr a
1004 93         976       movc a, @a+dptr
1005 F8         976       mov R0, a
1006 A3         976       inc dptr ; 0x7f04 should contain 0x44
1007 B8442C     977       cjne R0, #0x44, Load_Defaults2
100A E4         978       clr a
100B 93         978       movc a, @a+dptr
100C F8         978       mov R0, a
100D A3         978       inc dptr ; 0x7f05 should contain 0xBB
100E B8BB25     979       cjne R0, #0xBB, Load_Defaults2
1011            980   ; Keys are good.  Get stored values.
1011 907F00     981       mov dptr, #0x7f00
1014 E4         982       clr a
1015 93         982       movc a, @a+dptr
1016 F534       982       mov Temp_soak, a
1018 A3         982       inc dptr ; 0x7f00
1019 E4         983       clr a
101A 93         983       movc a, @a+dptr
101B F535       983       mov Time_soak, a
101D A3         983       inc dptr ; 0x7f01
101E E4         984       clr a
101F 93         984       movc a, @a+dptr
1020 F536       984       mov Temp_refl, a
1022 A3         984       inc dptr ; 0x7f02
1023 E4         985       clr a
1024 93         985       movc a, @a+dptr
1025 F537       985       mov Time_refl, a
1027 A3         985       inc dptr ; 0x7f03
1028 22         986   ret
1029            987   
1029            988   Load_Defaults1:
1029 753482     989       mov Temp_soak, #130 ; Soak Tmp Range is 130-170
102C 75353C     990       mov Time_soak, #60 ; Range 60-90 seconds
102F 7536DC     991       mov Temp_refl, #220 ; Range 220-240
1032 75371E     992       mov Time_refl, #30 ; Range 30-45 seconds
1035 22         993       ret
1036            994   
1036            995   Load_Defaults2:
1036 75348C     996       mov Temp_soak, #140 ; Soak Tmp Range is 130-170
1039 75354B     997       mov Time_soak, #75 ; Range 60-90 seconds
103C 7536E6     998       mov Temp_refl, #230 ; Range 220-240
103F 753723     999       mov Time_refl, #35 ; Range 30-45 seconds
1042 22        1000       ret
1043           1001   ;-------------------------------------------------------------------------------------------------------------------------------
1043           1002   ;off state
1043           1003   
1043           1004   OFF_STATE:
1043           1005       ;**CLEAR SCREEN**
1043 7401      1006            mov a, #0x01
1045 120083    1006            lcall ?WriteCommand
1048           1007       ;OFF_STATE1:
1048           1008       
1048 20C5FD    1009       jb POWER_BUTTON, $ ; loop while the button is not pressed
104B C002      1010            push AR2
104D 7A32      1010            mov R2, #50
104F 120039    1010            lcall ?Wait_Milli_Seconds
1052 D002      1010            pop AR2 ; debounce time
1054 20C5EC    1011            jb POWER_BUTTON, OFF_STATE ; it was a bounce, try again
1057 30C5FD    1012            jnb POWER_BUTTON, $ ; loop while the button is pressed
105A 0211F4    1013       ljmp main
105D 22        1014   ret
105E           1015   ;-------------------------------------------------------------------------------------------------------------------------------
105E           1016   
105E           1017   ;***CHECK TEMPERATURE BY READING VOLTAGE AND CONVERTING
105E           1018   Check_Temp:
105E           1019       
105E           1020       ;jnb one_seconds_flag, Check_Temp_done
105E           1021       ;clr one_seconds_flag
105E           1022       
105E C297      1023       clr CE_ADC
1060 7801      1024            mov R0, #00000001B ; Start bit:1
1062 1203F4    1025            lcall DO_SPI_G
1065 7880      1026            mov R0, #10000000B ; Single ended, read channel 0
1067 1203F4    1027            lcall DO_SPI_G
106A E9        1028            mov a, R1          ; R1 contains bits 8 and 9
106B 5403      1029            anl a, #00000011B  ; We need only the two least significant bits
106D F54B      1030            mov Result+1, a    ; Save result high.
106F 7855      1031            mov R0, #55H ; It doesn't matter what we transmit...
1071 1203F4    1032            lcall DO_SPI_G
1074 894A      1033            mov Result+0, R1     ; R1 contains bits 0 to 7.  Save result low.
1076 D297      1034            setb CE_ADC
1078           1035   
1078 C002      1036            push AR2
107A 7A0A      1036            mov R2, #10
107C 120039    1036            lcall ?Wait_Milli_Seconds
107F D002      1036            pop AR2
1081           1037       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
1081 AE4A      1038            mov R6, Result+0
1083 AF4B      1039            mov R7, Result+1
1085 22        1040   ret
1086           1041   
1086           1042       
1086           1043       
1086           1044   ;***CALCULATES THE TEMPERATURE
1086           1045   Average_Temp:
1086 753D00    1046            mov x+0, #low (0 % 0x10000) 
1089 753E00    1046            mov x+1, #high(0 % 0x10000) 
108C 753F00    1046            mov x+2, #low (0 / 0x10000) 
108F 754000    1046            mov x+3, #high(0 / 0x10000) 
1092 7D64      1047       mov R5, #100
1094           1048   Ave_loop:
1094 12105E    1049       lcall Check_Temp
1097 754400    1050       mov y+3, #0
109A 754300    1051       mov y+2, #0
109D 8F42      1052       mov y+1, R7
109F 8E41      1053       mov y+0, R6
10A1 1201B5    1054       lcall add32
10A4 121143    1055       lcall Wait10us
10A7 DDEB      1056       djnz R5, Ave_loop
10A9 754164    1057            mov y+0, #low (100 % 0x10000) 
10AC 754200    1057            mov y+1, #high(100 % 0x10000) 
10AF 754300    1057            mov y+2, #low (100 / 0x10000) 
10B2 754400    1057            mov y+3, #high(100 / 0x10000) 
10B5 1202F7    1058       lcall div32
10B8           1059   
10B8           1060       ;**INSERT MATH FUNCTIONS
10B8           1061   
10B8 75414E    1062            mov y+0, #low (2894 % 0x10000) 
10BB 75420B    1062            mov y+1, #high(2894 % 0x10000) 
10BE 754300    1062            mov y+2, #low (2894 / 0x10000) 
10C1 754400    1062            mov y+3, #high(2894 / 0x10000)  ;6078; 2026
10C4 12026A    1063            lcall mul32
10C7 754110    1064            mov y+0, #low (10000 % 0x10000) 
10CA 754227    1064            mov y+1, #high(10000 % 0x10000) 
10CD 754300    1064            mov y+2, #low (10000 / 0x10000) 
10D0 754400    1064            mov y+3, #high(10000 / 0x10000)  ;14000; 7000
10D3 1202F7    1065            lcall div32
10D6 754116    1066            mov y+0, #low (22 % 0x10000) 
10D9 754200    1066            mov y+1, #high(22 % 0x10000) 
10DC 754300    1066            mov y+2, #low (22 / 0x10000) 
10DF 754400    1066            mov y+3, #high(22 / 0x10000) 
10E2 1201B5    1067       lcall add32
10E5 853D3B    1068       mov Temp_oven, x+0
10E8           1069       ;add KTemp_oven, Temp_oven, #273
10E8           1070   
10E8           1071   Display_Temp_BCD_Or_Kelvin:
10E8 1200F0    1072            lcall hex2bcd ; converts binary in x to BCD in BCD
10EB           1073       ;mov a, K_or_C
10EB           1074       ;cjne a, #1, Display_3_digit_BCD
10EB           1075       ;mov a, KTemp_oven
10EB           1076       ;SendToLCD
10EB           1077       ;sjmp Send_Temp_Port
10EB           1078   
10EB           1079   Display_Temp_BCD:    
10EB 120E97    1080       lcall Display_3_digit_BCD
10EE           1081   
10EE           1082   Send_Temp_Port:
10EE           1083       ;Send_BCD(bcd+4)
10EE           1084       ;Send_BCD(bcd+3)
10EE           1085       ;Send_BCD(bcd+2)
10EE C000      1086       push ar0
10F0 A846      1086       mov r0, bcd+1
10F2 1200DA    1086       lcall ?Send_BCD
10F5 D000      1086       pop ar0
10F7           1086   
10F7 C000      1087       push ar0
10F9 A845      1087       mov r0, bcd+0
10FB 1200DA    1087       lcall ?Send_BCD
10FE D000      1087       pop ar0
1100           1087   
1100 740D      1088            mov a, #'\r'
1102 12047E    1089            lcall putchar
1105 740A      1090            mov a, #'\n'
1107 12047E    1091            lcall putchar
110A           1092   Check_Temp_done:
110A 22        1093   ret    
110B           1094   
110B           1095   ;-------------------------------------------------------------------------------------------------------------------------------
110B           1096   
110B           1097   ;Time wait
110B           1098   
110B           1099   Wait_One_Second:
110B C002      1100            push AR2
110D 7AFA      1100            mov R2, #250
110F 120039    1100            lcall ?Wait_Milli_Seconds
1112 D002      1100            pop AR2
1114 C002      1101            push AR2
1116 7AFA      1101            mov R2, #250
1118 120039    1101            lcall ?Wait_Milli_Seconds
111B D002      1101            pop AR2
111D C002      1102            push AR2
111F 7AFA      1102            mov R2, #250
1121 120039    1102            lcall ?Wait_Milli_Seconds
1124 D002      1102            pop AR2
1126 C002      1103            push AR2
1128 7AFA      1103            mov R2, #250
112A 120039    1103            lcall ?Wait_Milli_Seconds
112D D002      1103            pop AR2
112F 22        1104   ret
1130           1105   
1130           1106   Wait_Half_Second:
1130 C002      1107            push AR2
1132 7AFA      1107            mov R2, #250
1134 120039    1107            lcall ?Wait_Milli_Seconds
1137 D002      1107            pop AR2
1139 C002      1108            push AR2
113B 7AFA      1108            mov R2, #250
113D 120039    1108            lcall ?Wait_Milli_Seconds
1140 D002      1108            pop AR2
1142 22        1109   ret
1143           1110   
1143           1111   
1143           1112   
1143           1113   Wait10us:
1143 784A      1114       mov R0, #74
1145 D8FE      1115       djnz R0, $
1147 22        1116   ret
1148           1117   ; ==================================================================================================
1148           1118   
1148           1119   ;-------------------------------------;
1148           1120   ; ISR for Timer 1.  Used to playback  ;
1148           1121   ; the WAV file stored in the SPI      ;
1148           1122   ; flash memory.                       ;
1148           1123   ;-------------------------------------;
1148           1124   Timer1_ISR:
1148           1125            ; The registers used in the ISR must be saved in the stack
1148 C0E0      1126            push acc
114A C0D0      1127            push psw
114C           1128            
114C           1129            ; Check if the play counter is zero.  If so, stop playing sound.
114C E54C      1130            mov a, w+0
114E 454D      1131            orl a, w+1
1150 454E      1132            orl a, w+2
1152 601C      1133            jz stop_playing
1154           1134            
1154           1135            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
1154 74FF      1136            mov a, #0xff
1156 154C      1137            dec w+0
1158 B54C07    1138            cjne a, w+0, keep_playing
115B 154D      1139            dec w+1
115D B54D02    1140            cjne a, w+1, keep_playing
1160 154E      1141            dec w+2
1162           1142            
1162           1143   keep_playing:
1162 D2A6      1144            setb SPEAKER
1164 12040D    1145            lcall Send_SPI ; Read the next byte from the SPI Flash...
1167           1146            ;mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
1167 2480      1147            add a, #0x80
1169 F5AD      1148            mov DADH, a ; Output to DAC. DAC output is pin P2.3
116B 43A440    1149            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
116E 800C      1150            sjmp Timer1_ISR_Done
1170           1151   
1170           1152   stop_playing:
1170 C28E      1153            clr TR1 ; Stop timer 1
1172 D2A5      1154            setb FLASH_CE  ; Disable SPI Flash
1174 C2A6      1155            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
1176 75AD80    1156            mov DADH, #0x80 ; middle of range
1179 43A440    1157            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
117C           1158   
117C           1159   Timer1_ISR_Done:         
117C D0D0      1160            pop psw
117E D0E0      1161            pop acc
1180 32        1162            reti
1181           1163   ; ==================================================================================================
1181           1164   
1181           1165   ;---------------------------------;
1181           1166   ; Routine to initialize the ISR   ;
1181           1167   ; for timer 2                     ;
1181           1168   ;---------------------------------;
1181           1169   Timer2_init:
1181 75C800    1170       mov T2CON, #0
1184 75CDA9    1171       mov TH2, #high(TIMER2_RELOAD)
1187 75CC9A    1172       mov TL2, #low(TIMER2_RELOAD)
118A           1173   
118A 75CBA9    1174       mov RCAP2H, #high(TIMER2_RELOAD)
118D 75CA9A    1175       mov RCAP2L, #low(TIMER2_RELOAD)
1190           1176   
1190 E4        1177       clr a
1191 F530      1178       mov Count1ms+0, a
1193 F531      1179       mov Count1ms+1, a
1195 F532      1180       mov Count5sec , a
1197 D2AD      1181       setb ET2
1199 D2CA      1182       setb TR2
119B C202      1183       clr enable_clk
119D 22        1184       ret
119E           1185   
119E           1186   ;---------------------------------;
119E           1187   ; ISR for timer 2                 ;
119E           1188   ;---------------------------------;
119E           1189   Timer2_ISR:
119E C2CF      1190       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
11A0 B290      1191       cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
11A2           1192            
11A2           1193            ; The two registers used in the ISR must be saved in the stack
11A2 C0E0      1194       push acc
11A4 C0D0      1195       push psw
11A6           1196            
11A6           1197            ; Increment the 16-bit one mili second counter
11A6 0530      1198            inc Count1ms+0    ; Increment the low 8-bits first
11A8 E530      1199            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
11AA 7002      1200            jnz Inc_Done
11AC 0531      1201            inc Count1ms+1
11AE           1202   
11AE           1203   Inc_Done:
11AE           1204   
11AE           1205   ;**Oven Power Output-------------------
11AE           1206       ; Do the PWM thing
11AE           1207            ; Check if Count1ms > pwm_ratio (this is a 16-bit compare)
11AE C3        1208            clr c
11AF E54F      1209            mov a, pwm_ratio+0
11B1 9530      1210            subb a, Count1ms+0
11B3 E550      1211            mov a, pwm_ratio+1
11B5 9531      1212            subb a, Count1ms+1
11B7           1213            ; if Count1ms > pwm_ratio  the carry is set.  Just copy the carry to the pwm output pin:
11B7 9290      1214            mov PWM_OUTPUT, c
11B9           1215      
11B9           1216       
11B9           1217   ;**----------------------------------
11B9           1218            ; Check if one second has passed
11B9 E530      1219            mov a, Count1ms+0
11BB B4E831    1220            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
11BE E531      1221            mov a, Count1ms+1
11C0 B4032C    1222            cjne a, #high(1000), Timer2_ISR_done
11C3           1223            
11C3           1224            ; 1000 milliseconds have passed.  Set a flag so the main program knows
11C3 D200      1225            setb one_seconds_flag ; Let the main program know one second had passed
11C5           1226       
11C5 0532      1227       inc Count5sec
11C7 E532      1228       mov a, Count5sec
11C9 B40505    1229       cjne a, #5, Set_5sec_flag_done
11CC D201      1230       setb five_seconds_flag
11CE E4        1231       clr a
11CF F532      1232       mov Count5sec, a
11D1           1233       
11D1           1234   Set_5sec_flag_done:
11D1 E4        1235            clr a
11D2 F530      1236            mov Count1ms+0, a
11D4 F531      1237            mov Count1ms+1, a
11D6           1238   
11D6 300216    1239       jnb enable_clk, Timer2_ISR_done ;if the clk is enabled, increment the second. Otherwise skip
11D9           1240   ; Increment the run time counter and state time counter
11D9 E538      1241            mov a, Run_time_seconds
11DB 2401      1242            add a, #0x01
11DD D4        1243            da a
11DE F538      1244       mov Run_time_seconds, a
11E0           1245       ;check sec overflow
11E0 B4600A    1246       cjne a, #0x60, Check_sec_overflow_done
11E3 753800    1247       mov Run_time_seconds, #0x00
11E6 E539      1248       mov a, Run_time_minutes ;inc min
11E8 2401      1249       add a, #1
11EA D4        1250       da a
11EB F539      1251       mov Run_time_minutes, a
11ED           1252   Check_sec_overflow_done:
11ED 053A      1253       inc State_time
11EF           1254   Timer2_ISR_done:
11EF D0D0      1255            pop psw
11F1 D0E0      1256            pop acc
11F3 32        1257            reti
11F4           1258   
11F4           1259   
11F4           1260   ; ==================================================================================================
11F4           1261   
11F4           1262   main:
11F4 75817F    1263       mov SP, #0x7F
11F7 121181    1264       lcall Timer2_Init
11FA           1265       ;lcall INI_SPI
11FA 120088    1266       lcall LCD_4BIT
11FD 120466    1267       lcall InitSerialPort
1200 120CE2    1268       lcall INI_PLAYBACK_TEMP
1203           1269       ;orl AUXR, #0x01 ; pin 4.4
1203           1270       ; In case you decide to use the pins of P0, configure the port in bidirectional mode. Can be ignored
1203 75E600    1271       mov P0M0, #0
1206 75E700    1272       mov P0M1, #0
1209 D2AF      1273       setb EA   ;Enable global enterupt
120B D204      1274       setb SPAN_ENG ; setb for english, clr for spanish
120D           1275   
120D           1276       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
120D 754F00    1277            mov pwm_ratio+0, #low(0)
1210 755000    1278            mov pwm_ratio+1, #high(0)
1213 753300    1279       mov States, #0
1216 755300    1280       mov Profile, #0
1219 120FD7    1281       lcall Load_Configuration1
121C           1282       ;mov FAN, #1
121C 120EB4    1283       lcall Animation 
121F           1284       ;ljmp state5_beginning
121F           1285       
121F           1286   state0: ; idle 
121F           1287   ;***initial parameters displayed***
121F 754F00    1288       mov pwm_ratio+0, #low(0)
1222 755000    1289            mov pwm_ratio+1, #high(0)
1225           1290       
1225           1291       ;Displays Soak Temp and Time
1225 120DEA    1292       lcall State0_display
1228           1293       ;check power on
1228 12052A    1294       lcall CHECK_POWER
122B           1295       ; check the parameters being pressed
122B 120486    1296       lcall CHECK_STIME
122E 1204AF    1297       lcall CHECK_STEMP
1231 1204D8    1298       lcall CHECK_RTIME
1234 120501    1299       lcall CHECK_RTEMP
1237 120546    1300       lcall CHECK_PROFILE
123A           1301   
123A 12056C    1302       lcall CHECK_SPAN_OR_ENGL
123D           1303       
123D 2085DF    1304       jb NEXT_STATE_BUTTON, state0
1240 C002      1305            push AR2
1242 7A32      1305            mov R2, #50
1244 120039    1305            lcall ?Wait_Milli_Seconds
1247 D002      1305            pop AR2 ; debounce time
1249 2085D3    1306            jb NEXT_STATE_BUTTON, state0 ; if button not pressed, loop
124C 3085FD    1307            jnb NEXT_STATE_BUTTON, $
124F           1308   state0_done:
124F 753301    1309       mov States, #1
1252 753A00    1310       mov State_time, #0
1255 D202      1311       setb enable_clk
1257           1312       ; ***play audio***
1257           1312       ;cjne sound_flag, #0, $
1257           1312       
1257 C28E      1312       clr TR1 ; Stop Timer 1 ISR from playing previous request
1259 D2A5      1312       setb FLASH_CE
125B           1312       ;setb sound_flag ; sound starts
125B C2A6      1312       clr SPEAKER ; Turn off speaker
125D C2A5      1312       clr FLASH_CE ; Enable SPI Flash
125F 7403      1312       mov a, #READ_BYTES
1261 12040D    1312       lcall Send_SPI
1264           1312       ; Set the initial position in memory where to start playing
1264           1312       
1264 7418      1312       mov a, #0x18 ; change initial position
1266 12040D    1312       lcall Send_SPI
1269 74CB      1312       mov a, #0xcb ; next memory position
126B 12040D    1312       lcall Send_SPI
126E 74A8      1312       mov a, #0xa8 ; next memory position
1270 12040D    1312       lcall Send_SPI
1273 7418      1312       mov a, #0x18 ; request first byte to send to DAC
1275 12040D    1312       lcall Send_SPI
1278           1312       
1278           1312       ; How many bytes to play?
1278 754E02    1312       mov w+2, #0x02 ; Load the high byte of the number of bytes to play
127B 754D0F    1312       mov w+1, #0x0f ; Load the middle byte of the number of bytes to play
127E 754C58    1312       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
1281           1312       
1281           1312       
1281 D2A6      1312       setb SPEAKER ;Turn on speaker
1283 D28E      1312       setb TR1 ;Start playback by enabling Timer1
1285           1312       ;clr sound_flag ; sound ends
1285 12110B    1313       lcall Wait_One_Second
1288           1314        
1288           1315   
1288           1316   state1_beginning:
1288           1317   
1288           1318       ;Start Run Time
1288 753800    1319       mov Run_time_seconds, #0 ; time starts at 0:00
128B 753900    1320       mov Run_time_minutes, #0
128E 753A00    1321       mov State_time, #0
1291           1322   
1291           1323       ;***clear the screen and set new display***
1291 120D44    1324       lcall Initialize_State_Display
1294 C0E0      1325            push acc
1296 7407      1325            mov a, #7
1298 14        1325            dec a
1299 1200BD    1325            lcall ?Set_Cursor_2 ; Select column and row
129C D0E0      1325            pop acc
129E C083      1326            push dph
12A0 C082      1326            push dpl
12A2 C0E0      1326            push acc
12A4 9003C7    1326            mov dptr, #Ramp2Soak
12A7 1200B2    1326            lcall ?Send_Constant_String
12AA D0E0      1326            pop acc
12AC D082      1326            pop dpl
12AE D083      1326            pop dph; displays current state
12B0           1327   
12B0           1328       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
12B0 754FE8    1329            mov pwm_ratio+0, #low(1000)
12B3 755003    1330            mov pwm_ratio+1, #high(1000)
12B6 300433    1331       jnb SPAN_ENG, SPANISH1
12B9           1332       ; ***play audio***
12B9           1332       ;cjne sound_flag, #0, $
12B9 121130    1332       lcall Wait_Half_Second
12BC C28E      1332       clr TR1 ; Stop Timer 1 ISR from playing previous request
12BE D2A5      1332       setb FLASH_CE
12C0           1332       ;setb sound_flag ; sound starts
12C0 C2A6      1332       clr SPEAKER ; Turn off speaker
12C2 C2A5      1332       clr FLASH_CE ; Enable SPI Flash
12C4 7403      1332       mov a, #READ_BYTES
12C6 12040D    1332       lcall Send_SPI
12C9           1332       ; Set the initial position in memory where to start playing
12C9           1332       
12C9 7400      1332       mov a, #0x00 ; change initial position
12CB 12040D    1332       lcall Send_SPI
12CE 7400      1332       mov a, #0x00 ; next memory position
12D0 12040D    1332       lcall Send_SPI
12D3 742D      1332       mov a, #0x2d ; next memory position
12D5 12040D    1332       lcall Send_SPI
12D8 7400      1332       mov a, #0x00 ; request first byte to send to DAC
12DA 12040D    1332       lcall Send_SPI
12DD           1332       
12DD           1332       ; How many bytes to play?
12DD 754E00    1332       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
12E0 754D4E    1332       mov w+1, #0x4e ; Load the middle byte of the number of bytes to play
12E3 754C20    1332       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
12E6           1332       
12E6           1332       
12E6 D2A6      1332       setb SPEAKER ;Turn on speaker
12E8 D28E      1332       setb TR1 ;Start playback by enabling Timer1
12EA           1332       ;clr sound_flag ; sound ends
12EA           1333       ;lcall Wait_One_Second
12EA 8036      1334       sjmp state1
12EC           1335   SPANISH1:
12EC           1336       ; ***play audio***
12EC           1336       ;cjne sound_flag, #0, $
12EC 121130    1336       lcall Wait_Half_Second
12EF C28E      1336       clr TR1 ; Stop Timer 1 ISR from playing previous request
12F1 D2A5      1336       setb FLASH_CE
12F3           1336       ;setb sound_flag ; sound starts
12F3 C2A6      1336       clr SPEAKER ; Turn off speaker
12F5 C2A5      1336       clr FLASH_CE ; Enable SPI Flash
12F7 7403      1336       mov a, #READ_BYTES
12F9 12040D    1336       lcall Send_SPI
12FC           1336       ; Set the initial position in memory where to start playing
12FC           1336       
12FC 7405      1336       mov a, #0x05 ; change initial position
12FE 12040D    1336       lcall Send_SPI
1301 7457      1336       mov a, #0x57 ; next memory position
1303 12040D    1336       lcall Send_SPI
1306 7430      1336       mov a, #0x30 ; next memory position
1308 12040D    1336       lcall Send_SPI
130B 7405      1336       mov a, #0x05 ; request first byte to send to DAC
130D 12040D    1336       lcall Send_SPI
1310           1336       
1310           1336       ; How many bytes to play?
1310 754E00    1336       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
1313 754DEA    1336       mov w+1, #0xea ; Load the middle byte of the number of bytes to play
1316 754C60    1336       mov w+0, #0x60 ; Load the low byte of the number of bytes to play
1319           1336       
1319           1336       
1319 D2A6      1336       setb SPEAKER ;Turn on speaker
131B D28E      1336       setb TR1 ;Start playback by enabling Timer1
131D           1336       ;clr sound_flag ; sound ends
131D           1337       ;mov FAN, #1
131D 8003      1338       sjmp state1
131F           1339       
131F           1340   main_1:
131F 0211F4    1341            ljmp main
1322           1342   
1322           1343   state1: ; ramp to soak
1322           1344       ;check power on
1322 12052A    1345       lcall CHECK_POWER
1325           1346       ;Update Time and Temp
1325 120DC3    1347       lcall Update_Display
1328 121086    1348       lcall Average_Temp
132B           1349       ;lcall CHECK_SPAN_OR_ENGL
132B           1350       
132B           1351       ;Decides if going to Spanish or English
132B           1352       ;jb SPAN_ENG, SPANISH1
132B 1205B2    1353       lcall SOUND_FSM
132E           1354   ;SPANISH1:
132E           1355       ;lcall SOUND_FSM_S
132E           1356   
132E           1357   Check_Temp_done1:
132E           1358   
132E           1359       ;check if temp is below 150 
132E E53B      1360       mov a, Temp_oven           
1330 9534      1361       subb a, Temp_soak
1332 5014      1362       jnc state1_done        ; if greater, jump to state 2
1334 6012      1363       jz state1_done         ; if equal to, jump to state 2
1336 4000      1364       jc Check_state1_safety ; if less than, check state time
1338           1365   Check_state1_safety:       ; safety
1338 E53B      1366       mov a, Temp_oven           
133A 9432      1367       subb a, #50
133C 50E4      1368       jnc state1             ; if greater, go back to state1
133E E53A      1369       mov a, State_time      ; if less than 50C, check if state time is too long
1340 943C      1370       subb a, #60
1342 50DB      1371       jnc main_1             ; if greater, restart
1344 60D9      1372       jz main_1              ; if equal to, restart
1346 40DA      1373       jc state1              ; if less than, go back to state1
1348           1374   ;*Checking moving to states with buttons---- 
1348           1375   ;*Will remove after proper temperature reading----
1348           1376   
1348           1377       ;jb NEXT_STATE_BUTTON, state1
1348           1378       ;Wait_Milli_Seconds(#50) ; debounce time
1348           1379            ;jb NEXT_STATE_BUTTON, state1 ; if button not pressed, loop
1348           1380            ;jnb NEXT_STATE_BUTTON, $ 
1348           1381   
1348           1382   state1_done:
1348           1383       ;mov FAN, #0
1348 753302    1384       mov States, #2
134B           1385   
134B           1386   ; preheat/soak
134B           1387   state2_beginning: 
134B 753A00    1388       mov State_time, #0;x00 ;clear the state time
134E           1389       ;***clear the screen and set new display***
134E 120D44    1390       lcall Initialize_State_Display
1351 C0E0      1391            push acc
1353 7407      1391            mov a, #7
1355 14        1391            dec a
1356 1200BD    1391            lcall ?Set_Cursor_2 ; Select column and row
1359 D0E0      1391            pop acc
135B C083      1392            push dph
135D C082      1392            push dpl
135F C0E0      1392            push acc
1361 9003D1    1392            mov dptr, #Soak
1364 1200B2    1392            lcall ?Send_Constant_String
1367 D0E0      1392            pop acc
1369 D082      1392            pop dpl
136B D083      1392            pop dph ;displays current state
136D           1393   
136D           1394       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
136D 754FC8    1395            mov pwm_ratio+0, #low(200)
1370 755000    1396            mov pwm_ratio+1, #high(000)
1373           1397       ; Produces SOAK on speaker
1373 300433    1398       jnb SPAN_ENG, SPANISH2
1376           1399       ; ***play audio***
1376           1399       ;cjne sound_flag, #0, $
1376 121130    1399       lcall Wait_Half_Second
1379 C28E      1399       clr TR1 ; Stop Timer 1 ISR from playing previous request
137B D2A5      1399       setb FLASH_CE
137D           1399       ;setb sound_flag ; sound starts
137D C2A6      1399       clr SPEAKER ; Turn off speaker
137F C2A5      1399       clr FLASH_CE ; Enable SPI Flash
1381 7403      1399       mov a, #READ_BYTES
1383 12040D    1399       lcall Send_SPI
1386           1399       ; Set the initial position in memory where to start playing
1386           1399       
1386 7400      1399       mov a, #0x00 ; change initial position
1388 12040D    1399       lcall Send_SPI
138B 7444      1399       mov a, #0x44 ; next memory position
138D 12040D    1399       lcall Send_SPI
1390 74DD      1399       mov a, #0xdd ; next memory position
1392 12040D    1399       lcall Send_SPI
1395 7400      1399       mov a, #0x00 ; request first byte to send to DAC
1397 12040D    1399       lcall Send_SPI
139A           1399       
139A           1399       ; How many bytes to play?
139A 754E00    1399       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
139D 754D4E    1399       mov w+1, #0x4e ; Load the middle byte of the number of bytes to play
13A0 754C20    1399       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
13A3           1399       
13A3           1399       
13A3 D2A6      1399       setb SPEAKER ;Turn on speaker
13A5 D28E      1399       setb TR1 ;Start playback by enabling Timer1
13A7           1399       ;clr sound_flag ; sound ends
13A7 8031      1400       sjmp state2
13A9           1401   SPANISH2:
13A9           1402       ; ***play audio***
13A9           1402       ;cjne sound_flag, #0, $
13A9 121130    1402       lcall Wait_Half_Second
13AC C28E      1402       clr TR1 ; Stop Timer 1 ISR from playing previous request
13AE D2A5      1402       setb FLASH_CE
13B0           1402       ;setb sound_flag ; sound starts
13B0 C2A6      1402       clr SPEAKER ; Turn off speaker
13B2 C2A5      1402       clr FLASH_CE ; Enable SPI Flash
13B4 7403      1402       mov a, #READ_BYTES
13B6 12040D    1402       lcall Send_SPI
13B9           1402       ; Set the initial position in memory where to start playing
13B9           1402       
13B9 7406      1402       mov a, #0x06 ; change initial position
13BB 12040D    1402       lcall Send_SPI
13BE 741A      1402       mov a, #0x1a ; next memory position
13C0 12040D    1402       lcall Send_SPI
13C3 7480      1402       mov a, #0x80 ; next memory position
13C5 12040D    1402       lcall Send_SPI
13C8 7406      1402       mov a, #0x06 ; request first byte to send to DAC
13CA 12040D    1402       lcall Send_SPI
13CD           1402       
13CD           1402       ; How many bytes to play?
13CD 754E00    1402       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
13D0 754D9C    1402       mov w+1, #0x9c ; Load the middle byte of the number of bytes to play
13D3 754C40    1402       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
13D6           1402       
13D6           1402       
13D6 D2A6      1402       setb SPEAKER ;Turn on speaker
13D8 D28E      1402       setb TR1 ;Start playback by enabling Timer1
13DA           1402       ;clr sound_flag ; sound ends
13DA           1403   
13DA           1404   state2:
13DA           1405       ;check power on
13DA 12052A    1406       lcall CHECK_POWER 
13DD           1407       ;Update Time and Temp
13DD 120DC3    1408       lcall Update_Display
13E0 121086    1409       lcall Average_Temp
13E3           1410       ;lcall CHECK_SPAN_OR_ENGL
13E3           1411   
13E3           1412       ;jb SPAN_ENG, SPANISH2
13E3 1205B2    1413       lcall SOUND_FSM
13E6 8000      1414       sjmp Check_Temp_done2
13E8           1415   ;SPANISH2:
13E8           1416       ;lcall SOUND_FSM_S
13E8           1417       
13E8           1418       ; loop back to state2 if run time is less than soak time. If greater than jump to state3 cuz of overflow of time
13E8           1419   Check_Temp_done2:     
13E8 E53A      1420       mov a, State_time
13EA 9535      1421       subb a, Time_soak
13EC 5002      1422       jnc state2_done
13EE 40EA      1423       jc state2
13F0           1424   
13F0           1425   state2_done:
13F0 753A03    1426       mov State_time, #3
13F3           1427   
13F3           1428   ; ramp to peak
13F3           1429   state3_beginning:
13F3           1430       ;setb OVEN_POWER ;turn power on 100%
13F3           1431   
13F3           1432       ;***clear the screen and set new display***
13F3 120D44    1433       lcall Initialize_State_Display
13F6 C0E0      1434            push acc
13F8 7407      1434            mov a, #7
13FA 14        1434            dec a
13FB 1200BD    1434            lcall ?Set_Cursor_2 ; Select column and row
13FE D0E0      1434            pop acc
1400 C083      1435            push dph
1402 C082      1435            push dpl
1404 C0E0      1435            push acc
1406 9003D6    1435            mov dptr, #Ramp2Peak
1409 1200B2    1435            lcall ?Send_Constant_String
140C D0E0      1435            pop acc
140E D082      1435            pop dpl
1410 D083      1435            pop dph
1412           1436   
1412           1437       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
1412 754FE8    1438            mov pwm_ratio+0, #low(1000)
1415 755003    1439            mov pwm_ratio+1, #high(1000)
1418           1440   
1418           1441       ; Produces RAMP TO PEAK on speaker
1418 300433    1442       jnb SPAN_ENG, SPANISH3
141B           1443       ; ***play audio***
141B           1443       ;cjne sound_flag, #0, $
141B 121130    1443       lcall Wait_Half_Second
141E C28E      1443       clr TR1 ; Stop Timer 1 ISR from playing previous request
1420 D2A5      1443       setb FLASH_CE
1422           1443       ;setb sound_flag ; sound starts
1422 C2A6      1443       clr SPEAKER ; Turn off speaker
1424 C2A5      1443       clr FLASH_CE ; Enable SPI Flash
1426 7403      1443       mov a, #READ_BYTES
1428 12040D    1443       lcall Send_SPI
142B           1443       ; Set the initial position in memory where to start playing
142B           1443       
142B 7400      1443       mov a, #0x00 ; change initial position
142D 12040D    1443       lcall Send_SPI
1430 748B      1443       mov a, #0x8b ; next memory position
1432 12040D    1443       lcall Send_SPI
1435 74CA      1443       mov a, #0xca ; next memory position
1437 12040D    1443       lcall Send_SPI
143A 7400      1443       mov a, #0x00 ; request first byte to send to DAC
143C 12040D    1443       lcall Send_SPI
143F           1443       
143F           1443       ; How many bytes to play?
143F 754E00    1443       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
1442 754D75    1443       mov w+1, #0x75 ; Load the middle byte of the number of bytes to play
1445 754C30    1443       mov w+0, #0x30 ; Load the low byte of the number of bytes to play
1448           1443       
1448           1443       
1448 D2A6      1443       setb SPEAKER ;Turn on speaker
144A D28E      1443       setb TR1 ;Start playback by enabling Timer1
144C           1443       ;clr sound_flag ; sound ends
144C 8031      1444       sjmp state3
144E           1445   SPANISH3:
144E           1446       ; ***play audio***
144E           1446       ;cjne sound_flag, #0, $
144E 121130    1446       lcall Wait_Half_Second
1451 C28E      1446       clr TR1 ; Stop Timer 1 ISR from playing previous request
1453 D2A5      1446       setb FLASH_CE
1455           1446       ;setb sound_flag ; sound starts
1455 C2A6      1446       clr SPEAKER ; Turn off speaker
1457 C2A5      1446       clr FLASH_CE ; Enable SPI Flash
1459 7403      1446       mov a, #READ_BYTES
145B 12040D    1446       lcall Send_SPI
145E           1446       ; Set the initial position in memory where to start playing
145E           1446       
145E 7406      1446       mov a, #0x06 ; change initial position
1460 12040D    1446       lcall Send_SPI
1463 74B6      1446       mov a, #0xb6 ; next memory position
1465 12040D    1446       lcall Send_SPI
1468 74C0      1446       mov a, #0xc0 ; next memory position
146A 12040D    1446       lcall Send_SPI
146D 7406      1446       mov a, #0x06 ; request first byte to send to DAC
146F 12040D    1446       lcall Send_SPI
1472           1446       
1472           1446       ; How many bytes to play?
1472 754E00    1446       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
1475 754D75    1446       mov w+1, #0x75 ; Load the middle byte of the number of bytes to play
1478 754C30    1446       mov w+0, #0x30 ; Load the low byte of the number of bytes to play
147B           1446       
147B           1446       
147B D2A6      1446       setb SPEAKER ;Turn on speaker
147D D28E      1446       setb TR1 ;Start playback by enabling Timer1
147F           1446       ;clr sound_flag ; sound ends
147F           1447   
147F           1448   state3: 
147F           1449       ;check power on
147F 12052A    1450       lcall CHECK_POWER
1482 121086    1451       lcall Average_Temp
1485           1452       ;lcall CHECK_SPAN_OR_ENGL
1485           1453       
1485           1454       ;Update Time and Temp
1485 120DC3    1455       lcall Update_Display
1488           1456       ;jb SPAN_ENG, SPANISH3
1488 1205B2    1457       lcall SOUND_FSM
148B 8000      1458       sjmp Check_Temp_done3
148D           1459   ;SPANISH3:
148D           1460       ;lcall SOUND_FSM_S
148D           1461       
148D           1462   Check_Temp_done3:  
148D           1463    
148D E53B      1464       mov a, Temp_oven           
148F 9536      1465       subb a, Temp_refl
1491 5004      1466       jnc state3_done    ; if greater, jump to state 4
1493 6002      1467       jz state3_done ; if equal to, jump to state 4
1495 40E8      1468       jc state3 ; if less than, go back to state3
1497           1469    
1497           1470   state3_done:
1497 753A04    1471       mov State_time, #4
149A           1472   
149A           1473   ; reflow 
149A           1474   state4_beginning:
149A           1475       
149A 753A00    1476       mov State_time, #0;x00 clear the state time
149D           1477       ;***clear the screen and set new display***
149D 120D44    1478       lcall Initialize_State_Display
14A0 C0E0      1479            push acc
14A2 7407      1479            mov a, #7
14A4 14        1479            dec a
14A5 1200BD    1479            lcall ?Set_Cursor_2 ; Select column and row
14A8 D0E0      1479            pop acc
14AA C083      1480            push dph
14AC C082      1480            push dpl
14AE C0E0      1480            push acc
14B0 9003E0    1480            mov dptr, #Reflow
14B3 1200B2    1480            lcall ?Send_Constant_String
14B6 D0E0      1480            pop acc
14B8 D082      1480            pop dpl
14BA D083      1480            pop dph
14BC           1481   
14BC           1482       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
14BC 754FC8    1483            mov pwm_ratio+0, #low(200)
14BF 755000    1484            mov pwm_ratio+1, #high(000)
14C2           1485   
14C2           1486       ; Produces REFLOW on speaker
14C2 300433    1487       jnb SPAN_ENG, SPANISH4
14C5           1488       ; ***play audio***
14C5           1488       ;cjne sound_flag, #0, $
14C5 121130    1488       lcall Wait_Half_Second
14C8 C28E      1488       clr TR1 ; Stop Timer 1 ISR from playing previous request
14CA D2A5      1488       setb FLASH_CE
14CC           1488       ;setb sound_flag ; sound starts
14CC C2A6      1488       clr SPEAKER ; Turn off speaker
14CE C2A5      1488       clr FLASH_CE ; Enable SPI Flash
14D0 7403      1488       mov a, #READ_BYTES
14D2 12040D    1488       lcall Send_SPI
14D5           1488       ; Set the initial position in memory where to start playing
14D5           1488       
14D5 7400      1488       mov a, #0x00 ; change initial position
14D7 12040D    1488       lcall Send_SPI
14DA 74F0      1488       mov a, #0xf0 ; next memory position
14DC 12040D    1488       lcall Send_SPI
14DF 7463      1488       mov a, #0x63 ; next memory position
14E1 12040D    1488       lcall Send_SPI
14E4 7400      1488       mov a, #0x00 ; request first byte to send to DAC
14E6 12040D    1488       lcall Send_SPI
14E9           1488       
14E9           1488       ; How many bytes to play?
14E9 754E00    1488       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
14EC 754D59    1488       mov w+1, #0x59 ; Load the middle byte of the number of bytes to play
14EF 754CD8    1488       mov w+0, #0xd8 ; Load the low byte of the number of bytes to play
14F2           1488       
14F2           1488       
14F2 D2A6      1488       setb SPEAKER ;Turn on speaker
14F4 D28E      1488       setb TR1 ;Start playback by enabling Timer1
14F6           1488       ;clr sound_flag ; sound ends
14F6 8031      1489       sjmp state4
14F8           1490   SPANISH4:
14F8           1491       ; ***play audio***
14F8           1491       ;cjne sound_flag, #0, $
14F8 121130    1491       lcall Wait_Half_Second
14FB C28E      1491       clr TR1 ; Stop Timer 1 ISR from playing previous request
14FD D2A5      1491       setb FLASH_CE
14FF           1491       ;setb sound_flag ; sound starts
14FF C2A6      1491       clr SPEAKER ; Turn off speaker
1501 C2A5      1491       clr FLASH_CE ; Enable SPI Flash
1503 7403      1491       mov a, #READ_BYTES
1505 12040D    1491       lcall Send_SPI
1508           1491       ; Set the initial position in memory where to start playing
1508           1491       
1508 7419      1491       mov a, #0x19 ; change initial position
150A 12040D    1491       lcall Send_SPI
150D 748E      1491       mov a, #0x8e ; next memory position
150F 12040D    1491       lcall Send_SPI
1512 74F8      1491       mov a, #0xf8 ; next memory position
1514 12040D    1491       lcall Send_SPI
1517 7419      1491       mov a, #0x19 ; request first byte to send to DAC
1519 12040D    1491       lcall Send_SPI
151C           1491       
151C           1491       ; How many bytes to play?
151C 754E00    1491       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
151F 754D75    1491       mov w+1, #0x75 ; Load the middle byte of the number of bytes to play
1522 754C30    1491       mov w+0, #0x30 ; Load the low byte of the number of bytes to play
1525           1491       
1525           1491       
1525 D2A6      1491       setb SPEAKER ;Turn on speaker
1527 D28E      1491       setb TR1 ;Start playback by enabling Timer1
1529           1491       ;clr sound_flag ; sound ends
1529           1492   
1529           1493   state4:
1529           1494       ;check power on
1529 12052A    1495       lcall CHECK_POWER
152C           1496       ;Update Time and Temp
152C 120DC3    1497       lcall Update_Display
152F 121086    1498       lcall Average_Temp
1532           1499       ;lcall CHECK_SPAN_OR_ENGL
1532           1500      ;jb SPAN_ENG, SPANISH4
1532 1205B2    1501       lcall SOUND_FSM
1535 8000      1502       sjmp Check_Temp_done4
1537           1503   ;SPANISH4:
1537           1504       ;lcall SOUND_FSM_S
1537           1505       
1537           1506   Check_Temp_done4:  
1537           1507      
1537           1508       ; loop back to state2 if run time is less than soak time
1537 E53A      1509       mov a, State_time
1539 9537      1510       subb a, Time_refl
153B 5002      1511       jnc state4_done
153D 40EA      1512       jc state4
153F           1513   
153F           1514   state4_done: 
153F 753A00    1515       mov State_time, #0
1542 021545    1516       ljmp state5_beginning 
1545           1517   
1545           1518   
1545           1519   ; cooling
1545           1520   state5_beginning: ; turn oven off
1545           1521       ;clr OVEN_POWER
1545           1522   
1545           1523   ;***clear the screen and set new display***
1545 120D44    1524       lcall Initialize_State_Display
1548 C083      1525            push dph
154A C082      1525            push dpl
154C C0E0      1525            push acc
154E 9003E7    1525            mov dptr, #Cooling
1551 1200B2    1525            lcall ?Send_Constant_String
1554 D0E0      1525            pop acc
1556 D082      1525            pop dpl
1558 D083      1525            pop dph
155A           1526   
155A           1527       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
155A 754F00    1528            mov pwm_ratio+0, #low(0)
155D 755000    1529            mov pwm_ratio+1, #high(0)
1560           1530   
1560 753305    1531       mov States, #5
1563           1532   
1563           1533       ; Produces COOLING on speaker
1563 300433    1534       jnb SPAN_ENG, SPANISH5
1566           1535       ; ***play audio***
1566           1535       ;cjne sound_flag, #0, $
1566 121130    1535       lcall Wait_Half_Second
1569 C28E      1535       clr TR1 ; Stop Timer 1 ISR from playing previous request
156B D2A5      1535       setb FLASH_CE
156D           1535       ;setb sound_flag ; sound starts
156D C2A6      1535       clr SPEAKER ; Turn off speaker
156F C2A5      1535       clr FLASH_CE ; Enable SPI Flash
1571 7403      1535       mov a, #READ_BYTES
1573 12040D    1535       lcall Send_SPI
1576           1535       ; Set the initial position in memory where to start playing
1576           1535       
1576 7401      1535       mov a, #0x01 ; change initial position
1578 12040D    1535       lcall Send_SPI
157B 7448      1535       mov a, #0x48 ; next memory position
157D 12040D    1535       lcall Send_SPI
1580 749A      1535       mov a, #0x9a ; next memory position
1582 12040D    1535       lcall Send_SPI
1585 7401      1535       mov a, #0x01 ; request first byte to send to DAC
1587 12040D    1535       lcall Send_SPI
158A           1535       
158A           1535       ; How many bytes to play?
158A 754E00    1535       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
158D 754D6B    1535       mov w+1, #0x6b ; Load the middle byte of the number of bytes to play
1590 754C6C    1535       mov w+0, #0x6c ; Load the low byte of the number of bytes to play
1593           1535       
1593           1535       
1593 D2A6      1535       setb SPEAKER ;Turn on speaker
1595 D28E      1535       setb TR1 ;Start playback by enabling Timer1
1597           1535       ;clr sound_flag ; sound ends
1597 8031      1536       sjmp state5
1599           1537   
1599           1538   SPANISH5:
1599           1539       ; ***play audio***
1599           1539       ;cjne sound_flag, #0, $
1599 121130    1539       lcall Wait_Half_Second
159C C28E      1539       clr TR1 ; Stop Timer 1 ISR from playing previous request
159E D2A5      1539       setb FLASH_CE
15A0           1539       ;setb sound_flag ; sound starts
15A0 C2A6      1539       clr SPEAKER ; Turn off speaker
15A2 C2A5      1539       clr FLASH_CE ; Enable SPI Flash
15A4 7403      1539       mov a, #READ_BYTES
15A6 12040D    1539       lcall Send_SPI
15A9           1539       ; Set the initial position in memory where to start playing
15A9           1539       
15A9 7419      1539       mov a, #0x19 ; change initial position
15AB 12040D    1539       lcall Send_SPI
15AE 74F0      1539       mov a, #0xf0 ; next memory position
15B0 12040D    1539       lcall Send_SPI
15B3 74A0      1539       mov a, #0xa0 ; next memory position
15B5 12040D    1539       lcall Send_SPI
15B8 7419      1539       mov a, #0x19 ; request first byte to send to DAC
15BA 12040D    1539       lcall Send_SPI
15BD           1539       
15BD           1539       ; How many bytes to play?
15BD 754E00    1539       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
15C0 754DEA    1539       mov w+1, #0xea ; Load the middle byte of the number of bytes to play
15C3 754C60    1539       mov w+0, #0x60 ; Load the low byte of the number of bytes to play
15C6           1539       
15C6           1539       
15C6 D2A6      1539       setb SPEAKER ;Turn on speaker
15C8 D28E      1539       setb TR1 ;Start playback by enabling Timer1
15CA           1539       ;clr sound_flag ; sound ends
15CA           1540       ;cpl FAN
15CA           1541   
15CA           1542   state5:
15CA           1543       ;check power on
15CA 12052A    1544       lcall CHECK_POWER
15CD           1545       
15CD           1546       ; update display
15CD 120DC3    1547       lcall Update_Display
15D0 121086    1548       lcall Average_Temp
15D3           1549       ;jb SPAN_ENG, SPANISH5
15D3 1205B2    1550       lcall SOUND_FSM
15D6 8000      1551       sjmp Check_Temp_done5
15D8           1552   ;SPANISH5:
15D8           1553       ;lcall SOUND_FSM_S
15D8           1554       
15D8           1555   Check_Temp_done5:  
15D8           1556   
15D8 E53B      1557       mov a, Temp_oven
15DA 943C      1558       subb a, #60
15DC 50EC      1559       JNC state5    ; if greater, jump back to state 5
15DE 60EA      1560       JZ state5 ; if equal to, go back to state5
15E0 4000      1561       JC state5_done ; if less than, go back to state 0
15E2           1562   
15E2           1563       ;*Checking moving to states with buttons---- 
15E2           1564   ;*Will remove after proper temperature reading----
15E2           1565   
15E2           1566       ;jb NEXT_STATE_BUTTON, state5
15E2           1567       ;Wait_Milli_Seconds(#50) ; debounce time
15E2           1568            ;jb NEXT_STATE_BUTTON, state5 ; if button not pressed, loop
15E2           1569            ;jnb NEXT_STATE_BUTTON, $ 
15E2           1570   
15E2           1571   state5_done:
15E2           1572       ; ***play audio***
15E2           1572       ;cjne sound_flag, #0, $
15E2           1572       
15E2 C28E      1572       clr TR1 ; Stop Timer 1 ISR from playing previous request
15E4 D2A5      1572       setb FLASH_CE
15E6           1572       ;setb sound_flag ; sound starts
15E6 C2A6      1572       clr SPEAKER ; Turn off speaker
15E8 C2A5      1572       clr FLASH_CE ; Enable SPI Flash
15EA 7403      1572       mov a, #READ_BYTES
15EC 12040D    1572       lcall Send_SPI
15EF           1572       ; Set the initial position in memory where to start playing
15EF           1572       
15EF 7416      1572       mov a, #0x16 ; change initial position
15F1 12040D    1572       lcall Send_SPI
15F4 74BC      1572       mov a, #0xbc ; next memory position
15F6 12040D    1572       lcall Send_SPI
15F9 7450      1572       mov a, #0x50 ; next memory position
15FB 12040D    1572       lcall Send_SPI
15FE 7416      1572       mov a, #0x16 ; request first byte to send to DAC
1600 12040D    1572       lcall Send_SPI
1603           1572       
1603           1572       ; How many bytes to play?
1603 754E02    1572       mov w+2, #0x02 ; Load the high byte of the number of bytes to play
1606 754D0F    1572       mov w+1, #0x0f ; Load the middle byte of the number of bytes to play
1609 754C58    1572       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
160C           1572       
160C           1572       
160C D2A6      1572       setb SPEAKER ;Turn on speaker
160E D28E      1572       setb TR1 ;Start playback by enabling Timer1
1610           1572       ;clr sound_flag ; sound ends
1610 12110B    1573       lcall Wait_One_Second
1613 12110B    1574       lcall Wait_One_Second
1616 12110B    1575       lcall Wait_One_Second
1619 12110B    1576       lcall Wait_One_Second
161C 12110B    1577       lcall Wait_One_Second
161F 753A00    1578       mov State_time, #0
1622 753300    1579       mov States, #0
1625           1580       ;setb FAN
1625 0211F4    1581       ljmp main
1628           1582   
1628           1583   EN
