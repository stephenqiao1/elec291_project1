                  2   $LIST
0000              4   
0000              5   
0000              6   ;-------------------------------------------------------------------------------------------------------------------------------
0000              7   ;These EQU must match the wiring between the microcontroller and ADC
0000              8   CLK  EQU 22118400
0000              9   TIMER1_RATE    EQU 25000 ;22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             10   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             11   BAUD equ 115200
0000             12   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000             13   
0000             14   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             15   TIMER2_RELOAD EQU (65536-(CLK/TIMER2_RATE))
0000             16   
0000             17   ;shjfjdfs
0000             18   ;-------------------------------------------------------------------------------------------------------------------------------
0000             19   ;Button Pin Mapping
0000             20   NEXT_STATE_BUTTON  equ P0.5
0000             21   STIME_BUTTON    equ P0.2
0000             22   STEMP_BUTTON    equ P0.3
0000             23   RTIME_BUTTON    equ P0.4
0000             24   RTEMP_BUTTON    equ P0.6
0000             25   
0000             26   POWER_BUTTON    equ P4.5
0000             27   SHIFT_BUTTON    equ p0.1
0000             28   
0000             29   ;Output Pins
0000             30   OVEN_POWER      equ P0.7
0000             31   SPEAKER         equ P2.6
0000             32   
0000             33   PWM_OUTPUT    equ P1.0 ; Attach an LED (with 1k resistor in series) to P1.0
0000             34   
0000             35   
0000             36   ;FLASH pins
0000             37   MY_MOSI_SOUND EQU P2.4
0000             38   MY_MISO_SOUND EQU P2.1
0000             39   MY_SCLK_SOUND EQU P2.0
0000             40   FLASH_CE      EQU P2.5
0000             41   
0000             42   ;Thermowire Pins
0000             43   CE_ADC    EQU  P1.7
0000             44   MY_MOSI   EQU  P1.6
0000             45   MY_MISO   EQU  P1.5
0000             46   MY_SCLK   EQU  P1.4 
0000             47   
0000             48   ; Commands supported by the SPI flash memory according to the datasheet
0000             49   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             50   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             51   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             52   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             53   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             54   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             55   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             56   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             57   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             58   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             59   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             60   
0000             61   ; These 'equ' must match the hardware wiring
0000             62   LCD_RS equ P3.2
0000             63   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
0000             64   LCD_E  equ P3.3
0000             65   LCD_D4 equ P3.4
0000             66   LCD_D5 equ P3.5
0000             67   LCD_D6 equ P3.6
0000             68   LCD_D7 equ P3.7
0000             69   
0000             70   ;-------------------------------------------------------------------------------------------------------------------------------
0000             71   
0000             72   org 0x0000
0000 0210FA      73       ljmp main
0003             74   
0003             75   ; External interrupt 0 vector (not used in this code)
0003             76   org 0x0003
0003 32          77            reti
0004             78   
0004             79   ; Timer/Counter 0 overflow interrupt vector
000B             80   org 0x000B
000B 32          81            reti
000C             82   
000C             83   ; External interrupt 1 vector (not used in this code)
0013             84   org 0x0013
0013 32          85            reti
0014             86   
0014             87   ; Timer/Counter 1 overflow interrupt vector
001B             88   org 0x001B
001B 02104E      89            ljmp Timer1_ISR
001E             90   
001E             91   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             92   org 0x0023 
0023 32          93            reti
0024             94            
0024             95   ; Timer/Counter 2 overflow interrupt vector
002B             96   org 0x002B
002B 0210A4      97       ljmp Timer2_ISR
002E             98   ;-------------------------------------------------------------------------------------------------------------------------------
002E             99   ; Place our variables here
0030            100   DSEG at 0x30 ; Before the state machine!
0030            101   Count1ms:         ds 2 ; Used to determine when one second has passed
0032            102   Count5sec:        ds 1
0033            103   States:           ds 1
0034            104   Temp_soak:        ds 1
0035            105   Time_soak:        ds 1
0036            106   Temp_refl:        ds 1
0037            107   Time_refl:        ds 1
0038            108   Run_time_seconds: ds 1
0039            109   Run_time_minutes: ds 1
003A            110   State_time:       ds 1
003B            111   Temp_oven:        ds 1
003C            112   KTemp_oven:       ds 1
003D            113   x:                ds 4
0041            114   y:                ds 4
0045            115   bcd:              ds 5
004A            116   Result:           ds 2
004C            117   w:                ds 3
004F            118   pwm_ratio:        ds 2
0051            119   average_count:    ds 1
0052            120   K_or_C:           ds 1
0053            121   
                123   $LIST
00F0            125   
                546   $LIST
                127   $LIST
0360            129   
0360            130   ;$NOLIST
0360            131   ;$INCLUDE(sound_for_project1_index.asm)
0360            132   ;$LIST
0360            133   
0000            134   bseg
0000            135   one_seconds_flag:  dbit 1
0001            136   five_seconds_flag: dbit 1
0002            137   enable_clk:        dbit 1
0003            138   mf:                dbit 1
0004            139   ;sound_flag: dbit 1
0004            140   
0360            141   cseg
0360            142   
0360            143   ;-------------------------------------------------------------------------------------------------------------------------------
0360            144   ;***Messages To Display*** 
0360            145   
0360            146   ;shortened labels
0360 53546D70   147   STemp:  db 'STmp:', 0
     3A00
0366 53546D3A   148   STime:  db 'STm:', 0
     00
036B 52546D70   149   RTemp:  db 'RTmp:', 0
     3A00
0371 52546D3A   150   RTime:  db 'RTm:', 0
     00
0376            151   
0376            152   ;lables for runnning oven
0376 53746174   153   state:     db 'State>' , 0
     653E00
037D 546D653E   154   time:      db 'Tme>' , 0
     00
0382 3A00       155   colon:     db ':', 0
0384 546D703E   156   temp:      db 'Tmp>', 0
     00
0389            157   
0389            158   ;labels for changin parameters
0389 5265666C   159   ReflowTemp:  db 'Reflow Temperature:', 0
     6F772054
     656D7065
     72617475
     72653A00
039D 5265666C   160   ReflowTime:  db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03AA 536F616B   161   SoakTime:    db 'Soak Time:', 0
     2054696D
     653A00
03B5 536F616B   162   SoakTemp:    db 'Soak Temperature:', 0
     2054656D
     70657261
     74757265
     3A00
03C7            163   
03C7            164   
03C7            165   ;Current State in Oven
03C7 52616D70   166   Ramp2Soak: db 'Ramp-Soak' , 0
     2D536F61
     6B00
03D1 536F616B   167   Soak:      db 'Soak' , 0
     00
03D6 52616D70   168   Ramp2Peak: db 'Ramp-Peak' , 0
     2D506561
     6B00
03E0 5265666C   169   Reflow:    db 'Reflow' , 0
     6F7700
03E7 436F6F6C   170   Cooling:   db 'Cooling' , 0
     696E6700
03EF            171   
03EF            172   ;-------------------------------------------------------------------------------------------------------------------------------
03EF            173   ;FXNS FOR THERMOWIRE
03EF            174   
03EF            175   ;initialize SPI 
03EF            176   INI_SPI:
03EF D295       177            setb MY_MISO          ; Make MISO an input pin
03F1 C294       178            clr MY_SCLK           ; Mode 0,0 default
03F3 22         179            ret
03F4            180   DO_SPI_G:
03F4 C0E0       181            push acc
03F6 7900       182            mov R1, #0            ; Received byte stored in R1
03F8 7A08       183            mov R2, #8            ; Loop counter (8-bits)
03FA            184   DO_SPI_G_LOOP:
03FA E8         185            mov a, R0             ; Byte to write is in R0
03FB 33         186            rlc a                 ; Carry flag has bit to write
03FC F8         187            mov R0, a
03FD 9296       188            mov MY_MOSI, c
03FF D294       189            setb MY_SCLK          ; Transmit
0401 A295       190            mov c, MY_MISO        ; Read received bit
0403 E9         191            mov a, R1             ; Save received bit in R1
0404 33         192            rlc a
0405 F9         193            mov R1, a
0406 C294       194            clr MY_SCLK
0408 DAF0       195            djnz R2, DO_SPI_G_LOOP
040A D0E0       196            pop acc
040C 22         197   ret
040D            198   
040D            199   Send_SPI:
                200   	SPIBIT MAC
                201   	    ; Send/Receive bit %0
                202   		rlc a
                203   		mov MY_MOSI_SOUND, c
                204   		setb MY_SCLK_SOUND
                205   		mov c, MY_MISO_SOUND
                206   		clr MY_SCLK_SOUND
                207   		mov acc.0, c
                208   	ENDMAC
040D            209            
040D            210                ; Send/Receive bit 7
040D 33         210                    rlc a
040E 92A4       210                    mov MY_MOSI_SOUND, c
0410 D2A0       210                    setb MY_SCLK_SOUND
0412 A2A1       210                    mov c, MY_MISO_SOUND
0414 C2A0       210                    clr MY_SCLK_SOUND
0416 92E0       210                    mov acc.0, c
0418            211                ; Send/Receive bit 6
0418 33         211                    rlc a
0419 92A4       211                    mov MY_MOSI_SOUND, c
041B D2A0       211                    setb MY_SCLK_SOUND
041D A2A1       211                    mov c, MY_MISO_SOUND
041F C2A0       211                    clr MY_SCLK_SOUND
0421 92E0       211                    mov acc.0, c
0423            212                ; Send/Receive bit 5
0423 33         212                    rlc a
0424 92A4       212                    mov MY_MOSI_SOUND, c
0426 D2A0       212                    setb MY_SCLK_SOUND
0428 A2A1       212                    mov c, MY_MISO_SOUND
042A C2A0       212                    clr MY_SCLK_SOUND
042C 92E0       212                    mov acc.0, c
042E            213                ; Send/Receive bit 4
042E 33         213                    rlc a
042F 92A4       213                    mov MY_MOSI_SOUND, c
0431 D2A0       213                    setb MY_SCLK_SOUND
0433 A2A1       213                    mov c, MY_MISO_SOUND
0435 C2A0       213                    clr MY_SCLK_SOUND
0437 92E0       213                    mov acc.0, c
0439            214                ; Send/Receive bit 3
0439 33         214                    rlc a
043A 92A4       214                    mov MY_MOSI_SOUND, c
043C D2A0       214                    setb MY_SCLK_SOUND
043E A2A1       214                    mov c, MY_MISO_SOUND
0440 C2A0       214                    clr MY_SCLK_SOUND
0442 92E0       214                    mov acc.0, c
0444            215                ; Send/Receive bit 2
0444 33         215                    rlc a
0445 92A4       215                    mov MY_MOSI_SOUND, c
0447 D2A0       215                    setb MY_SCLK_SOUND
0449 A2A1       215                    mov c, MY_MISO_SOUND
044B C2A0       215                    clr MY_SCLK_SOUND
044D 92E0       215                    mov acc.0, c
044F            216                ; Send/Receive bit 1
044F 33         216                    rlc a
0450 92A4       216                    mov MY_MOSI_SOUND, c
0452 D2A0       216                    setb MY_SCLK_SOUND
0454 A2A1       216                    mov c, MY_MISO_SOUND
0456 C2A0       216                    clr MY_SCLK_SOUND
0458 92E0       216                    mov acc.0, c
045A            217                ; Send/Receive bit 0
045A 33         217                    rlc a
045B 92A4       217                    mov MY_MOSI_SOUND, c
045D D2A0       217                    setb MY_SCLK_SOUND
045F A2A1       217                    mov c, MY_MISO_SOUND
0461 C2A0       217                    clr MY_SCLK_SOUND
0463 92E0       217                    mov acc.0, c
0465            218   
0465 22         219   ret
0466            220   
                221   Change_8bit_Variable MAC
                222       jb %0, %2
                223       Wait_Milli_Seconds(#50) ; de-bounce
                224       jb %0, %2
                225       jnb %0, $
                226       jb SHIFT_BUTTON, skip%Mb
                227       dec %1
                228       sjmp skip%Ma
                229       skip%Mb:
                230       inc %1
                231       skip%Ma:
                232   ENDMAC
0466            233   
0466            234   ;Change_8bit_Variable(MY_VARIABLE_BUTTON, my_variable, loop_c)
0466            235   ;    Set_Cursor(2, 14)
0466            236   ;    mov a, my_variable
0466            237   ;    lcall SendToLCD
0466            238   ;lcall Save_Configuration
0466            239   
0466            240   ;-------------------------------------------------------------------------------------------------------------------------------
0466            241   ;***FXNS For Serial Port
0466            242   
0466            243   ; Configure the serial port and baud rate
0466            244   InitSerialPort:
0466            245       ; Since the reset button bounces, we need to wait a bit before
0466            246       ; sending messages, otherwise we risk displaying gibberish!
0466 79DE       247       mov R1, #222
0468 78A6       248       mov R0, #166
046A D8FE       249       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
046C D9FA       250       djnz R1, $-4 ; 22.51519us*222=4.998ms
046E            251       ; Now we can proceed with the configuration
046E 438780     252            orl     PCON,#0x80
0471 759852     253            mov     SCON,#0x52
0474 759B00     254            mov     BDRCON,#0x00
0477 759AF4     255            mov     BRL,#BRG_VAL
047A 759B1E     256            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
047D 22         257   ret
047E            258   
047E            259   
047E            260   putchar:
047E 3099FD     261       jnb TI, putchar
0481 C299       262       clr TI
0483 F599       263       mov SBUF, a
0485 22         264   ret
0486            265   
0486            266   ;-------------------------------------------------------------------------------------------------------------------------------
0486            267   ;***FXNS to CHECK BUTTONS
0486            268   
0486            269   CHECK_STIME:
0486            270   
0486 208218     271       jb STIME_BUTTON, CHECK_STIME_END
0489 C002       271            push AR2
048B 7A32       271            mov R2, #50
048D 120039     271            lcall ?Wait_Milli_Seconds
0490 D002       271            pop AR2 ; de-bounce
0492 20820C     271       jb STIME_BUTTON, CHECK_STIME_END
0495 3082FD     271       jnb STIME_BUTTON, $
0498 208104     271       jb SHIFT_BUTTON, skip16b
049B 1535       271       dec Time_soak
049D 8002       271       sjmp skip16a
049F            271       skip16b:
049F 0535       271       inc Time_soak
04A1            271       skip16a:
04A1            272            
04A1            273   CHECK_STIME_END:
04A1 22         274   ret
04A2            275   
04A2            276   CHECK_STEMP:
04A2 208318     277       jb STEMP_BUTTON, CHECK_STEMP_END
04A5 C002       277            push AR2
04A7 7A32       277            mov R2, #50
04A9 120039     277            lcall ?Wait_Milli_Seconds
04AC D002       277            pop AR2 ; de-bounce
04AE 20830C     277       jb STEMP_BUTTON, CHECK_STEMP_END
04B1 3083FD     277       jnb STEMP_BUTTON, $
04B4 208104     277       jb SHIFT_BUTTON, skip18b
04B7 1534       277       dec Temp_soak
04B9 8002       277       sjmp skip18a
04BB            277       skip18b:
04BB 0534       277       inc Temp_soak
04BD            277       skip18a:
04BD            278       ;lcall Save_Configuration
04BD            279            
04BD            280   CHECK_STEMP_END:
04BD 22         281   ret
04BE            282   
04BE            283   CHECK_RTIME:
04BE 208418     284       jb RTIME_BUTTON, CHECK_RTIME_END
04C1 C002       284            push AR2
04C3 7A32       284            mov R2, #50
04C5 120039     284            lcall ?Wait_Milli_Seconds
04C8 D002       284            pop AR2 ; de-bounce
04CA 20840C     284       jb RTIME_BUTTON, CHECK_RTIME_END
04CD 3084FD     284       jnb RTIME_BUTTON, $
04D0 208104     284       jb SHIFT_BUTTON, skip20b
04D3 1537       284       dec Time_refl
04D5 8002       284       sjmp skip20a
04D7            284       skip20b:
04D7 0537       284       inc Time_refl
04D9            284       skip20a:
04D9            285   CHECK_RTIME_END:
04D9 22         286   ret
04DA            287   
04DA            288   CHECK_RTEMP:
04DA 208618     289       jb RTEMP_BUTTON, CHECK_RTEMP_END
04DD C002       289            push AR2
04DF 7A32       289            mov R2, #50
04E1 120039     289            lcall ?Wait_Milli_Seconds
04E4 D002       289            pop AR2 ; de-bounce
04E6 20860C     289       jb RTEMP_BUTTON, CHECK_RTEMP_END
04E9 3086FD     289       jnb RTEMP_BUTTON, $
04EC 208104     289       jb SHIFT_BUTTON, skip22b
04EF 1536       289       dec Temp_refl
04F1 8002       289       sjmp skip22a
04F3            289       skip22b:
04F3 0536       289       inc Temp_refl
04F5            289       skip22a:
04F5            290   CHECK_RTEMP_END:
04F5 22         291   ret
04F6            292   
04F6            293   CHECK_POWER:
04F6            294   
04F6 20C518     295       jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
04F9 C002       296            push AR2
04FB 7A32       296            mov R2, #50
04FD 120039     296            lcall ?Wait_Milli_Seconds
0500 D002       296            pop AR2 ; debounce time
0502 20C50C     297            jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
0505 30C5FD     298            jnb POWER_BUTTON, $ ; loop while the button is pressed
0508 754F00     299       mov pwm_ratio+0, #low(0)
050B 755000     300            mov pwm_ratio+1, #high(0)
050E 120F49     301       lcall OFF_STATE
0511            302   
0511            303   CHECK_POWER_END:
0511 22         304   ret
0512            305   
0512            306   CHECK_K_OR_C:
0512            307   
0512 20860F     308       jb RTEMP_BUTTON, CHECK_K_OR_C_END ; if button not pressed, stop checking
0515 C002       309            push AR2
0517 7A32       309            mov R2, #50
0519 120039     309            lcall ?Wait_Milli_Seconds
051C D002       309            pop AR2 ; debounce time
051E 208603     310            jb RTEMP_BUTTON, CHECK_K_OR_C_END ; if button not pressed, stop checking
0521 3086FD     311            jnb RTEMP_BUTTON, $ ; loop while the button is pressed
0524            312       
0524            313       ;mov a, K_or_C
0524            314       ;anl a,
0524            315       ;anl a, #00000001B  ; We need only the two least significant bits
0524            316   
0524            317   
0524            318   CHECK_K_OR_C_END:
0524 22         319   ret
0525            320   
0525            321   ; Playback MACRO for sound --------------------------------------------------
0525            322   
                323   PLAYBACK_TEMP MAC
                324       ; ***play audio***
                325       ;cjne sound_flag, #0, $
                326       
                327       lcall Wait_Half_Second
                328       clr TR1 ; Stop Timer 1 ISR from playing previous request
                329       setb FLASH_CE
                330       ;setb sound_flag ; sound starts
                331       clr SPEAKER ; Turn off speaker
                332       clr FLASH_CE ; Enable SPI Flash
                333       mov a, #READ_BYTES
                334       lcall Send_SPI
                335       ; Set the initial position in memory where to start playing
                336       
                337       mov a, %0 ; change initial position
                338       lcall Send_SPI
                339       mov a, %1 ; next memory position
                340       lcall Send_SPI
                341       mov a, %2 ; next memory position
                342       lcall Send_SPI
                343       mov a, %0 ; request first byte to send to DAC
                344       lcall Send_SPI
                345       
                346       ; How many bytes to play?
                347       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
                348       mov w+1, %3 ; Load the middle byte of the number of bytes to play
                349       mov w+0, %4 ; Load the low byte of the number of bytes to play
                350       
                351       
                352       setb SPEAKER ;Turn on speaker
                353       setb TR1 ;Start playback by enabling Timer1
                354       ;clr sound_flag ; sound ends
                355   ENDMAC
0525            356   
0525            357   
0525            358   
0525            359   ;**SOUND STUFF---------------------------------------------------------------
0525            360   
0525            361   SOUND_FSM:
0525            362   state_0_sound:
0525            363   ;check if 5 seconds has passed, if yes go to state 1, if no exit function 
0525 300104     364       jnb five_seconds_flag, Sound_ret
0528 C201       365       clr five_seconds_flag
052A 8001       366       sjmp state_1_sound
052C            367   Sound_ret:
052C 22         368       ret
052D            369   
052D            370   state_1_sound:
052D            371   ; check if temp is greater than or equal to 100, if yes go to state 2
052D            372   ; check if temp is less than 100, if yes go to state 4
052D E53B       373       mov a, Temp_oven
052F 9464       374       subb a, #100
0531 5002       375       jnc state_2_sound_hop
0533 4002       376       jc state_4_sound_hop
0535            377   
0535            378       state_2_sound_hop:
0535 8003       379           sjmp state_2_sound
0537            380   
0537            381       state_4_sound_hop:
0537 020633     382           ljmp state_4_sound
053A            383   
053A            384   state_2_sound:
053A            385   ;divide temp by 100, if it is 1 play sound: "100", if it is 2 play sound: "200"
053A            386   ; go to state_3_sound
053A 75F064     387       mov b, #100
053D E53B       388       mov a, Temp_oven
053F 84         389       div ab
0540 9401       390       subb a, #1
0542 600A       391       jz play_sound_100
0544            392   
0544 75F064     393       mov b, #100
0547 E53B       394       mov a, Temp_oven
0549 84         395       div ab
054A 9402       396       subb a, #2
054C 6065       397       jz play_sound_200
054E            398      
054E            399       play_sound_100: 
054E            400       ; ***play audio***
054E            400       ;cjne sound_flag, #0, $
054E            400       
054E 121036     400       lcall Wait_Half_Second
0551 C28E       400       clr TR1 ; Stop Timer 1 ISR from playing previous request
0553 D2A5       400       setb FLASH_CE
0555            400       ;setb sound_flag ; sound starts
0555 C2A6       400       clr SPEAKER ; Turn off speaker
0557 C2A5       400       clr FLASH_CE ; Enable SPI Flash
0559 7403       400       mov a, #READ_BYTES
055B 12040D     400       lcall Send_SPI
055E            400       ; Set the initial position in memory where to start playing
055E            400       
055E 7401       400       mov a, #0x01 ; change initial position
0560 12040D     400       lcall Send_SPI
0563 7493       400       mov a, #0x93 ; next memory position
0565 12040D     400       lcall Send_SPI
0568 7484       400       mov a, #0x84 ; next memory position
056A 12040D     400       lcall Send_SPI
056D 7401       400       mov a, #0x01 ; request first byte to send to DAC
056F 12040D     400       lcall Send_SPI
0572            400       
0572            400       ; How many bytes to play?
0572 754E00     400       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0575 754D36     400       mov w+1, #0x36 ; Load the middle byte of the number of bytes to play
0578 754CB0     400       mov w+0, #0xb0 ; Load the low byte of the number of bytes to play
057B            400       
057B            400       
057B D2A6       400       setb SPEAKER ;Turn on speaker
057D D28E       400       setb TR1 ;Start playback by enabling Timer1
057F            400       ;clr sound_flag ; sound ends ;one
057F            401       ; ***play audio***
057F            401       ;cjne sound_flag, #0, $
057F            401       
057F 121036     401       lcall Wait_Half_Second
0582 C28E       401       clr TR1 ; Stop Timer 1 ISR from playing previous request
0584 D2A5       401       setb FLASH_CE
0586            401       ;setb sound_flag ; sound starts
0586 C2A6       401       clr SPEAKER ; Turn off speaker
0588 C2A5       401       clr FLASH_CE ; Enable SPI Flash
058A 7403       401       mov a, #READ_BYTES
058C 12040D     401       lcall Send_SPI
058F            401       ; Set the initial position in memory where to start playing
058F            401       
058F 7405       401       mov a, #0x05 ; change initial position
0591 12040D     401       lcall Send_SPI
0594 7409       401       mov a, #0x09 ; next memory position
0596 12040D     401       lcall Send_SPI
0599 7410       401       mov a, #0x10 ; next memory position
059B 12040D     401       lcall Send_SPI
059E 7405       401       mov a, #0x05 ; request first byte to send to DAC
05A0 12040D     401       lcall Send_SPI
05A3            401       
05A3            401       ; How many bytes to play?
05A3 754E00     401       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
05A6 754D27     401       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
05A9 754C10     401       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
05AC            401       
05AC            401       
05AC D2A6       401       setb SPEAKER ;Turn on speaker
05AE D28E       401       setb TR1 ;Start playback by enabling Timer1
05B0            401       ;clr sound_flag ; sound ends ;hundred
05B0 020618     402           ljmp state_3_sound
05B3            403   
05B3            404       play_sound_200:
05B3            405       ; ***play audio***
05B3            405       ;cjne sound_flag, #0, $
05B3            405       
05B3 121036     405       lcall Wait_Half_Second
05B6 C28E       405       clr TR1 ; Stop Timer 1 ISR from playing previous request
05B8 D2A5       405       setb FLASH_CE
05BA            405       ;setb sound_flag ; sound starts
05BA C2A6       405       clr SPEAKER ; Turn off speaker
05BC C2A5       405       clr FLASH_CE ; Enable SPI Flash
05BE 7403       405       mov a, #READ_BYTES
05C0 12040D     405       lcall Send_SPI
05C3            405       ; Set the initial position in memory where to start playing
05C3            405       
05C3 7401       405       mov a, #0x01 ; change initial position
05C5 12040D     405       lcall Send_SPI
05C8 74C7       405       mov a, #0xc7 ; next memory position
05CA 12040D     405       lcall Send_SPI
05CD 7414       405       mov a, #0x14 ; next memory position
05CF 12040D     405       lcall Send_SPI
05D2 7401       405       mov a, #0x01 ; request first byte to send to DAC
05D4 12040D     405       lcall Send_SPI
05D7            405       
05D7            405       ; How many bytes to play?
05D7 754E00     405       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
05DA 754D13     405       mov w+1, #0x13 ; Load the middle byte of the number of bytes to play
05DD 754C88     405       mov w+0, #0x88 ; Load the low byte of the number of bytes to play
05E0            405       
05E0            405       
05E0 D2A6       405       setb SPEAKER ;Turn on speaker
05E2 D28E       405       setb TR1 ;Start playback by enabling Timer1
05E4            405       ;clr sound_flag ; sound ends ;two
05E4            406       ; ***play audio***
05E4            406       ;cjne sound_flag, #0, $
05E4            406       
05E4 121036     406       lcall Wait_Half_Second
05E7 C28E       406       clr TR1 ; Stop Timer 1 ISR from playing previous request
05E9 D2A5       406       setb FLASH_CE
05EB            406       ;setb sound_flag ; sound starts
05EB C2A6       406       clr SPEAKER ; Turn off speaker
05ED C2A5       406       clr FLASH_CE ; Enable SPI Flash
05EF 7403       406       mov a, #READ_BYTES
05F1 12040D     406       lcall Send_SPI
05F4            406       ; Set the initial position in memory where to start playing
05F4            406       
05F4 7405       406       mov a, #0x05 ; change initial position
05F6 12040D     406       lcall Send_SPI
05F9 7409       406       mov a, #0x09 ; next memory position
05FB 12040D     406       lcall Send_SPI
05FE 7410       406       mov a, #0x10 ; next memory position
0600 12040D     406       lcall Send_SPI
0603 7405       406       mov a, #0x05 ; request first byte to send to DAC
0605 12040D     406       lcall Send_SPI
0608            406       
0608            406       ; How many bytes to play?
0608 754E00     406       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
060B 754D27     406       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
060E 754C10     406       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0611            406       
0611            406       
0611 D2A6       406       setb SPEAKER ;Turn on speaker
0613 D28E       406       setb TR1 ;Start playback by enabling Timer1
0615            406       ;clr sound_flag ; sound ends ;hundred
0615 020618     407           ljmp state_3_sound
0618            408   
0618            409   state_3_sound:
0618            410   ; check remainder of temp, if it is 0, exit
0618            411   ; if not 0, go to state_4_sound
0618            412   
0618            413   
0618 75F064     414       mov b, #100
061B E53B       415       mov a, Temp_oven
061D 95F0       416       subb a, b
061F E5F0       417       mov a, b
0621 600D       418       jz state_3_sound_hop
0623            419       
0623 75F0C8     420       mov b, #200
0626 E53B       421       mov a, Temp_oven
0628 95F0       422       subb a, b
062A E5F0       423       mov a, b
062C 6002       424       jz state_3_sound_hop
062E            425   
062E 8003       426       sjmp state_4_sound
0630            427   
0630            428       state_3_sound_hop:
0630 02052C     429           ljmp Sound_ret
0633            430   
0633            431   state_4_sound:
0633            432   ; if T % 100 greater or equal to 20, go to state_5_sound,
0633 75F064     433       mov b, #100
0636 E53B       434       mov a, Temp_oven
0638 84         435       div ab
0639            436       ;mov R0, b
0639 E5F0       437       mov a, b 
063B            438   
063B            439   
063B 9414       440       subb a, #20
063D 5027       441       jnc state_5_sound
063F 6025       442       jz state_5_sound
0641 E4         443       clr a
0642            444   ; if T % 100 is less than 10, go to state_6_sound
0642 75F064     445       mov b, #100
0645 E53B       446       mov a, Temp_oven
0647 84         447       div ab
0648 E5F0       448       mov a, b
064A 940A       449       subb a, #10
064C 4015       450       jc state_6_sound_hop0
064E            451       
064E            452       ;mov a, b
064E            453       
064E            454       ; ubb a, #0
064E            455       ;jc state_6_sound_hop0
064E            456       ;clr a
064E            457   ; if T % 100 is greater than or equal to 10 and less than 20, go to state_7_sound
064E            458   
064E 75F064     459       mov b, #100
0651 E53B       460       mov a, Temp_oven
0653 84         461       div ab
0654 E5F0       462       mov a, b
0656 940A       463       subb a, #10
0658 6000       464       jz and_branch
065A            465   
065A            466       and_branch:
065A E5F0       467           mov a, b
065C 9414       468           subb a, #20
065E 4000       469           jc state_7_sound_hop0
0660            470       
0660            471       state_7_sound_hop0:
0660 020A27     472           ljmp state_7_sound
0663            473   
0663            474       state_6_sound_hop0:
0663 020827     475           ljmp state_6_sound
0666            476       
0666            477   
0666            478   state_5_sound:
0666            479   ; play number from 20 to 90 in decades (20, 30, 40, 50, 60, 70, 80, 90), based off remainder from temp divided by 100
0666            480   ; if (T % 100) % 10 is not equal to 0, go to state_6_sound
0666            481   ; if (T % 100) % 10 is equal to 0, go to state_8_sound
0666            482   
0666            483       play_sound:
0666            484           ;ljmp PLAYBACK_TEMP
0666 E53B       485           mov a, Temp_oven
0668 75F064     486           mov b, #100
066B 84         487           div ab
066C E5F0       488           mov a, b
066E 75F00A     489           mov b, #10
0671 84         490           div ab
0672 B40234     491           cjne a, #2, play_30
0675            492           ;mov    
0675            493   
0675            494           play_20:
0675            495       ; ***play audio***
0675            495       ;cjne sound_flag, #0, $
0675            495       
0675 121036     495       lcall Wait_Half_Second
0678 C28E       495       clr TR1 ; Stop Timer 1 ISR from playing previous request
067A D2A5       495       setb FLASH_CE
067C            495       ;setb sound_flag ; sound starts
067C C2A6       495       clr SPEAKER ; Turn off speaker
067E C2A5       495       clr FLASH_CE ; Enable SPI Flash
0680 7403       495       mov a, #READ_BYTES
0682 12040D     495       lcall Send_SPI
0685            495       ; Set the initial position in memory where to start playing
0685            495       
0685 7403       495       mov a, #0x03 ; change initial position
0687 12040D     495       lcall Send_SPI
068A 74EF       495       mov a, #0xef ; next memory position
068C 12040D     495       lcall Send_SPI
068F 74D0       495       mov a, #0xd0 ; next memory position
0691 12040D     495       lcall Send_SPI
0694 7403       495       mov a, #0x03 ; request first byte to send to DAC
0696 12040D     495       lcall Send_SPI
0699            495       
0699            495       ; How many bytes to play?
0699 754E00     495       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
069C 754D27     495       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
069F 754C10     495       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
06A2            495       
06A2            495       
06A2 D2A6       495       setb SPEAKER ;Turn on speaker
06A4 D28E       495       setb TR1 ;Start playback by enabling Timer1
06A6            495       ;clr sound_flag ; sound ends
06A6            496               ;lcall Wait_One_Second
06A6 020824     497               ljmp state_6_sound_hop1
06A9            498   
06A9            499           play_30:
06A9            500               
06A9 B40334     501               cjne a, #3, play_40   
06AC            502       ; ***play audio***
06AC            502       ;cjne sound_flag, #0, $
06AC            502       
06AC 121036     502       lcall Wait_Half_Second
06AF C28E       502       clr TR1 ; Stop Timer 1 ISR from playing previous request
06B1 D2A5       502       setb FLASH_CE
06B3            502       ;setb sound_flag ; sound starts
06B3 C2A6       502       clr SPEAKER ; Turn off speaker
06B5 C2A5       502       clr FLASH_CE ; Enable SPI Flash
06B7 7403       502       mov a, #READ_BYTES
06B9 12040D     502       lcall Send_SPI
06BC            502       ; Set the initial position in memory where to start playing
06BC            502       
06BC 7404       502       mov a, #0x04 ; change initial position
06BE 12040D     502       lcall Send_SPI
06C1 7416       502       mov a, #0x16 ; next memory position
06C3 12040D     502       lcall Send_SPI
06C6 74E0       502       mov a, #0xe0 ; next memory position
06C8 12040D     502       lcall Send_SPI
06CB 7404       502       mov a, #0x04 ; request first byte to send to DAC
06CD 12040D     502       lcall Send_SPI
06D0            502       
06D0            502       ; How many bytes to play?
06D0 754E00     502       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
06D3 754D23     502       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
06D6 754C28     502       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
06D9            502       
06D9            502       
06D9 D2A6       502       setb SPEAKER ;Turn on speaker
06DB D28E       502       setb TR1 ;Start playback by enabling Timer1
06DD            502       ;clr sound_flag ; sound ends
06DD 020824     503               ljmp state_6_sound_hop1
06E0            504   
06E0            505           play_40:
06E0            506               
06E0 B40434     507               cjne a, #4, play_50  
06E3            508       ; ***play audio***
06E3            508       ;cjne sound_flag, #0, $
06E3            508       
06E3 121036     508       lcall Wait_Half_Second
06E6 C28E       508       clr TR1 ; Stop Timer 1 ISR from playing previous request
06E8 D2A5       508       setb FLASH_CE
06EA            508       ;setb sound_flag ; sound starts
06EA C2A6       508       clr SPEAKER ; Turn off speaker
06EC C2A5       508       clr FLASH_CE ; Enable SPI Flash
06EE 7403       508       mov a, #READ_BYTES
06F0 12040D     508       lcall Send_SPI
06F3            508       ; Set the initial position in memory where to start playing
06F3            508       
06F3 7404       508       mov a, #0x04 ; change initial position
06F5 12040D     508       lcall Send_SPI
06F8 743D       508       mov a, #0x3d ; next memory position
06FA 12040D     508       lcall Send_SPI
06FD 74F0       508       mov a, #0xf0 ; next memory position
06FF 12040D     508       lcall Send_SPI
0702 7404       508       mov a, #0x04 ; request first byte to send to DAC
0704 12040D     508       lcall Send_SPI
0707            508       
0707            508       ; How many bytes to play?
0707 754E00     508       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
070A 754D1F     508       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
070D 754C40     508       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0710            508       
0710            508       
0710 D2A6       508       setb SPEAKER ;Turn on speaker
0712 D28E       508       setb TR1 ;Start playback by enabling Timer1
0714            508       ;clr sound_flag ; sound ends
0714 020824     509               ljmp state_6_sound_hop1
0717            510   
0717            511           play_50:
0717            512              
0717 B40534     513               cjne a, #5, play_60  
071A            514       ; ***play audio***
071A            514       ;cjne sound_flag, #0, $
071A            514       
071A 121036     514       lcall Wait_Half_Second
071D C28E       514       clr TR1 ; Stop Timer 1 ISR from playing previous request
071F D2A5       514       setb FLASH_CE
0721            514       ;setb sound_flag ; sound starts
0721 C2A6       514       clr SPEAKER ; Turn off speaker
0723 C2A5       514       clr FLASH_CE ; Enable SPI Flash
0725 7403       514       mov a, #READ_BYTES
0727 12040D     514       lcall Send_SPI
072A            514       ; Set the initial position in memory where to start playing
072A            514       
072A 7404       514       mov a, #0x04 ; change initial position
072C 12040D     514       lcall Send_SPI
072F 7451       514       mov a, #0x51 ; next memory position
0731 12040D     514       lcall Send_SPI
0734 7478       514       mov a, #0x78 ; next memory position
0736 12040D     514       lcall Send_SPI
0739 7404       514       mov a, #0x04 ; request first byte to send to DAC
073B 12040D     514       lcall Send_SPI
073E            514       
073E            514       ; How many bytes to play?
073E 754E00     514       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0741 754D23     514       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
0744 754C28     514       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0747            514       
0747            514       
0747 D2A6       514       setb SPEAKER ;Turn on speaker
0749 D28E       514       setb TR1 ;Start playback by enabling Timer1
074B            514       ;clr sound_flag ; sound ends
074B 020824     515               ljmp state_6_sound_hop1
074E            516   
074E            517           play_60:
074E            518               
074E B40634     519               cjne a, #6, play_70  
0751            520       ; ***play audio***
0751            520       ;cjne sound_flag, #0, $
0751            520       
0751 121036     520       lcall Wait_Half_Second
0754 C28E       520       clr TR1 ; Stop Timer 1 ISR from playing previous request
0756 D2A5       520       setb FLASH_CE
0758            520       ;setb sound_flag ; sound starts
0758 C2A6       520       clr SPEAKER ; Turn off speaker
075A C2A5       520       clr FLASH_CE ; Enable SPI Flash
075C 7403       520       mov a, #READ_BYTES
075E 12040D     520       lcall Send_SPI
0761            520       ; Set the initial position in memory where to start playing
0761            520       
0761 7404       520       mov a, #0x04 ; change initial position
0763 12040D     520       lcall Send_SPI
0766 7474       520       mov a, #0x74 ; next memory position
0768 12040D     520       lcall Send_SPI
076B 74A0       520       mov a, #0xa0 ; next memory position
076D 12040D     520       lcall Send_SPI
0770 7404       520       mov a, #0x04 ; request first byte to send to DAC
0772 12040D     520       lcall Send_SPI
0775            520       
0775            520       ; How many bytes to play?
0775 754E00     520       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0778 754D27     520       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
077B 754C10     520       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
077E            520       
077E            520       
077E D2A6       520       setb SPEAKER ;Turn on speaker
0780 D28E       520       setb TR1 ;Start playback by enabling Timer1
0782            520       ;clr sound_flag ; sound ends
0782 020824     521               ljmp state_6_sound_hop1
0785            522   
0785            523           play_70:
0785            524              
0785 B40734     525               cjne a, #7, play_80  
0788            526       ; ***play audio***
0788            526       ;cjne sound_flag, #0, $
0788            526       
0788 121036     526       lcall Wait_Half_Second
078B C28E       526       clr TR1 ; Stop Timer 1 ISR from playing previous request
078D D2A5       526       setb FLASH_CE
078F            526       ;setb sound_flag ; sound starts
078F C2A6       526       clr SPEAKER ; Turn off speaker
0791 C2A5       526       clr FLASH_CE ; Enable SPI Flash
0793 7403       526       mov a, #READ_BYTES
0795 12040D     526       lcall Send_SPI
0798            526       ; Set the initial position in memory where to start playing
0798            526       
0798 7404       526       mov a, #0x04 ; change initial position
079A 12040D     526       lcall Send_SPI
079D 749B       526       mov a, #0x9b ; next memory position
079F 12040D     526       lcall Send_SPI
07A2 74B0       526       mov a, #0xb0 ; next memory position
07A4 12040D     526       lcall Send_SPI
07A7 7404       526       mov a, #0x04 ; request first byte to send to DAC
07A9 12040D     526       lcall Send_SPI
07AC            526       
07AC            526       ; How many bytes to play?
07AC 754E00     526       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
07AF 754D32     526       mov w+1, #0x32 ; Load the middle byte of the number of bytes to play
07B2 754CC8     526       mov w+0, #0xc8 ; Load the low byte of the number of bytes to play
07B5            526       
07B5            526       
07B5 D2A6       526       setb SPEAKER ;Turn on speaker
07B7 D28E       526       setb TR1 ;Start playback by enabling Timer1
07B9            526       ;clr sound_flag ; sound ends
07B9 020824     527               ljmp state_6_sound_hop1
07BC            528   
07BC            529           play_80:
07BC            530               
07BC B40834     531               cjne a, #8, play_90  
07BF            532       ; ***play audio***
07BF            532       ;cjne sound_flag, #0, $
07BF            532       
07BF 121036     532       lcall Wait_Half_Second
07C2 C28E       532       clr TR1 ; Stop Timer 1 ISR from playing previous request
07C4 D2A5       532       setb FLASH_CE
07C6            532       ;setb sound_flag ; sound starts
07C6 C2A6       532       clr SPEAKER ; Turn off speaker
07C8 C2A5       532       clr FLASH_CE ; Enable SPI Flash
07CA 7403       532       mov a, #READ_BYTES
07CC 12040D     532       lcall Send_SPI
07CF            532       ; Set the initial position in memory where to start playing
07CF            532       
07CF 7404       532       mov a, #0x04 ; change initial position
07D1 12040D     532       lcall Send_SPI
07D4 74C6       532       mov a, #0xc6 ; next memory position
07D6 12040D     532       lcall Send_SPI
07D9 74A8       532       mov a, #0xa8 ; next memory position
07DB 12040D     532       lcall Send_SPI
07DE 7404       532       mov a, #0x04 ; request first byte to send to DAC
07E0 12040D     532       lcall Send_SPI
07E3            532       
07E3            532       ; How many bytes to play?
07E3 754E00     532       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
07E6 754D23     532       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
07E9 754C28     532       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
07EC            532       
07EC            532       
07EC D2A6       532       setb SPEAKER ;Turn on speaker
07EE D28E       532       setb TR1 ;Start playback by enabling Timer1
07F0            532       ;clr sound_flag ; sound ends
07F0 020824     533               ljmp state_6_sound_hop1
07F3            534   
07F3            535           play_90:
07F3            536       ; ***play audio***
07F3            536       ;cjne sound_flag, #0, $
07F3            536       
07F3 121036     536       lcall Wait_Half_Second
07F6 C28E       536       clr TR1 ; Stop Timer 1 ISR from playing previous request
07F8 D2A5       536       setb FLASH_CE
07FA            536       ;setb sound_flag ; sound starts
07FA C2A6       536       clr SPEAKER ; Turn off speaker
07FC C2A5       536       clr FLASH_CE ; Enable SPI Flash
07FE 7403       536       mov a, #READ_BYTES
0800 12040D     536       lcall Send_SPI
0803            536       ; Set the initial position in memory where to start playing
0803            536       
0803 7404       536       mov a, #0x04 ; change initial position
0805 12040D     536       lcall Send_SPI
0808 74ED       536       mov a, #0xed ; next memory position
080A 12040D     536       lcall Send_SPI
080D 74B8       536       mov a, #0xb8 ; next memory position
080F 12040D     536       lcall Send_SPI
0812 7404       536       mov a, #0x04 ; request first byte to send to DAC
0814 12040D     536       lcall Send_SPI
0817            536       
0817            536       ; How many bytes to play?
0817 754E00     536       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
081A 754D1F     536       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
081D 754C40     536       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0820            536       
0820            536       
0820 D2A6       536       setb SPEAKER ;Turn on speaker
0822 D28E       536       setb TR1 ;Start playback by enabling Timer1
0824            536       ;clr sound_flag ; sound ends
0824            537   
0824            538       ;mov a, Temp_oven
0824            539       ;mov b, #100 
0824            540       ;div ab
0824            541       ;mov a, b
0824            542       ;mov b, #10
0824            543       ;div ab
0824            544       ;mov a, b
0824            545       ;jnz state_6_sound_hop1
0824            546       
0824            547       ;jz play_sound
0824            548       
0824            549       ;lcall Wait_One_Second
0824            550       ;lcall Wait_One_Second
0824            551       ;lcall Wait_One_Second
0824            552   
0824            553   
0824            554       state_6_sound_hop1:
0824 020827     555           ljmp state_6_sound
0827            556           
0827            557       ;state_8_hop0:
0827            558           ;ljmp state_6_sound ;state_8_sound
0827            559   
0827            560   
0827            561   state_6_sound:
0827            562   ; play 1 - 9
0827            563       ;ljmp PLAYBACK_TEMP
0827 75F064     564       mov b, #100
082A E53B       565       mov a, Temp_oven
082C 84         566       div ab
082D E5F0       567       mov a, b
082F 75F00A     568       mov b, #10
0832 84         569       div ab
0833 E5F0       570       mov a, b
0835            571       
0835 B40003     572       cjne a, #0x00, play_1
0838 020A24     573       ljmp state_8_hop1
083B            574   
083B            575       play_1:
083B B40134     576           cjne a, #0x01, play_2
083E            577       ; ***play audio***
083E            577       ;cjne sound_flag, #0, $
083E            577       
083E 121036     577       lcall Wait_Half_Second
0841 C28E       577       clr TR1 ; Stop Timer 1 ISR from playing previous request
0843 D2A5       577       setb FLASH_CE
0845            577       ;setb sound_flag ; sound starts
0845 C2A6       577       clr SPEAKER ; Turn off speaker
0847 C2A5       577       clr FLASH_CE ; Enable SPI Flash
0849 7403       577       mov a, #READ_BYTES
084B 12040D     577       lcall Send_SPI
084E            577       ; Set the initial position in memory where to start playing
084E            577       
084E 7401       577       mov a, #0x01 ; change initial position
0850 12040D     577       lcall Send_SPI
0853 7493       577       mov a, #0x93 ; next memory position
0855 12040D     577       lcall Send_SPI
0858 7484       577       mov a, #0x84 ; next memory position
085A 12040D     577       lcall Send_SPI
085D 7401       577       mov a, #0x01 ; request first byte to send to DAC
085F 12040D     577       lcall Send_SPI
0862            577       
0862            577       ; How many bytes to play?
0862 754E00     577       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0865 754D36     577       mov w+1, #0x36 ; Load the middle byte of the number of bytes to play
0868 754CB0     577       mov w+0, #0xb0 ; Load the low byte of the number of bytes to play
086B            577       
086B            577       
086B D2A6       577       setb SPEAKER ;Turn on speaker
086D D28E       577       setb TR1 ;Start playback by enabling Timer1
086F            577       ;clr sound_flag ; sound ends 
086F 020A24     578           ljmp state_8_hop1
0872            579   
0872            580       play_2:
0872 B40234     581           cjne a, #0x02, play_3
0875            582       ; ***play audio***
0875            582       ;cjne sound_flag, #0, $
0875            582       
0875 121036     582       lcall Wait_Half_Second
0878 C28E       582       clr TR1 ; Stop Timer 1 ISR from playing previous request
087A D2A5       582       setb FLASH_CE
087C            582       ;setb sound_flag ; sound starts
087C C2A6       582       clr SPEAKER ; Turn off speaker
087E C2A5       582       clr FLASH_CE ; Enable SPI Flash
0880 7403       582       mov a, #READ_BYTES
0882 12040D     582       lcall Send_SPI
0885            582       ; Set the initial position in memory where to start playing
0885            582       
0885 7401       582       mov a, #0x01 ; change initial position
0887 12040D     582       lcall Send_SPI
088A 74C7       582       mov a, #0xc7 ; next memory position
088C 12040D     582       lcall Send_SPI
088F 7414       582       mov a, #0x14 ; next memory position
0891 12040D     582       lcall Send_SPI
0894 7401       582       mov a, #0x01 ; request first byte to send to DAC
0896 12040D     582       lcall Send_SPI
0899            582       
0899            582       ; How many bytes to play?
0899 754E00     582       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
089C 754D13     582       mov w+1, #0x13 ; Load the middle byte of the number of bytes to play
089F 754C88     582       mov w+0, #0x88 ; Load the low byte of the number of bytes to play
08A2            582       
08A2            582       
08A2 D2A6       582       setb SPEAKER ;Turn on speaker
08A4 D28E       582       setb TR1 ;Start playback by enabling Timer1
08A6            582       ;clr sound_flag ; sound ends
08A6 020A24     583           ljmp state_8_hop1
08A9            584   
08A9            585       play_3:
08A9 B40334     586           cjne a, #0x03, play_4
08AC            587       ; ***play audio***
08AC            587       ;cjne sound_flag, #0, $
08AC            587       
08AC 121036     587       lcall Wait_Half_Second
08AF C28E       587       clr TR1 ; Stop Timer 1 ISR from playing previous request
08B1 D2A5       587       setb FLASH_CE
08B3            587       ;setb sound_flag ; sound starts
08B3 C2A6       587       clr SPEAKER ; Turn off speaker
08B5 C2A5       587       clr FLASH_CE ; Enable SPI Flash
08B7 7403       587       mov a, #READ_BYTES
08B9 12040D     587       lcall Send_SPI
08BC            587       ; Set the initial position in memory where to start playing
08BC            587       
08BC 7401       587       mov a, #0x01 ; change initial position
08BE 12040D     587       lcall Send_SPI
08C1 74D6       587       mov a, #0xd6 ; next memory position
08C3 12040D     587       lcall Send_SPI
08C6 7468       587       mov a, #0x68 ; next memory position
08C8 12040D     587       lcall Send_SPI
08CB 7401       587       mov a, #0x01 ; request first byte to send to DAC
08CD 12040D     587       lcall Send_SPI
08D0            587       
08D0            587       ; How many bytes to play?
08D0 754E00     587       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
08D3 754D23     587       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
08D6 754C28     587       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
08D9            587       
08D9            587       
08D9 D2A6       587       setb SPEAKER ;Turn on speaker
08DB D28E       587       setb TR1 ;Start playback by enabling Timer1
08DD            587       ;clr sound_flag ; sound ends
08DD 020A24     588           ljmp state_8_hop1
08E0            589   
08E0            590       play_4:
08E0 B40434     591           cjne a, #0x04, play_5
08E3            592       ; ***play audio***
08E3            592       ;cjne sound_flag, #0, $
08E3            592       
08E3 121036     592       lcall Wait_Half_Second
08E6 C28E       592       clr TR1 ; Stop Timer 1 ISR from playing previous request
08E8 D2A5       592       setb FLASH_CE
08EA            592       ;setb sound_flag ; sound starts
08EA C2A6       592       clr SPEAKER ; Turn off speaker
08EC C2A5       592       clr FLASH_CE ; Enable SPI Flash
08EE 7403       592       mov a, #READ_BYTES
08F0 12040D     592       lcall Send_SPI
08F3            592       ; Set the initial position in memory where to start playing
08F3            592       
08F3 7401       592       mov a, #0x01 ; change initial position
08F5 12040D     592       lcall Send_SPI
08F8 74F4       592       mov a, #0xf4 ; next memory position
08FA 12040D     592       lcall Send_SPI
08FD 7400       592       mov a, #0x00 ; next memory position
08FF 12040D     592       lcall Send_SPI
0902 7401       592       mov a, #0x01 ; request first byte to send to DAC
0904 12040D     592       lcall Send_SPI
0907            592       
0907            592       ; How many bytes to play?
0907 754E00     592       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
090A 754D1B     592       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
090D 754C58     592       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
0910            592       
0910            592       
0910 D2A6       592       setb SPEAKER ;Turn on speaker
0912 D28E       592       setb TR1 ;Start playback by enabling Timer1
0914            592       ;clr sound_flag ; sound ends
0914 020A24     593           ljmp state_8_hop1
0917            594   
0917            595       play_5:
0917 B40534     596           cjne a, #0x05, play_6
091A            597       ; ***play audio***
091A            597       ;cjne sound_flag, #0, $
091A            597       
091A 121036     597       lcall Wait_Half_Second
091D C28E       597       clr TR1 ; Stop Timer 1 ISR from playing previous request
091F D2A5       597       setb FLASH_CE
0921            597       ;setb sound_flag ; sound starts
0921 C2A6       597       clr SPEAKER ; Turn off speaker
0923 C2A5       597       clr FLASH_CE ; Enable SPI Flash
0925 7403       597       mov a, #READ_BYTES
0927 12040D     597       lcall Send_SPI
092A            597       ; Set the initial position in memory where to start playing
092A            597       
092A 7402       597       mov a, #0x02 ; change initial position
092C 12040D     597       lcall Send_SPI
092F 7407       597       mov a, #0x07 ; next memory position
0931 12040D     597       lcall Send_SPI
0934 7488       597       mov a, #0x88 ; next memory position
0936 12040D     597       lcall Send_SPI
0939 7402       597       mov a, #0x02 ; request first byte to send to DAC
093B 12040D     597       lcall Send_SPI
093E            597       
093E            597       ; How many bytes to play?
093E 754E00     597       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0941 754D1B     597       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
0944 754C58     597       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
0947            597       
0947            597       
0947 D2A6       597       setb SPEAKER ;Turn on speaker
0949 D28E       597       setb TR1 ;Start playback by enabling Timer1
094B            597       ;clr sound_flag ; sound ends
094B 020A24     598           ljmp state_8_hop1
094E            599   
094E            600       play_6:
094E B40634     601           cjne a, #0x06, play_7
0951            602       ; ***play audio***
0951            602       ;cjne sound_flag, #0, $
0951            602       
0951 121036     602       lcall Wait_Half_Second
0954 C28E       602       clr TR1 ; Stop Timer 1 ISR from playing previous request
0956 D2A5       602       setb FLASH_CE
0958            602       ;setb sound_flag ; sound starts
0958 C2A6       602       clr SPEAKER ; Turn off speaker
095A C2A5       602       clr FLASH_CE ; Enable SPI Flash
095C 7403       602       mov a, #READ_BYTES
095E 12040D     602       lcall Send_SPI
0961            602       ; Set the initial position in memory where to start playing
0961            602       
0961 7402       602       mov a, #0x02 ; change initial position
0963 12040D     602       lcall Send_SPI
0966 7426       602       mov a, #0x26 ; next memory position
0968 12040D     602       lcall Send_SPI
096B 74C8       602       mov a, #0xc8 ; next memory position
096D 12040D     602       lcall Send_SPI
0970 7402       602       mov a, #0x02 ; request first byte to send to DAC
0972 12040D     602       lcall Send_SPI
0975            602       
0975            602       ; How many bytes to play?
0975 754E00     602       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0978 754D1F     602       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
097B 754C40     602       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
097E            602       
097E            602       
097E D2A6       602       setb SPEAKER ;Turn on speaker
0980 D28E       602       setb TR1 ;Start playback by enabling Timer1
0982            602       ;clr sound_flag ; sound ends
0982 020A24     603           ljmp state_8_hop1
0985            604   
0985            605       play_7:
0985 B40734     606           cjne a, #0x07, play_8
0988            607       ; ***play audio***
0988            607       ;cjne sound_flag, #0, $
0988            607       
0988 121036     607       lcall Wait_Half_Second
098B C28E       607       clr TR1 ; Stop Timer 1 ISR from playing previous request
098D D2A5       607       setb FLASH_CE
098F            607       ;setb sound_flag ; sound starts
098F C2A6       607       clr SPEAKER ; Turn off speaker
0991 C2A5       607       clr FLASH_CE ; Enable SPI Flash
0993 7403       607       mov a, #READ_BYTES
0995 12040D     607       lcall Send_SPI
0998            607       ; Set the initial position in memory where to start playing
0998            607       
0998 7402       607       mov a, #0x02 ; change initial position
099A 12040D     607       lcall Send_SPI
099D 7436       607       mov a, #0x36 ; next memory position
099F 12040D     607       lcall Send_SPI
09A2 7468       607       mov a, #0x68 ; next memory position
09A4 12040D     607       lcall Send_SPI
09A7 7402       607       mov a, #0x02 ; request first byte to send to DAC
09A9 12040D     607       lcall Send_SPI
09AC            607       
09AC            607       ; How many bytes to play?
09AC 754E00     607       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
09AF 754D23     607       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
09B2 754C28     607       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
09B5            607       
09B5            607       
09B5 D2A6       607       setb SPEAKER ;Turn on speaker
09B7 D28E       607       setb TR1 ;Start playback by enabling Timer1
09B9            607       ;clr sound_flag ; sound ends
09B9 020A24     608           ljmp state_8_hop1
09BC            609   
09BC            610       play_8:
09BC B40834     611           cjne a, #0x08, play_9
09BF            612       ; ***play audio***
09BF            612       ;cjne sound_flag, #0, $
09BF            612       
09BF 121036     612       lcall Wait_Half_Second
09C2 C28E       612       clr TR1 ; Stop Timer 1 ISR from playing previous request
09C4 D2A5       612       setb FLASH_CE
09C6            612       ;setb sound_flag ; sound starts
09C6 C2A6       612       clr SPEAKER ; Turn off speaker
09C8 C2A5       612       clr FLASH_CE ; Enable SPI Flash
09CA 7403       612       mov a, #READ_BYTES
09CC 12040D     612       lcall Send_SPI
09CF            612       ; Set the initial position in memory where to start playing
09CF            612       
09CF 7402       612       mov a, #0x02 ; change initial position
09D1 12040D     612       lcall Send_SPI
09D4 7457       612       mov a, #0x57 ; next memory position
09D6 12040D     612       lcall Send_SPI
09D9 749C       612       mov a, #0x9c ; next memory position
09DB 12040D     612       lcall Send_SPI
09DE 7402       612       mov a, #0x02 ; request first byte to send to DAC
09E0 12040D     612       lcall Send_SPI
09E3            612       
09E3            612       ; How many bytes to play?
09E3 754E00     612       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
09E6 754D1B     612       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
09E9 754C58     612       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
09EC            612       
09EC            612       
09EC D2A6       612       setb SPEAKER ;Turn on speaker
09EE D28E       612       setb TR1 ;Start playback by enabling Timer1
09F0            612       ;clr sound_flag ; sound ends
09F0 020A24     613           ljmp state_8_hop1
09F3            614   
09F3            615       play_9:
09F3            616       ; ***play audio***
09F3            616       ;cjne sound_flag, #0, $
09F3            616       
09F3 121036     616       lcall Wait_Half_Second
09F6 C28E       616       clr TR1 ; Stop Timer 1 ISR from playing previous request
09F8 D2A5       616       setb FLASH_CE
09FA            616       ;setb sound_flag ; sound starts
09FA C2A6       616       clr SPEAKER ; Turn off speaker
09FC C2A5       616       clr FLASH_CE ; Enable SPI Flash
09FE 7403       616       mov a, #READ_BYTES
0A00 12040D     616       lcall Send_SPI
0A03            616       ; Set the initial position in memory where to start playing
0A03            616       
0A03 7402       616       mov a, #0x02 ; change initial position
0A05 12040D     616       lcall Send_SPI
0A08 7469       616       mov a, #0x69 ; next memory position
0A0A 12040D     616       lcall Send_SPI
0A0D 7430       616       mov a, #0x30 ; next memory position
0A0F 12040D     616       lcall Send_SPI
0A12 7402       616       mov a, #0x02 ; request first byte to send to DAC
0A14 12040D     616       lcall Send_SPI
0A17            616       
0A17            616       ; How many bytes to play?
0A17 754E00     616       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0A1A 754D1F     616       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0A1D 754C40     616       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0A20            616       
0A20            616       
0A20 D2A6       616       setb SPEAKER ;Turn on speaker
0A22 D28E       616       setb TR1 ;Start playback by enabling Timer1
0A24            616       ;clr sound_flag ; sound ends
0A24            617   
0A24            618   state_8_hop1:
0A24            619   ; go to state_8_sound
0A24 020C52     620       ljmp state_8_sound
0A27            621   
0A27            622   
0A27            623   state_7_sound:
0A27            624   ; play 10 - 19
0A27            625       ;ljmp PLAYBACK_TEMP
0A27 75F064     626       mov b, #100
0A2A E53B       627       mov a, Temp_oven
0A2C 84         628       div ab
0A2D E5F0       629       mov a, b
0A2F B40A34     630       cjne a, #0x0a, play_11
0A32            631       
0A32            632       ; ***play audio***
0A32            632       ;cjne sound_flag, #0, $
0A32            632       
0A32 121036     632       lcall Wait_Half_Second
0A35 C28E       632       clr TR1 ; Stop Timer 1 ISR from playing previous request
0A37 D2A5       632       setb FLASH_CE
0A39            632       ;setb sound_flag ; sound starts
0A39 C2A6       632       clr SPEAKER ; Turn off speaker
0A3B C2A5       632       clr FLASH_CE ; Enable SPI Flash
0A3D 7403       632       mov a, #READ_BYTES
0A3F 12040D     632       lcall Send_SPI
0A42            632       ; Set the initial position in memory where to start playing
0A42            632       
0A42 7402       632       mov a, #0x02 ; change initial position
0A44 12040D     632       lcall Send_SPI
0A47 7484       632       mov a, #0x84 ; next memory position
0A49 12040D     632       lcall Send_SPI
0A4C 7488       632       mov a, #0x88 ; next memory position
0A4E 12040D     632       lcall Send_SPI
0A51 7402       632       mov a, #0x02 ; request first byte to send to DAC
0A53 12040D     632       lcall Send_SPI
0A56            632       
0A56            632       ; How many bytes to play?
0A56 754E00     632       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0A59 754D17     632       mov w+1, #0x17 ; Load the middle byte of the number of bytes to play
0A5C 754C70     632       mov w+0, #0x70 ; Load the low byte of the number of bytes to play
0A5F            632       
0A5F            632       
0A5F D2A6       632       setb SPEAKER ;Turn on speaker
0A61 D28E       632       setb TR1 ;Start playback by enabling Timer1
0A63            632       ;clr sound_flag ; sound ends
0A63 020C4F     633       ljmp state_8_hop2
0A66            634   
0A66            635       play_11:
0A66 B40B34     636           cjne a, #0x0b, play_12
0A69            637       ; ***play audio***
0A69            637       ;cjne sound_flag, #0, $
0A69            637       
0A69 121036     637       lcall Wait_Half_Second
0A6C C28E       637       clr TR1 ; Stop Timer 1 ISR from playing previous request
0A6E D2A5       637       setb FLASH_CE
0A70            637       ;setb sound_flag ; sound starts
0A70 C2A6       637       clr SPEAKER ; Turn off speaker
0A72 C2A5       637       clr FLASH_CE ; Enable SPI Flash
0A74 7403       637       mov a, #READ_BYTES
0A76 12040D     637       lcall Send_SPI
0A79            637       ; Set the initial position in memory where to start playing
0A79            637       
0A79 7402       637       mov a, #0x02 ; change initial position
0A7B 12040D     637       lcall Send_SPI
0A7E 749B       637       mov a, #0x9b ; next memory position
0A80 12040D     637       lcall Send_SPI
0A83 74F8       637       mov a, #0xf8 ; next memory position
0A85 12040D     637       lcall Send_SPI
0A88 7402       637       mov a, #0x02 ; request first byte to send to DAC
0A8A 12040D     637       lcall Send_SPI
0A8D            637       
0A8D            637       ; How many bytes to play?
0A8D 754E00     637       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0A90 754D1F     637       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0A93 754C40     637       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0A96            637       
0A96            637       
0A96 D2A6       637       setb SPEAKER ;Turn on speaker
0A98 D28E       637       setb TR1 ;Start playback by enabling Timer1
0A9A            637       ;clr sound_flag ; sound ends
0A9A 020C4F     638           ljmp state_8_hop2
0A9D            639   
0A9D            640       play_12:
0A9D B40C34     641           cjne a, #0x0c, play_13
0AA0            642       ; ***play audio***
0AA0            642       ;cjne sound_flag, #0, $
0AA0            642       
0AA0 121036     642       lcall Wait_Half_Second
0AA3 C28E       642       clr TR1 ; Stop Timer 1 ISR from playing previous request
0AA5 D2A5       642       setb FLASH_CE
0AA7            642       ;setb sound_flag ; sound starts
0AA7 C2A6       642       clr SPEAKER ; Turn off speaker
0AA9 C2A5       642       clr FLASH_CE ; Enable SPI Flash
0AAB 7403       642       mov a, #READ_BYTES
0AAD 12040D     642       lcall Send_SPI
0AB0            642       ; Set the initial position in memory where to start playing
0AB0            642       
0AB0 7402       642       mov a, #0x02 ; change initial position
0AB2 12040D     642       lcall Send_SPI
0AB5 74B7       642       mov a, #0xb7 ; next memory position
0AB7 12040D     642       lcall Send_SPI
0ABA 7450       642       mov a, #0x50 ; next memory position
0ABC 12040D     642       lcall Send_SPI
0ABF 7402       642       mov a, #0x02 ; request first byte to send to DAC
0AC1 12040D     642       lcall Send_SPI
0AC4            642       
0AC4            642       ; How many bytes to play?
0AC4 754E00     642       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0AC7 754D1F     642       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0ACA 754C40     642       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0ACD            642       
0ACD            642       
0ACD D2A6       642       setb SPEAKER ;Turn on speaker
0ACF D28E       642       setb TR1 ;Start playback by enabling Timer1
0AD1            642       ;clr sound_flag ; sound ends
0AD1 020C4F     643           ljmp state_8_hop2
0AD4            644   
0AD4            645       play_13:
0AD4 B40D34     646           cjne a, #0x0d, play_14
0AD7            647       ; ***play audio***
0AD7            647       ;cjne sound_flag, #0, $
0AD7            647       
0AD7 121036     647       lcall Wait_Half_Second
0ADA C28E       647       clr TR1 ; Stop Timer 1 ISR from playing previous request
0ADC D2A5       647       setb FLASH_CE
0ADE            647       ;setb sound_flag ; sound starts
0ADE C2A6       647       clr SPEAKER ; Turn off speaker
0AE0 C2A5       647       clr FLASH_CE ; Enable SPI Flash
0AE2 7403       647       mov a, #READ_BYTES
0AE4 12040D     647       lcall Send_SPI
0AE7            647       ; Set the initial position in memory where to start playing
0AE7            647       
0AE7 7402       647       mov a, #0x02 ; change initial position
0AE9 12040D     647       lcall Send_SPI
0AEC 74CE       647       mov a, #0xce ; next memory position
0AEE 12040D     647       lcall Send_SPI
0AF1 74C0       647       mov a, #0xc0 ; next memory position
0AF3 12040D     647       lcall Send_SPI
0AF6 7402       647       mov a, #0x02 ; request first byte to send to DAC
0AF8 12040D     647       lcall Send_SPI
0AFB            647       
0AFB            647       ; How many bytes to play?
0AFB 754E00     647       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0AFE 754D2E     647       mov w+1, #0x2e ; Load the middle byte of the number of bytes to play
0B01 754CE0     647       mov w+0, #0xe0 ; Load the low byte of the number of bytes to play
0B04            647       
0B04            647       
0B04 D2A6       647       setb SPEAKER ;Turn on speaker
0B06 D28E       647       setb TR1 ;Start playback by enabling Timer1
0B08            647       ;clr sound_flag ; sound ends
0B08 020C4F     648           ljmp state_8_hop2
0B0B            649   
0B0B            650       play_14:
0B0B B40E34     651           cjne a, #0x0e, play_15
0B0E            652       ; ***play audio***
0B0E            652       ;cjne sound_flag, #0, $
0B0E            652       
0B0E 121036     652       lcall Wait_Half_Second
0B11 C28E       652       clr TR1 ; Stop Timer 1 ISR from playing previous request
0B13 D2A5       652       setb FLASH_CE
0B15            652       ;setb sound_flag ; sound starts
0B15 C2A6       652       clr SPEAKER ; Turn off speaker
0B17 C2A5       652       clr FLASH_CE ; Enable SPI Flash
0B19 7403       652       mov a, #READ_BYTES
0B1B 12040D     652       lcall Send_SPI
0B1E            652       ; Set the initial position in memory where to start playing
0B1E            652       
0B1E 7402       652       mov a, #0x02 ; change initial position
0B20 12040D     652       lcall Send_SPI
0B23 74F5       652       mov a, #0xf5 ; next memory position
0B25 12040D     652       lcall Send_SPI
0B28 74D0       652       mov a, #0xd0 ; next memory position
0B2A 12040D     652       lcall Send_SPI
0B2D 7402       652       mov a, #0x02 ; request first byte to send to DAC
0B2F 12040D     652       lcall Send_SPI
0B32            652       
0B32            652       ; How many bytes to play?
0B32 754E00     652       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0B35 754D36     652       mov w+1, #0x36 ; Load the middle byte of the number of bytes to play
0B38 754CB0     652       mov w+0, #0xb0 ; Load the low byte of the number of bytes to play
0B3B            652       
0B3B            652       
0B3B D2A6       652       setb SPEAKER ;Turn on speaker
0B3D D28E       652       setb TR1 ;Start playback by enabling Timer1
0B3F            652       ;clr sound_flag ; sound ends
0B3F 020C4F     653           ljmp state_8_hop2
0B42            654   
0B42            655       play_15:
0B42 B40F34     656           cjne a, #0x0f, play_16
0B45            657       ; ***play audio***
0B45            657       ;cjne sound_flag, #0, $
0B45            657       
0B45 121036     657       lcall Wait_Half_Second
0B48 C28E       657       clr TR1 ; Stop Timer 1 ISR from playing previous request
0B4A D2A5       657       setb FLASH_CE
0B4C            657       ;setb sound_flag ; sound starts
0B4C C2A6       657       clr SPEAKER ; Turn off speaker
0B4E C2A5       657       clr FLASH_CE ; Enable SPI Flash
0B50 7403       657       mov a, #READ_BYTES
0B52 12040D     657       lcall Send_SPI
0B55            657       ; Set the initial position in memory where to start playing
0B55            657       
0B55 7403       657       mov a, #0x03 ; change initial position
0B57 12040D     657       lcall Send_SPI
0B5A 7428       657       mov a, #0x28 ; next memory position
0B5C 12040D     657       lcall Send_SPI
0B5F 7498       657       mov a, #0x98 ; next memory position
0B61 12040D     657       lcall Send_SPI
0B64 7403       657       mov a, #0x03 ; request first byte to send to DAC
0B66 12040D     657       lcall Send_SPI
0B69            657       
0B69            657       ; How many bytes to play?
0B69 754E00     657       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0B6C 754D23     657       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
0B6F 754C28     657       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0B72            657       
0B72            657       
0B72 D2A6       657       setb SPEAKER ;Turn on speaker
0B74 D28E       657       setb TR1 ;Start playback by enabling Timer1
0B76            657       ;clr sound_flag ; sound ends
0B76 020C4F     658           ljmp state_8_hop2
0B79            659   
0B79            660       play_16:
0B79 B41034     661           cjne a, #0x10, play_17
0B7C            662       ; ***play audio***
0B7C            662       ;cjne sound_flag, #0, $
0B7C            662       
0B7C 121036     662       lcall Wait_Half_Second
0B7F C28E       662       clr TR1 ; Stop Timer 1 ISR from playing previous request
0B81 D2A5       662       setb FLASH_CE
0B83            662       ;setb sound_flag ; sound starts
0B83 C2A6       662       clr SPEAKER ; Turn off speaker
0B85 C2A5       662       clr FLASH_CE ; Enable SPI Flash
0B87 7403       662       mov a, #READ_BYTES
0B89 12040D     662       lcall Send_SPI
0B8C            662       ; Set the initial position in memory where to start playing
0B8C            662       
0B8C 7403       662       mov a, #0x03 ; change initial position
0B8E 12040D     662       lcall Send_SPI
0B91 7447       662       mov a, #0x47 ; next memory position
0B93 12040D     662       lcall Send_SPI
0B96 74D8       662       mov a, #0xd8 ; next memory position
0B98 12040D     662       lcall Send_SPI
0B9B 7403       662       mov a, #0x03 ; request first byte to send to DAC
0B9D 12040D     662       lcall Send_SPI
0BA0            662       
0BA0            662       ; How many bytes to play?
0BA0 754E00     662       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0BA3 754D32     662       mov w+1, #0x32 ; Load the middle byte of the number of bytes to play
0BA6 754CC8     662       mov w+0, #0xc8 ; Load the low byte of the number of bytes to play
0BA9            662       
0BA9            662       
0BA9 D2A6       662       setb SPEAKER ;Turn on speaker
0BAB D28E       662       setb TR1 ;Start playback by enabling Timer1
0BAD            662       ;clr sound_flag ; sound ends
0BAD 020C4F     663           ljmp state_8_hop2
0BB0            664   
0BB0            665       play_17:
0BB0 B41134     666           cjne a, #0x11, play_18
0BB3            667       ; ***play audio***
0BB3            667       ;cjne sound_flag, #0, $
0BB3            667       
0BB3 121036     667       lcall Wait_Half_Second
0BB6 C28E       667       clr TR1 ; Stop Timer 1 ISR from playing previous request
0BB8 D2A5       667       setb FLASH_CE
0BBA            667       ;setb sound_flag ; sound starts
0BBA C2A6       667       clr SPEAKER ; Turn off speaker
0BBC C2A5       667       clr FLASH_CE ; Enable SPI Flash
0BBE 7403       667       mov a, #READ_BYTES
0BC0 12040D     667       lcall Send_SPI
0BC3            667       ; Set the initial position in memory where to start playing
0BC3            667       
0BC3 7403       667       mov a, #0x03 ; change initial position
0BC5 12040D     667       lcall Send_SPI
0BC8 7476       667       mov a, #0x76 ; next memory position
0BCA 12040D     667       lcall Send_SPI
0BCD 74B8       667       mov a, #0xb8 ; next memory position
0BCF 12040D     667       lcall Send_SPI
0BD2 7403       667       mov a, #0x03 ; request first byte to send to DAC
0BD4 12040D     667       lcall Send_SPI
0BD7            667       
0BD7            667       ; How many bytes to play?
0BD7 754E00     667       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0BDA 754D2E     667       mov w+1, #0x2e ; Load the middle byte of the number of bytes to play
0BDD 754C20     667       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
0BE0            667       
0BE0            667       
0BE0 D2A6       667       setb SPEAKER ;Turn on speaker
0BE2 D28E       667       setb TR1 ;Start playback by enabling Timer1
0BE4            667       ;clr sound_flag ; sound ends
0BE4 020C4F     668           ljmp state_8_hop2
0BE7            669   
0BE7            670       play_18:
0BE7 B41234     671           cjne a, #0x12, play_19
0BEA            672       ; ***play audio***
0BEA            672       ;cjne sound_flag, #0, $
0BEA            672       
0BEA 121036     672       lcall Wait_Half_Second
0BED C28E       672       clr TR1 ; Stop Timer 1 ISR from playing previous request
0BEF D2A5       672       setb FLASH_CE
0BF1            672       ;setb sound_flag ; sound starts
0BF1 C2A6       672       clr SPEAKER ; Turn off speaker
0BF3 C2A5       672       clr FLASH_CE ; Enable SPI Flash
0BF5 7403       672       mov a, #READ_BYTES
0BF7 12040D     672       lcall Send_SPI
0BFA            672       ; Set the initial position in memory where to start playing
0BFA            672       
0BFA 7403       672       mov a, #0x03 ; change initial position
0BFC 12040D     672       lcall Send_SPI
0BFF 74A1       672       mov a, #0xa1 ; next memory position
0C01 12040D     672       lcall Send_SPI
0C04 74B0       672       mov a, #0xb0 ; next memory position
0C06 12040D     672       lcall Send_SPI
0C09 7403       672       mov a, #0x03 ; request first byte to send to DAC
0C0B 12040D     672       lcall Send_SPI
0C0E            672       
0C0E            672       ; How many bytes to play?
0C0E 754E00     672       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0C11 754D27     672       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0C14 754C10     672       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0C17            672       
0C17            672       
0C17 D2A6       672       setb SPEAKER ;Turn on speaker
0C19 D28E       672       setb TR1 ;Start playback by enabling Timer1
0C1B            672       ;clr sound_flag ; sound ends
0C1B 020C4F     673           ljmp state_8_hop2
0C1E            674   
0C1E            675       play_19:
0C1E            676       ; ***play audio***
0C1E            676       ;cjne sound_flag, #0, $
0C1E            676       
0C1E 121036     676       lcall Wait_Half_Second
0C21 C28E       676       clr TR1 ; Stop Timer 1 ISR from playing previous request
0C23 D2A5       676       setb FLASH_CE
0C25            676       ;setb sound_flag ; sound starts
0C25 C2A6       676       clr SPEAKER ; Turn off speaker
0C27 C2A5       676       clr FLASH_CE ; Enable SPI Flash
0C29 7403       676       mov a, #READ_BYTES
0C2B 12040D     676       lcall Send_SPI
0C2E            676       ; Set the initial position in memory where to start playing
0C2E            676       
0C2E 7403       676       mov a, #0x03 ; change initial position
0C30 12040D     676       lcall Send_SPI
0C33 74C8       676       mov a, #0xc8 ; next memory position
0C35 12040D     676       lcall Send_SPI
0C38 74C0       676       mov a, #0xc0 ; next memory position
0C3A 12040D     676       lcall Send_SPI
0C3D 7403       676       mov a, #0x03 ; request first byte to send to DAC
0C3F 12040D     676       lcall Send_SPI
0C42            676       
0C42            676       ; How many bytes to play?
0C42 754E00     676       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0C45 754D27     676       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0C48 754C10     676       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0C4B            676       
0C4B            676       
0C4B D2A6       676       setb SPEAKER ;Turn on speaker
0C4D D28E       676       setb TR1 ;Start playback by enabling Timer1
0C4F            676       ;clr sound_flag ; sound ends
0C4F            677   
0C4F            678       state_8_hop2:
0C4F            679       ; go to state_8_sound
0C4F 020C52     680           ljmp state_8_sound
0C52            681   
0C52            682   state_8_sound:
0C52            683   ; go to state_0_sound
0C52 02052C     684       ljmp Sound_ret
0C55            685   
0C55            686   
0C55            687   
0C55            688   
0C55            689   INI_PLAYBACK_TEMP:
0C55            690       ; ****INITIALIZATION****
0C55            691       ; Configure SPI pins and turn off speaker
0C55            692            ;anl P2M0, #0b_1100_1110
0C55 43CE90     693       orl P2M0, #0b_1001_0000
0C58            694       ;orl P2M0, #0b_0011_0001
0C58            695            ;orl P2M1, #0b_0011_0001
0C58 43CF90     696       orl P2M1, #0b_1001_0000
0C5B D2A1       697            setb MY_MISO_SOUND  ; Configured as input
0C5D D2A5       698            setb FLASH_CE ; CS=1 for SPI flash memory
0C5F C2A0       699            clr MY_SCLK_SOUND   ; Rest state of SCLK=0
0C61 C2A6       700            clr SPEAKER   ; Turn off speaker.
0C63            701            
0C63            702            ; Configure timer 1
0C63 53890F     703            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
0C66 438910     704            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
0C69 758DFC     705            mov TH1, #high(TIMER1_RELOAD)
0C6C 758B8C     706            mov TL1, #low(TIMER1_RELOAD)
0C6F            707            ; Set autoreload value
0C6F 75F5FC     708            mov RH1, #high(TIMER1_RELOAD)
0C72 75F38C     709            mov RL1, #low(TIMER1_RELOAD)
0C75            710   
0C75            711            ;Enable the timer and interrupts
0C75 D2AB       712       setb ET1  ; Enable timer 1 interrupt
0C77 D28E       713            setb TR1 ; Timer 1 is only enabled to play stored sound
0C79            714   
0C79            715            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
0C79 75A5A0     716            mov DADI, #0b_1010_0000 ; ACON=1
0C7C 75A43A     717            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0C7F 75AD80     718            mov DADH, #0x80 ; Middle of scale
0C82 75AC00     719            mov DADL, #0
0C85 43A440     720            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
0C88            721       check_DAC_init:
0C88 E5A4       722            mov a, DADC
0C8A 20E6FB     723            jb acc.6, check_DAC_init ; Wait for DAC to finish
0C8D            724            
0C8D 22         725   ret
0C8E            726   
0C8E            727       
0C8E            728   ;-------------------------------------------------------------------------------------------------------------------------------
0C8E            729   ;***LCD FXNS
0C8E            730   
                731   Display_lower_BCD mac
                732       push ar0
                733       mov r0, %0
                734       lcall ?Display_lower_BCD
                735       pop ar0
                736   endmac
0C8E            737   
0C8E            738   ?Display_lower_BCD:
0C8E C0E0       739       push acc
0C90            740       ; write least significant digit
0C90 E8         741       mov a, r0
0C91 540F       742       anl a, #0fh
0C93 4430       743       orl a, #30h
0C95 12007E     744       lcall ?WriteData
0C98 D0E0       745       pop acc
0C9A 22         746   ret
0C9B            747   
0C9B            748   
0C9B            749   SendToLCD:
0C9B 75F064     750       mov b, #100
0C9E 84         751       div ab
0C9F 4430       752       orl a, #0x30h ; Convert hundreds to ASCII
0CA1 12007E     753       lcall ?WriteData ; Send to LCD
0CA4 E5F0       754       mov a, b    ; Remainder is in register b
0CA6 75F00A     755       mov b, #10
0CA9 84         756       div ab
0CAA 4430       757       orl a, #0x30h ; Convert tens to ASCII
0CAC 12007E     758       lcall ?WriteData; Send to LCD
0CAF E5F0       759       mov a, b
0CB1 4430       760       orl a, #0x30h ; Convert units to ASCII
0CB3 12007E     761       lcall ?WriteData; Send to LCD
0CB6 22         762   ret
0CB7            763   
0CB7            764   Initialize_State_Display:
0CB7            765   
0CB7            766       ;***clear the screen and set new display***
0CB7 7401       767            mov a, #0x01
0CB9 120083     767            lcall ?WriteCommand
0CBC C002       768            push AR2
0CBE 7A02       768            mov R2, #2
0CC0 120039     768            lcall ?Wait_Milli_Seconds
0CC3 D002       768            pop AR2
0CC5            769       
0CC5 C0E0       770            push acc
0CC7 7401       770            mov a, #1
0CC9 14         770            dec a
0CCA 1200BF     770            lcall ?Set_Cursor_1 ; Select column and row
0CCD D0E0       770            pop acc
0CCF C083       771            push dph
0CD1 C082       771            push dpl
0CD3 C0E0       771            push acc
0CD5 90037D     771            mov dptr, #time
0CD8 1200B2     771            lcall ?Send_Constant_String
0CDB D0E0       771            pop acc
0CDD D082       771            pop dpl
0CDF D083       771            pop dph
0CE1            772            
0CE1 C0E0       773            push acc
0CE3 7406       773            mov a, #6
0CE5 14         773            dec a
0CE6 1200BF     773            lcall ?Set_Cursor_1 ; Select column and row
0CE9 D0E0       773            pop acc
0CEB C083       774            push dph
0CED C082       774            push dpl
0CEF C0E0       774            push acc
0CF1 900382     774            mov dptr, #colon
0CF4 1200B2     774            lcall ?Send_Constant_String
0CF7 D0E0       774            pop acc
0CF9 D082       774            pop dpl
0CFB D083       774            pop dph
0CFD            775      
0CFD C0E0       776            push acc
0CFF 740A       776            mov a, #10
0D01 14         776            dec a
0D02 1200BF     776            lcall ?Set_Cursor_1 ; Select column and row
0D05 D0E0       776            pop acc
0D07 C083       777            push dph
0D09 C082       777            push dpl
0D0B C0E0       777            push acc
0D0D 900384     777            mov dptr, #temp
0D10 1200B2     777            lcall ?Send_Constant_String
0D13 D0E0       777            pop acc
0D15 D082       777            pop dpl
0D17 D083       777            pop dph
0D19            778       
0D19 C0E0       779            push acc
0D1B 7401       779            mov a, #1
0D1D 14         779            dec a
0D1E 1200BD     779            lcall ?Set_Cursor_2 ; Select column and row
0D21 D0E0       779            pop acc
0D23 C083       780            push dph
0D25 C082       780            push dpl
0D27 C0E0       780            push acc
0D29 900376     780            mov dptr, #state
0D2C 1200B2     780            lcall ?Send_Constant_String
0D2F D0E0       780            pop acc
0D31 D082       780            pop dpl
0D33 D083       780            pop dph
0D35 22         781   ret
0D36            782   
0D36            783   Update_Display:
0D36 C0E0       784            push acc
0D38 7405       784            mov a, #5
0D3A 14         784            dec a
0D3B 1200BF     784            lcall ?Set_Cursor_1 ; Select column and row
0D3E D0E0       784            pop acc
0D40 C000       785       push ar0
0D42 A839       785       mov r0, Run_time_minutes
0D44 120C8E     785       lcall ?Display_lower_BCD
0D47 D000       785       pop ar0
0D49 C0E0       786            push acc
0D4B 7407       786            mov a, #7
0D4D 14         786            dec a
0D4E 1200BF     786            lcall ?Set_Cursor_1 ; Select column and row
0D51 D0E0       786            pop acc
0D53 C000       787            push ar0
0D55 A838       787            mov r0, Run_time_seconds
0D57 1200C4     787            lcall ?Display_BCD
0D5A D000       787            pop ar0
0D5C            788       ;Set_Cursor(1,14)
0D5C            789       ;mov a, Temp_oven
0D5C            790       ;SendToLCD(Temp_oven)
0D5C 22         791   ret
0D5D            792   
0D5D            793   State0_display:
0D5D C0E0       794            push acc
0D5F 7401       794            mov a, #1
0D61 14         794            dec a
0D62 1200BF     794            lcall ?Set_Cursor_1 ; Select column and row
0D65 D0E0       794            pop acc
0D67 C083       795            push dph
0D69 C082       795            push dpl
0D6B C0E0       795            push acc
0D6D 900360     795            mov dptr, #STemp
0D70 1200B2     795            lcall ?Send_Constant_String
0D73 D0E0       795            pop acc
0D75 D082       795            pop dpl
0D77 D083       795            pop dph
0D79 C0E0       796            push acc
0D7B 7406       796            mov a, #6
0D7D 14         796            dec a
0D7E 1200BF     796            lcall ?Set_Cursor_1 ; Select column and row
0D81 D0E0       796            pop acc
0D83 E534       797       mov a, Temp_soak
0D85 120C9B     798       lcall SendToLCD
0D88            799       
0D88 C0E0       800            push acc
0D8A 740A       800            mov a, #10
0D8C 14         800            dec a
0D8D 1200BF     800            lcall ?Set_Cursor_1 ; Select column and row
0D90 D0E0       800            pop acc
0D92 C083       801            push dph
0D94 C082       801            push dpl
0D96 C0E0       801            push acc
0D98 900366     801            mov dptr, #STime
0D9B 1200B2     801            lcall ?Send_Constant_String
0D9E D0E0       801            pop acc
0DA0 D082       801            pop dpl
0DA2 D083       801            pop dph
0DA4 C0E0       802            push acc
0DA6 740E       802            mov a, #14
0DA8 14         802            dec a
0DA9 1200BF     802            lcall ?Set_Cursor_1 ; Select column and row
0DAC D0E0       802            pop acc
0DAE E535       803       mov a, Time_soak
0DB0 120C9B     804            lcall SendToLCD
0DB3            805       ;Display_BCD(Time_soak)
0DB3            806   
0DB3            807       ;Displays Reflow Temp and Time
0DB3 C0E0       808            push acc
0DB5 7401       808            mov a, #1
0DB7 14         808            dec a
0DB8 1200BD     808            lcall ?Set_Cursor_2 ; Select column and row
0DBB D0E0       808            pop acc
0DBD C083       809            push dph
0DBF C082       809            push dpl
0DC1 C0E0       809            push acc
0DC3 90036B     809            mov dptr, #RTemp
0DC6 1200B2     809            lcall ?Send_Constant_String
0DC9 D0E0       809            pop acc
0DCB D082       809            pop dpl
0DCD D083       809            pop dph
0DCF C0E0       810            push acc
0DD1 7406       810            mov a, #6
0DD3 14         810            dec a
0DD4 1200BD     810            lcall ?Set_Cursor_2 ; Select column and row
0DD7 D0E0       810            pop acc
0DD9 E536       811       mov a, Temp_refl
0DDB 120C9B     812       lcall SendToLCD
0DDE            813       
0DDE C0E0       814            push acc
0DE0 740A       814            mov a, #10
0DE2 14         814            dec a
0DE3 1200BD     814            lcall ?Set_Cursor_2 ; Select column and row
0DE6 D0E0       814            pop acc
0DE8 C083       815            push dph
0DEA C082       815            push dpl
0DEC C0E0       815            push acc
0DEE 900371     815            mov dptr, #RTime
0DF1 1200B2     815            lcall ?Send_Constant_String
0DF4 D0E0       815            pop acc
0DF6 D082       815            pop dpl
0DF8 D083       815            pop dph
0DFA C0E0       816            push acc
0DFC 740E       816            mov a, #14
0DFE 14         816            dec a
0DFF 1200BD     816            lcall ?Set_Cursor_2 ; Select column and row
0E02 D0E0       816            pop acc
0E04 E537       817       mov a, Time_refl
0E06 120C9B     818            lcall SendToLCD
0E09 22         819   ret
0E0A            820   
0E0A            821   Display_3_digit_BCD:
0E0A C0E0       822            push acc
0E0C 740E       822            mov a, #14
0E0E 14         822            dec a
0E0F 1200BF     822            lcall ?Set_Cursor_1 ; Select column and row
0E12 D0E0       822            pop acc
0E14 C000       823       push ar0
0E16 A846       823       mov r0, bcd+1
0E18 120C8E     823       lcall ?Display_lower_BCD
0E1B D000       823       pop ar0
0E1D C000       824            push ar0
0E1F A845       824            mov r0, bcd+0
0E21 1200C4     824            lcall ?Display_BCD
0E24 D000       824            pop ar0
0E26 22         825   ret
0E27            826   
0E27            827   Animation:
0E27 740F       828            mov a, #0x0f
0E29 120083     828            lcall ?WriteCommand ;display cursor
0E2C            829   
0E2C            830       ;name ; Move cursor to line 1 column 1
0E2C 7480       831            mov a, #0x80
0E2E 120083     831            lcall ?WriteCommand
0E31 7457       832            mov a, #'W'
0E33 12007E     832            lcall ?WriteData
0E36 C002       833            push AR2
0E38 7AFA       833            mov R2, #250
0E3A 120039     833            lcall ?Wait_Milli_Seconds
0E3D D002       833            pop AR2
0E3F 7465       834            mov a, #'e'
0E41 12007E     834            lcall ?WriteData
0E44 C002       835            push AR2
0E46 7AFA       835            mov R2, #250
0E48 120039     835            lcall ?Wait_Milli_Seconds
0E4B D002       835            pop AR2
0E4D 746C       836            mov a, #'l'
0E4F 12007E     836            lcall ?WriteData
0E52 C002       837            push AR2
0E54 7AFA       837            mov R2, #250
0E56 120039     837            lcall ?Wait_Milli_Seconds
0E59 D002       837            pop AR2
0E5B 7463       838            mov a, #'c'
0E5D 12007E     838            lcall ?WriteData
0E60 C002       839            push AR2
0E62 7AFA       839            mov R2, #250
0E64 120039     839            lcall ?Wait_Milli_Seconds
0E67 D002       839            pop AR2
0E69 746F       840            mov a, #'o'
0E6B 12007E     840            lcall ?WriteData
0E6E C002       841            push AR2
0E70 7AFA       841            mov R2, #250
0E72 120039     841            lcall ?Wait_Milli_Seconds
0E75 D002       841            pop AR2
0E77 746D       842            mov a, #'m'
0E79 12007E     842            lcall ?WriteData
0E7C C002       843            push AR2
0E7E 7AFA       843            mov R2, #250
0E80 120039     843            lcall ?Wait_Milli_Seconds
0E83 D002       843            pop AR2
0E85 7465       844            mov a, #'e'
0E87 12007E     844            lcall ?WriteData
0E8A C002       845            push AR2
0E8C 7AFA       845            mov R2, #250
0E8E 120039     845            lcall ?Wait_Milli_Seconds
0E91 D002       845            pop AR2
0E93 7421       846            mov a, #'!'
0E95 12007E     846            lcall ?WriteData
0E98 C002       847            push AR2
0E9A 7AFA       847            mov R2, #250
0E9C 120039     847            lcall ?Wait_Milli_Seconds
0E9F D002       847            pop AR2
0EA1 7420       848            mov a, #' '
0EA3 12007E     848            lcall ?WriteData
0EA6 C002       849            push AR2
0EA8 7AFA       849            mov R2, #250
0EAA 120039     849            lcall ?Wait_Milli_Seconds
0EAD D002       849            pop AR2
0EAF 7460       850            mov a, #96
0EB1 12007E     850            lcall ?WriteData
0EB4 C002       851            push AR2
0EB6 7AFA       851            mov R2, #250
0EB8 120039     851            lcall ?Wait_Milli_Seconds
0EBB D002       851            pop AR2
0EBD 74EF       852            mov a, #239
0EBF 12007E     852            lcall ?WriteData
0EC2 C002       853            push AR2
0EC4 7AFA       853            mov R2, #250
0EC6 120039     853            lcall ?Wait_Milli_Seconds
0EC9 D002       853            pop AR2
0ECB 742F       854            mov a, #47
0ECD 12007E     854            lcall ?WriteData
0ED0 121011     855       lcall Wait_One_Second
0ED3 121011     856       lcall Wait_One_Second
0ED6 740C       857            mov a, #0x0c
0ED8 120083     857            lcall ?WriteCommand ;clear cursor
0EDB 22         858   ret
0EDC            859   
0EDC            860   ;The following functions store and restore the values--------------------------------------------------------------------------
                861   loadbyte mac
                862       mov a, %0
                863       movx @dptr, a
                864       inc dptr
                865   endmac
0EDC            866   
0EDC            867   Save_Configuration:
0EDC C0A8       868       push IE ; Save the current state of bit EA in the stack
0EDE C2AF       869       clr EA ; Disable interrupts
0EE0 75D108     870       mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
0EE3 907F80     871       mov dptr, #0x7f80 ; Last page of flash memory
0EE6            872       ; Save variables
0EE6 E534       873       mov a, temp_soak
0EE8 F0         873       movx @dptr, a
0EE9 A3         873       inc dptr ; @0x7f80
0EEA E535       874       mov a, time_soak
0EEC F0         874       movx @dptr, a
0EED A3         874       inc dptr ; @0x7f81
0EEE E536       875       mov a, temp_refl
0EF0 F0         875       movx @dptr, a
0EF1 A3         875       inc dptr ; @0x7f82
0EF2 E537       876       mov a, time_refl
0EF4 F0         876       movx @dptr, a
0EF5 A3         876       inc dptr ; @0x7f83
0EF6 7455       877       mov a, #0x55
0EF8 F0         877       movx @dptr, a
0EF9 A3         877       inc dptr ; First key value @0x7f84
0EFA 74AA       878       mov a, #0xAA
0EFC F0         878       movx @dptr, a
0EFD A3         878       inc dptr ; Second key value @0x7f85
0EFE 75D100     879       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
0F01 43D240     880       orl EECON, #0b01000000 ; Enable auto-erase on next write sequence 
0F04 75D150     881       mov FCON, #0x50 ; Write trigger first byte
0F07 75D1A0     882       mov FCON, #0xA0 ; Write trigger second byte
0F0A            883       ; CPU idles until writing of flash completes.
0F0A 75D100     884       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
0F0D 53D2BF     885       anl EECON, #0b10111111 ; Disable auto-erase
0F10 D0A8       886       pop IE ; Restore the state of bit EA from the stack
0F12 22         887   ret
0F13            888   
                889   getbyte mac
                890       clr a
                891       movc a, @a+dptr
                892       mov %0, a
                893       inc dptr
                894   endmac
0F13            895   
0F13            896   Load_Configuration:
0F13 907F84     897       mov dptr, #0x7f84 ; First key value location.
0F16 E4         898       clr a
0F17 93         898       movc a, @a+dptr
0F18 F8         898       mov R0, a
0F19 A3         898       inc dptr ; 0x7f84 should contain 0x55
0F1A B8551F     899       cjne R0, #0x55, Load_Defaults
0F1D E4         900       clr a
0F1E 93         900       movc a, @a+dptr
0F1F F8         900       mov R0, a
0F20 A3         900       inc dptr ; 0x7f85 should contain 0xAA
0F21 B8AA18     901       cjne R0, #0xAA, Load_Defaults
0F24            902   ; Keys are good.  Get stored values.
0F24 907F80     903       mov dptr, #0x7f80
0F27 E4         904       clr a
0F28 93         904       movc a, @a+dptr
0F29 F534       904       mov Temp_soak, a
0F2B A3         904       inc dptr ; 0x7f80
0F2C E4         905       clr a
0F2D 93         905       movc a, @a+dptr
0F2E F535       905       mov Time_soak, a
0F30 A3         905       inc dptr ; 0x7f81
0F31 E4         906       clr a
0F32 93         906       movc a, @a+dptr
0F33 F536       906       mov Temp_refl, a
0F35 A3         906       inc dptr ; 0x7f82
0F36 E4         907       clr a
0F37 93         907       movc a, @a+dptr
0F38 F537       907       mov Time_refl, a
0F3A A3         907       inc dptr ; 0x7f83
0F3B 22         908   ret
0F3C            909   
0F3C            910   Load_Defaults:
0F3C 753482     911       mov Temp_soak, #130 ; Soak Tmp Range is 130-170
0F3F 75353C     912       mov Time_soak, #0x3C ; Range 60-90 seconds
0F42 7536DC     913       mov Temp_refl, #220 ; Range 220-240
0F45 75371E     914       mov Time_refl, #0x1E ; Range 30-45 seconds
0F48 22         915       ret 
0F49            916   ;-------------------------------------------------------------------------------------------------------------------------------
0F49            917   ;off state
0F49            918   
0F49            919   OFF_STATE:
0F49            920       ;**CLEAR SCREEN**
0F49 7401       921            mov a, #0x01
0F4B 120083     921            lcall ?WriteCommand
0F4E            922       ;OFF_STATE1:
0F4E            923       
0F4E 20C5FD     924       jb POWER_BUTTON, $ ; loop while the button is not pressed
0F51 C002       925            push AR2
0F53 7A32       925            mov R2, #50
0F55 120039     925            lcall ?Wait_Milli_Seconds
0F58 D002       925            pop AR2 ; debounce time
0F5A 20C5EC     926            jb POWER_BUTTON, OFF_STATE ; it was a bounce, try again
0F5D 30C5FD     927            jnb POWER_BUTTON, $ ; loop while the button is pressed
0F60 0210FA     928       ljmp main
0F63 22         929   ret
0F64            930   ;-------------------------------------------------------------------------------------------------------------------------------
0F64            931   
0F64            932   ;***CHECK TEMPERATURE BY READING VOLTAGE AND CONVERTING
0F64            933   Check_Temp:
0F64            934       
0F64            935       ;jnb one_seconds_flag, Check_Temp_done
0F64            936       ;clr one_seconds_flag
0F64            937       
0F64 C297       938       clr CE_ADC
0F66 7801       939            mov R0, #00000001B ; Start bit:1
0F68 1203F4     940            lcall DO_SPI_G
0F6B 7880       941            mov R0, #10000000B ; Single ended, read channel 0
0F6D 1203F4     942            lcall DO_SPI_G
0F70 E9         943            mov a, R1          ; R1 contains bits 8 and 9
0F71 5403       944            anl a, #00000011B  ; We need only the two least significant bits
0F73 F54B       945            mov Result+1, a    ; Save result high.
0F75 7855       946            mov R0, #55H ; It doesn't matter what we transmit...
0F77 1203F4     947            lcall DO_SPI_G
0F7A 894A       948            mov Result+0, R1     ; R1 contains bits 0 to 7.  Save result low.
0F7C D297       949            setb CE_ADC
0F7E            950   
0F7E C002       951            push AR2
0F80 7A0A       951            mov R2, #10
0F82 120039     951            lcall ?Wait_Milli_Seconds
0F85 D002       951            pop AR2
0F87            952       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
0F87 AE4A       953            mov R6, Result+0
0F89 AF4B       954            mov R7, Result+1
0F8B 22         955   ret
0F8C            956   
0F8C            957       
0F8C            958       
0F8C            959   ;***CALCULATES THE TEMPERATURE
0F8C            960   Average_Temp:
0F8C 753D00     961            mov x+0, #low (0 % 0x10000) 
0F8F 753E00     961            mov x+1, #high(0 % 0x10000) 
0F92 753F00     961            mov x+2, #low (0 / 0x10000) 
0F95 754000     961            mov x+3, #high(0 / 0x10000) 
0F98 7D64       962       mov R5, #100
0F9A            963   Ave_loop:
0F9A 120F64     964       lcall Check_Temp
0F9D 754400     965       mov y+3, #0
0FA0 754300     966       mov y+2, #0
0FA3 8F42       967       mov y+1, R7
0FA5 8E41       968       mov y+0, R6
0FA7 1201B5     969       lcall add32
0FAA 121049     970       lcall Wait10us
0FAD DDEB       971       djnz R5, Ave_loop
0FAF 754164     972            mov y+0, #low (100 % 0x10000) 
0FB2 754200     972            mov y+1, #high(100 % 0x10000) 
0FB5 754300     972            mov y+2, #low (100 / 0x10000) 
0FB8 754400     972            mov y+3, #high(100 / 0x10000) 
0FBB 1202F7     973       lcall div32
0FBE            974   
0FBE            975       ;**INSERT MATH FUNCTIONS
0FBE            976   
0FBE 75414E     977            mov y+0, #low (2894 % 0x10000) 
0FC1 75420B     977            mov y+1, #high(2894 % 0x10000) 
0FC4 754300     977            mov y+2, #low (2894 / 0x10000) 
0FC7 754400     977            mov y+3, #high(2894 / 0x10000)  ;6078; 2026
0FCA 12026A     978            lcall mul32
0FCD 754110     979            mov y+0, #low (10000 % 0x10000) 
0FD0 754227     979            mov y+1, #high(10000 % 0x10000) 
0FD3 754300     979            mov y+2, #low (10000 / 0x10000) 
0FD6 754400     979            mov y+3, #high(10000 / 0x10000)  ;14000; 7000
0FD9 1202F7     980            lcall div32
0FDC 754116     981            mov y+0, #low (22 % 0x10000) 
0FDF 754200     981            mov y+1, #high(22 % 0x10000) 
0FE2 754300     981            mov y+2, #low (22 / 0x10000) 
0FE5 754400     981            mov y+3, #high(22 / 0x10000) 
0FE8 1201B5     982       lcall add32
0FEB 853D3B     983       mov Temp_oven, x+0
0FEE            984       ;add KTemp_oven, Temp_oven, #273
0FEE            985   
0FEE            986   Display_Temp_BCD_Or_Kelvin:
0FEE 1200F0     987            lcall hex2bcd ; converts binary in x to BCD in BCD
0FF1            988       ;mov a, K_or_C
0FF1            989       ;cjne a, #1, Display_3_digit_BCD
0FF1            990       ;mov a, KTemp_oven
0FF1            991       ;SendToLCD
0FF1            992       ;sjmp Send_Temp_Port
0FF1            993   
0FF1            994   Display_Temp_BCD:    
0FF1 120E0A     995       lcall Display_3_digit_BCD
0FF4            996   
0FF4            997   Send_Temp_Port:
0FF4            998       ;Send_BCD(bcd+4)
0FF4            999       ;Send_BCD(bcd+3)
0FF4           1000       ;Send_BCD(bcd+2)
0FF4 C000      1001       push ar0
0FF6 A846      1001       mov r0, bcd+1
0FF8 1200DA    1001       lcall ?Send_BCD
0FFB D000      1001       pop ar0
0FFD           1001   
0FFD C000      1002       push ar0
0FFF A845      1002       mov r0, bcd+0
1001 1200DA    1002       lcall ?Send_BCD
1004 D000      1002       pop ar0
1006           1002   
1006 740D      1003            mov a, #'\r'
1008 12047E    1004            lcall putchar
100B 740A      1005            mov a, #'\n'
100D 12047E    1006            lcall putchar
1010           1007   Check_Temp_done:
1010 22        1008   ret    
1011           1009   
1011           1010   ;-------------------------------------------------------------------------------------------------------------------------------
1011           1011   
1011           1012   ;Time wait
1011           1013   
1011           1014   Wait_One_Second:
1011 C002      1015            push AR2
1013 7AFA      1015            mov R2, #250
1015 120039    1015            lcall ?Wait_Milli_Seconds
1018 D002      1015            pop AR2
101A C002      1016            push AR2
101C 7AFA      1016            mov R2, #250
101E 120039    1016            lcall ?Wait_Milli_Seconds
1021 D002      1016            pop AR2
1023 C002      1017            push AR2
1025 7AFA      1017            mov R2, #250
1027 120039    1017            lcall ?Wait_Milli_Seconds
102A D002      1017            pop AR2
102C C002      1018            push AR2
102E 7AFA      1018            mov R2, #250
1030 120039    1018            lcall ?Wait_Milli_Seconds
1033 D002      1018            pop AR2
1035 22        1019   ret
1036           1020   
1036           1021   Wait_Half_Second:
1036 C002      1022            push AR2
1038 7AFA      1022            mov R2, #250
103A 120039    1022            lcall ?Wait_Milli_Seconds
103D D002      1022            pop AR2
103F C002      1023            push AR2
1041 7AFA      1023            mov R2, #250
1043 120039    1023            lcall ?Wait_Milli_Seconds
1046 D002      1023            pop AR2
1048 22        1024   ret
1049           1025   
1049           1026   
1049           1027   
1049           1028   Wait10us:
1049 784A      1029       mov R0, #74
104B D8FE      1030       djnz R0, $
104D 22        1031   ret
104E           1032   ; ==================================================================================================
104E           1033   
104E           1034   ;-------------------------------------;
104E           1035   ; ISR for Timer 1.  Used to playback  ;
104E           1036   ; the WAV file stored in the SPI      ;
104E           1037   ; flash memory.                       ;
104E           1038   ;-------------------------------------;
104E           1039   Timer1_ISR:
104E           1040            ; The registers used in the ISR must be saved in the stack
104E C0E0      1041            push acc
1050 C0D0      1042            push psw
1052           1043            
1052           1044            ; Check if the play counter is zero.  If so, stop playing sound.
1052 E54C      1045            mov a, w+0
1054 454D      1046            orl a, w+1
1056 454E      1047            orl a, w+2
1058 601C      1048            jz stop_playing
105A           1049            
105A           1050            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
105A 74FF      1051            mov a, #0xff
105C 154C      1052            dec w+0
105E B54C07    1053            cjne a, w+0, keep_playing
1061 154D      1054            dec w+1
1063 B54D02    1055            cjne a, w+1, keep_playing
1066 154E      1056            dec w+2
1068           1057            
1068           1058   keep_playing:
1068 D2A6      1059            setb SPEAKER
106A 12040D    1060            lcall Send_SPI ; Read the next byte from the SPI Flash...
106D           1061            ;mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
106D 2480      1062            add a, #0x80
106F F5AD      1063            mov DADH, a ; Output to DAC. DAC output is pin P2.3
1071 43A440    1064            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
1074 800C      1065            sjmp Timer1_ISR_Done
1076           1066   
1076           1067   stop_playing:
1076 C28E      1068            clr TR1 ; Stop timer 1
1078 D2A5      1069            setb FLASH_CE  ; Disable SPI Flash
107A C2A6      1070            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
107C 75AD80    1071            mov DADH, #0x80 ; middle of range
107F 43A440    1072            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
1082           1073   
1082           1074   Timer1_ISR_Done:         
1082 D0D0      1075            pop psw
1084 D0E0      1076            pop acc
1086 32        1077            reti
1087           1078   ; ==================================================================================================
1087           1079   
1087           1080   ;---------------------------------;
1087           1081   ; Routine to initialize the ISR   ;
1087           1082   ; for timer 2                     ;
1087           1083   ;---------------------------------;
1087           1084   Timer2_init:
1087 75C800    1085       mov T2CON, #0
108A 75CDA9    1086       mov TH2, #high(TIMER2_RELOAD)
108D 75CC9A    1087       mov TL2, #low(TIMER2_RELOAD)
1090           1088   
1090 75CBA9    1089       mov RCAP2H, #high(TIMER2_RELOAD)
1093 75CA9A    1090       mov RCAP2L, #low(TIMER2_RELOAD)
1096           1091   
1096 E4        1092       clr a
1097 F530      1093       mov Count1ms+0, a
1099 F531      1094       mov Count1ms+1, a
109B F532      1095       mov Count5sec , a
109D D2AD      1096       setb ET2
109F D2CA      1097       setb TR2
10A1 C202      1098       clr enable_clk
10A3 22        1099       ret
10A4           1100   
10A4           1101   ;---------------------------------;
10A4           1102   ; ISR for timer 2                 ;
10A4           1103   ;---------------------------------;
10A4           1104   Timer2_ISR:
10A4 C2CF      1105       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
10A6 B290      1106       cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
10A8           1107            
10A8           1108            ; The two registers used in the ISR must be saved in the stack
10A8 C0E0      1109       push acc
10AA C0D0      1110       push psw
10AC           1111            
10AC           1112            ; Increment the 16-bit one mili second counter
10AC 0530      1113            inc Count1ms+0    ; Increment the low 8-bits first
10AE E530      1114            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
10B0 7002      1115            jnz Inc_Done
10B2 0531      1116            inc Count1ms+1
10B4           1117   
10B4           1118   Inc_Done:
10B4           1119   
10B4           1120   ;**Oven Power Output-------------------
10B4           1121       ; Do the PWM thing
10B4           1122            ; Check if Count1ms > pwm_ratio (this is a 16-bit compare)
10B4 C3        1123            clr c
10B5 E54F      1124            mov a, pwm_ratio+0
10B7 9530      1125            subb a, Count1ms+0
10B9 E550      1126            mov a, pwm_ratio+1
10BB 9531      1127            subb a, Count1ms+1
10BD           1128            ; if Count1ms > pwm_ratio  the carry is set.  Just copy the carry to the pwm output pin:
10BD 9290      1129            mov PWM_OUTPUT, c
10BF           1130   ;**----------------------------------
10BF           1131            ; Check if one second has passed
10BF E530      1132            mov a, Count1ms+0
10C1 B4E831    1133            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
10C4 E531      1134            mov a, Count1ms+1
10C6 B4032C    1135            cjne a, #high(1000), Timer2_ISR_done
10C9           1136            
10C9           1137            ; 1000 milliseconds have passed.  Set a flag so the main program knows
10C9 D200      1138            setb one_seconds_flag ; Let the main program know one second had passed
10CB           1139       
10CB 0532      1140       inc Count5sec
10CD E532      1141       mov a, Count5sec
10CF B40505    1142       cjne a, #5, Set_5sec_flag_done
10D2 D201      1143       setb five_seconds_flag
10D4 E4        1144       clr a
10D5 F532      1145       mov Count5sec, a
10D7           1146       
10D7           1147   Set_5sec_flag_done:
10D7 E4        1148            clr a
10D8 F530      1149            mov Count1ms+0, a
10DA F531      1150            mov Count1ms+1, a
10DC           1151   
10DC 300216    1152       jnb enable_clk, Timer2_ISR_done ;if the clk is enabled, increment the second. Otherwise skip
10DF           1153   ; Increment the run time counter and state time counter
10DF E538      1154            mov a, Run_time_seconds
10E1 2401      1155            add a, #0x01
10E3 D4        1156            da a
10E4 F538      1157       mov Run_time_seconds, a
10E6           1158       ;check sec overflow
10E6 B4600A    1159       cjne a, #0x60, Check_sec_overflow_done
10E9 753800    1160       mov Run_time_seconds, #0x00
10EC E539      1161       mov a, Run_time_minutes ;inc min
10EE 2401      1162       add a, #1
10F0 D4        1163       da a
10F1 F539      1164       mov Run_time_minutes, a
10F3           1165   Check_sec_overflow_done:
10F3 053A      1166       inc State_time
10F5           1167   Timer2_ISR_done:
10F5 D0D0      1168            pop psw
10F7 D0E0      1169            pop acc
10F9 32        1170            reti
10FA           1171   
10FA           1172   
10FA           1173   ; ==================================================================================================
10FA           1174   
10FA           1175   main:
10FA 75817F    1176       mov SP, #0x7F
10FD 121087    1177       lcall Timer2_Init
1100           1178       ;lcall INI_SPI
1100 120088    1179       lcall LCD_4BIT
1103 120466    1180       lcall InitSerialPort
1106 120C55    1181       lcall INI_PLAYBACK_TEMP
1109           1182       ; In case you decide to use the pins of P0, configure the port in bidirectional mode. Can be ignored
1109 75E600    1183       mov P0M0, #0
110C 75E700    1184       mov P0M1, #0
110F D2AF      1185       setb EA   ;Enable global enterupt
1111           1186   
1111 120F13    1187       lcall Load_Configuration
1114           1188   
1114           1189       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
1114 754F00    1190            mov pwm_ratio+0, #low(0)
1117 755000    1191            mov pwm_ratio+1, #high(0)
111A 753300    1192       mov States, #0
111D 120E27    1193       lcall Animation
1120           1194       
1120           1195       ; ***play audio***
1120           1195       ;cjne sound_flag, #0, $
1120           1195       
1120 121036    1195       lcall Wait_Half_Second
1123 C28E      1195       clr TR1 ; Stop Timer 1 ISR from playing previous request
1125 D2A5      1195       setb FLASH_CE
1127           1195       ;setb sound_flag ; sound starts
1127 C2A6      1195       clr SPEAKER ; Turn off speaker
1129 C2A5      1195       clr FLASH_CE ; Enable SPI Flash
112B 7403      1195       mov a, #READ_BYTES
112D 12040D    1195       lcall Send_SPI
1130           1195       ; Set the initial position in memory where to start playing
1130           1195       
1130 7400      1195       mov a, #0x00 ; change initial position
1132 12040D    1195       lcall Send_SPI
1135 7400      1195       mov a, #0x00 ; next memory position
1137 12040D    1195       lcall Send_SPI
113A 742D      1195       mov a, #0x2d ; next memory position
113C 12040D    1195       lcall Send_SPI
113F 7400      1195       mov a, #0x00 ; request first byte to send to DAC
1141 12040D    1195       lcall Send_SPI
1144           1195       
1144           1195       ; How many bytes to play?
1144 754E00    1195       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
1147 754D4E    1195       mov w+1, #0x4e ; Load the middle byte of the number of bytes to play
114A 754C20    1195       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
114D           1195       
114D           1195       
114D D2A6      1195       setb SPEAKER ;Turn on speaker
114F D28E      1195       setb TR1 ;Start playback by enabling Timer1
1151           1195       ;clr sound_flag ; sound ends
1151           1196       
1151           1197       
1151           1198   state0: ; idle
1151           1199       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
1151           1200            ;mov pwm_ratio+0, #low(0)
1151           1201            ;mov pwm_ratio+1, #high(0)
1151           1202       ;mov States, #0
1151           1203   
1151           1204   ;***initial parameters displayed***
1151           1205       
1151           1206       ;Displays Soak Temp and Time
1151 120D5D    1207       lcall State0_display
1154           1208       ;check power on
1154 1204F6    1209       lcall CHECK_POWER
1157           1210       ; check the parameters being pressed
1157 120486    1211       lcall CHECK_STIME
115A 1204A2    1212       lcall CHECK_STEMP
115D 1204BE    1213       lcall CHECK_RTIME
1160 1204DA    1214       lcall CHECK_RTEMP
1163 120EDC    1215       lcall Save_Configuration
1166           1216       
1166           1217       ;lcall Check_Temp
1166           1218       ;lcall PLAYBACK_TEMP
1166           1219   
1166 2085E8    1220       jb NEXT_STATE_BUTTON, state0
1169 C002      1221            push AR2
116B 7A32      1221            mov R2, #50
116D 120039    1221            lcall ?Wait_Milli_Seconds
1170 D002      1221            pop AR2 ; debounce time
1172 2085DC    1222            jb NEXT_STATE_BUTTON, state0 ; if button not pressed, loop
1175 3085FD    1223            jnb NEXT_STATE_BUTTON, $
1178           1224   state0_done:
1178 753301    1225       mov States, #1
117B 753A00    1226       mov State_time, #0
117E D202      1227       setb enable_clk
1180           1228      
1180           1229        
1180           1230   
1180           1231   state1_beginning:
1180           1232       
1180           1233       ;Start Run Time
1180 753800    1234       mov Run_time_seconds, #0 ; time starts at 0:00
1183 753900    1235       mov Run_time_minutes, #0
1186 753A00    1236       mov State_time, #0
1189           1237   
1189           1238       ;***clear the screen and set new display***
1189 120CB7    1239       lcall Initialize_State_Display
118C C0E0      1240            push acc
118E 7407      1240            mov a, #7
1190 14        1240            dec a
1191 1200BD    1240            lcall ?Set_Cursor_2 ; Select column and row
1194 D0E0      1240            pop acc
1196 C083      1241            push dph
1198 C082      1241            push dpl
119A C0E0      1241            push acc
119C 9003C7    1241            mov dptr, #Ramp2Soak
119F 1200B2    1241            lcall ?Send_Constant_String
11A2 D0E0      1241            pop acc
11A4 D082      1241            pop dpl
11A6 D083      1241            pop dph; displays current state
11A8           1242   
11A8           1243       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
11A8 754FE8    1244            mov pwm_ratio+0, #low(1000)
11AB 755003    1245            mov pwm_ratio+1, #high(1000)
11AE           1246       ; ***play audio***
11AE           1246       ;cjne sound_flag, #0, $
11AE           1246       
11AE 121036    1246       lcall Wait_Half_Second
11B1 C28E      1246       clr TR1 ; Stop Timer 1 ISR from playing previous request
11B3 D2A5      1246       setb FLASH_CE
11B5           1246       ;setb sound_flag ; sound starts
11B5 C2A6      1246       clr SPEAKER ; Turn off speaker
11B7 C2A5      1246       clr FLASH_CE ; Enable SPI Flash
11B9 7403      1246       mov a, #READ_BYTES
11BB 12040D    1246       lcall Send_SPI
11BE           1246       ; Set the initial position in memory where to start playing
11BE           1246       
11BE 7400      1246       mov a, #0x00 ; change initial position
11C0 12040D    1246       lcall Send_SPI
11C3 7400      1246       mov a, #0x00 ; next memory position
11C5 12040D    1246       lcall Send_SPI
11C8 742D      1246       mov a, #0x2d ; next memory position
11CA 12040D    1246       lcall Send_SPI
11CD 7400      1246       mov a, #0x00 ; request first byte to send to DAC
11CF 12040D    1246       lcall Send_SPI
11D2           1246       
11D2           1246       ; How many bytes to play?
11D2 754E00    1246       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
11D5 754D4E    1246       mov w+1, #0x4e ; Load the middle byte of the number of bytes to play
11D8 754C20    1246       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
11DB           1246       
11DB           1246       
11DB D2A6      1246       setb SPEAKER ;Turn on speaker
11DD D28E      1246       setb TR1 ;Start playback by enabling Timer1
11DF           1246       ;clr sound_flag ; sound ends
11DF 8003      1247       sjmp state1
11E1           1248       
11E1           1249   main_1:
11E1 0210FA    1250            ljmp main
11E4           1251   
11E4           1252   state1: ; ramp to soak
11E4           1253       
11E4           1254       ;PLAYBACK_TEMP(#0x00,#0x00,#0x2d, #0x4e,#0x20)
11E4           1255       ;check power on
11E4 1204F6    1256       lcall CHECK_POWER
11E7           1257       ;Update Time and Temp
11E7 120D36    1258       lcall Update_Display
11EA 120F8C    1259       lcall Average_Temp
11ED           1260       
11ED 120525    1261       lcall SOUND_FSM
11F0           1262   
11F0           1263   Check_Temp_done1:
11F0           1264   
11F0           1265       ;check if temp is below 150 
11F0 E53B      1266       mov a, Temp_oven           
11F2 9534      1267       subb a, Temp_soak
11F4 5014      1268       jnc state1_done        ; if greater, jump to state 2
11F6 6012      1269       jz state1_done         ; if equal to, jump to state 2
11F8 4000      1270       jc Check_state1_safety ; if less than, check state time
11FA           1271   Check_state1_safety:       ; safety
11FA E53B      1272       mov a, Temp_oven           
11FC 9432      1273       subb a, #50
11FE 50E4      1274       jnc state1             ; if greater, go back to state1
1200 E53A      1275       mov a, State_time      ; if less than 50C, check if state time is too long
1202 943C      1276       subb a, #60
1204 50DB      1277       jnc main_1             ; if greater, restart
1206 60D9      1278       jz main_1              ; if equal to, restart
1208 40DA      1279       jc state1              ; if less than, go back to state1
120A           1280   ;*Checking moving to states with buttons---- 
120A           1281   ;*Will remove after proper temperature reading----
120A           1282   
120A           1283       ;jb NEXT_STATE_BUTTON, state1
120A           1284       ;Wait_Milli_Seconds(#50) ; debounce time
120A           1285            ;jb NEXT_STATE_BUTTON, state1 ; if button not pressed, loop
120A           1286            ;jnb NEXT_STATE_BUTTON, $ 
120A           1287   
120A           1288   state1_done:
120A 753302    1289       mov States, #2
120D           1290   
120D           1291   ; preheat/soak
120D           1292   state2_beginning: 
120D 753A00    1293       mov State_time, #0;x00 ;clear the state time
1210           1294       ;***clear the screen and set new display***
1210 120CB7    1295       lcall Initialize_State_Display
1213 C0E0      1296            push acc
1215 7407      1296            mov a, #7
1217 14        1296            dec a
1218 1200BD    1296            lcall ?Set_Cursor_2 ; Select column and row
121B D0E0      1296            pop acc
121D C083      1297            push dph
121F C082      1297            push dpl
1221 C0E0      1297            push acc
1223 9003D1    1297            mov dptr, #Soak
1226 1200B2    1297            lcall ?Send_Constant_String
1229 D0E0      1297            pop acc
122B D082      1297            pop dpl
122D D083      1297            pop dph ;displays current state
122F           1298   
122F           1299       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
122F 754FC8    1300            mov pwm_ratio+0, #low(200)
1232 755000    1301            mov pwm_ratio+1, #high(000)
1235           1302       ; Produces SOAK on speaker
1235           1303       ; ***play audio***
1235           1303       ;cjne sound_flag, #0, $
1235           1303       
1235 121036    1303       lcall Wait_Half_Second
1238 C28E      1303       clr TR1 ; Stop Timer 1 ISR from playing previous request
123A D2A5      1303       setb FLASH_CE
123C           1303       ;setb sound_flag ; sound starts
123C C2A6      1303       clr SPEAKER ; Turn off speaker
123E C2A5      1303       clr FLASH_CE ; Enable SPI Flash
1240 7403      1303       mov a, #READ_BYTES
1242 12040D    1303       lcall Send_SPI
1245           1303       ; Set the initial position in memory where to start playing
1245           1303       
1245 7400      1303       mov a, #0x00 ; change initial position
1247 12040D    1303       lcall Send_SPI
124A 7444      1303       mov a, #0x44 ; next memory position
124C 12040D    1303       lcall Send_SPI
124F 74DD      1303       mov a, #0xdd ; next memory position
1251 12040D    1303       lcall Send_SPI
1254 7400      1303       mov a, #0x00 ; request first byte to send to DAC
1256 12040D    1303       lcall Send_SPI
1259           1303       
1259           1303       ; How many bytes to play?
1259 754E00    1303       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
125C 754D4E    1303       mov w+1, #0x4e ; Load the middle byte of the number of bytes to play
125F 754C20    1303       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
1262           1303       
1262           1303       
1262 D2A6      1303       setb SPEAKER ;Turn on speaker
1264 D28E      1303       setb TR1 ;Start playback by enabling Timer1
1266           1303       ;clr sound_flag ; sound ends
1266           1304   
1266           1305   state2:
1266           1306       ;check power on
1266 1204F6    1307       lcall CHECK_POWER 
1269           1308       ;Update Time and Temp
1269 120D36    1309       lcall Update_Display
126C 120F8C    1310       lcall Average_Temp
126F           1311   
126F 120525    1312       lcall SOUND_FSM
1272           1313       
1272           1314       ; loop back to state2 if run time is less than soak time. If greater than jump to state3 cuz of overflow of time
1272           1315        
1272 E53A      1316       mov a, State_time
1274 9535      1317       subb a, Time_soak
1276 5002      1318       jnc state2_done
1278 40EC      1319       jc state2
127A           1320   
127A           1321   
127A           1322   ;*Checking moving to states with buttons---- 
127A           1323   ;*Will remove after proper temperature reading----
127A           1324   
127A           1325       ;jb NEXT_STATE_BUTTON, state2
127A           1326       ;Wait_Milli_Seconds(#50) ; debounce time
127A           1327            ;jb NEXT_STATE_BUTTON, state2 ; if button not pressed, loop
127A           1328            ;jnb NEXT_STATE_BUTTON, $ 
127A           1329       
127A           1330   state2_done:
127A 753A03    1331       mov State_time, #3
127D           1332   
127D           1333   ; ramp to peak
127D           1334   state3_beginning:
127D           1335       ;setb OVEN_POWER ;turn power on 100%
127D           1336   
127D           1337       ;***clear the screen and set new display***
127D 120CB7    1338       lcall Initialize_State_Display
1280 C0E0      1339            push acc
1282 7407      1339            mov a, #7
1284 14        1339            dec a
1285 1200BD    1339            lcall ?Set_Cursor_2 ; Select column and row
1288 D0E0      1339            pop acc
128A C083      1340            push dph
128C C082      1340            push dpl
128E C0E0      1340            push acc
1290 9003D6    1340            mov dptr, #Ramp2Peak
1293 1200B2    1340            lcall ?Send_Constant_String
1296 D0E0      1340            pop acc
1298 D082      1340            pop dpl
129A D083      1340            pop dph
129C           1341   
129C           1342       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
129C 754FE8    1343            mov pwm_ratio+0, #low(1000)
129F 755003    1344            mov pwm_ratio+1, #high(1000)
12A2           1345   
12A2           1346       ; Produces RAMP TO PEAK on speaker
12A2           1347       ; ***play audio***
12A2           1347       ;cjne sound_flag, #0, $
12A2           1347       
12A2 121036    1347       lcall Wait_Half_Second
12A5 C28E      1347       clr TR1 ; Stop Timer 1 ISR from playing previous request
12A7 D2A5      1347       setb FLASH_CE
12A9           1347       ;setb sound_flag ; sound starts
12A9 C2A6      1347       clr SPEAKER ; Turn off speaker
12AB C2A5      1347       clr FLASH_CE ; Enable SPI Flash
12AD 7403      1347       mov a, #READ_BYTES
12AF 12040D    1347       lcall Send_SPI
12B2           1347       ; Set the initial position in memory where to start playing
12B2           1347       
12B2 7400      1347       mov a, #0x00 ; change initial position
12B4 12040D    1347       lcall Send_SPI
12B7 748B      1347       mov a, #0x8b ; next memory position
12B9 12040D    1347       lcall Send_SPI
12BC 74CA      1347       mov a, #0xca ; next memory position
12BE 12040D    1347       lcall Send_SPI
12C1 7400      1347       mov a, #0x00 ; request first byte to send to DAC
12C3 12040D    1347       lcall Send_SPI
12C6           1347       
12C6           1347       ; How many bytes to play?
12C6 754E00    1347       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
12C9 754D75    1347       mov w+1, #0x75 ; Load the middle byte of the number of bytes to play
12CC 754C30    1347       mov w+0, #0x30 ; Load the low byte of the number of bytes to play
12CF           1347       
12CF           1347       
12CF D2A6      1347       setb SPEAKER ;Turn on speaker
12D1 D28E      1347       setb TR1 ;Start playback by enabling Timer1
12D3           1347       ;clr sound_flag ; sound ends
12D3           1348   
12D3           1349   state3: 
12D3           1350       ;check power on
12D3 1204F6    1351       lcall CHECK_POWER
12D6 120F8C    1352       lcall Average_Temp
12D9           1353       
12D9           1354       
12D9           1355       ;Update Time and Temp
12D9 120D36    1356       lcall Update_Display
12DC 120525    1357       lcall SOUND_FSM
12DF           1358   
12DF           1359       
12DF E53B      1360       mov a, Temp_oven           
12E1 9536      1361       subb a, Temp_refl
12E3 5004      1362       jnc state3_done    ; if greater, jump to state 4
12E5 6002      1363       jz state3_done ; if equal to, jump to state 4
12E7 40EA      1364       jc state3 ; if less than, go back to state3
12E9           1365       
12E9           1366       ;jb NEXT_STATE_BUTTON, state3
12E9           1367       ;Wait_Milli_Seconds(#50) ; debounce time
12E9           1368            ;jb NEXT_STATE_BUTTON, state3 ; if button not pressed, loop
12E9           1369            ;jnb NEXT_STATE_BUTTON, $
12E9           1370   
12E9           1371   state3_done:
12E9 753A04    1372       mov State_time, #4
12EC           1373   
12EC           1374   ; reflow 
12EC           1375   state4_beginning:
12EC           1376       
12EC 753A00    1377       mov State_time, #0;x00 clear the state time
12EF           1378       ;***clear the screen and set new display***
12EF 120CB7    1379       lcall Initialize_State_Display
12F2 C0E0      1380            push acc
12F4 7407      1380            mov a, #7
12F6 14        1380            dec a
12F7 1200BD    1380            lcall ?Set_Cursor_2 ; Select column and row
12FA D0E0      1380            pop acc
12FC C083      1381            push dph
12FE C082      1381            push dpl
1300 C0E0      1381            push acc
1302 9003E0    1381            mov dptr, #Reflow
1305 1200B2    1381            lcall ?Send_Constant_String
1308 D0E0      1381            pop acc
130A D082      1381            pop dpl
130C D083      1381            pop dph
130E           1382   
130E           1383       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
130E 754FC8    1384            mov pwm_ratio+0, #low(200)
1311 755000    1385            mov pwm_ratio+1, #high(000)
1314           1386   
1314           1387       ; Produces REFLOW on speaker
1314           1388       ; ***play audio***
1314           1388       ;cjne sound_flag, #0, $
1314           1388       
1314 121036    1388       lcall Wait_Half_Second
1317 C28E      1388       clr TR1 ; Stop Timer 1 ISR from playing previous request
1319 D2A5      1388       setb FLASH_CE
131B           1388       ;setb sound_flag ; sound starts
131B C2A6      1388       clr SPEAKER ; Turn off speaker
131D C2A5      1388       clr FLASH_CE ; Enable SPI Flash
131F 7403      1388       mov a, #READ_BYTES
1321 12040D    1388       lcall Send_SPI
1324           1388       ; Set the initial position in memory where to start playing
1324           1388       
1324 7400      1388       mov a, #0x00 ; change initial position
1326 12040D    1388       lcall Send_SPI
1329 74F0      1388       mov a, #0xf0 ; next memory position
132B 12040D    1388       lcall Send_SPI
132E 7463      1388       mov a, #0x63 ; next memory position
1330 12040D    1388       lcall Send_SPI
1333 7400      1388       mov a, #0x00 ; request first byte to send to DAC
1335 12040D    1388       lcall Send_SPI
1338           1388       
1338           1388       ; How many bytes to play?
1338 754E00    1388       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
133B 754D59    1388       mov w+1, #0x59 ; Load the middle byte of the number of bytes to play
133E 754CD8    1388       mov w+0, #0xd8 ; Load the low byte of the number of bytes to play
1341           1388       
1341           1388       
1341 D2A6      1388       setb SPEAKER ;Turn on speaker
1343 D28E      1388       setb TR1 ;Start playback by enabling Timer1
1345           1388       ;clr sound_flag ; sound ends
1345           1389   
1345           1390   
1345           1391   state4:
1345           1392       ;check power on
1345 1204F6    1393       lcall CHECK_POWER
1348           1394       ;Update Time and Temp
1348 120D36    1395       lcall Update_Display
134B 120F8C    1396       lcall Average_Temp
134E 120525    1397       lcall SOUND_FSM
1351           1398   
1351           1399       
1351           1400       ; loop back to state2 if run time is less than soak time
1351 E53A      1401       mov a, State_time
1353 9537      1402       subb a, Time_refl
1355 5002      1403       jnc state4_done
1357 40EC      1404       jc state4
1359           1405   
1359           1406       ;*Checking moving to states with buttons---- 
1359           1407   ;*Will remove after proper temperature reading----
1359           1408   
1359           1409       ;jb NEXT_STATE_BUTTON, state4
1359           1410       ;Wait_Milli_Seconds(#50) ; debounce time
1359           1411            ;jb NEXT_STATE_BUTTON, state4 ; if button not pressed, loop
1359           1412            ;jnb NEXT_STATE_BUTTON, $ 
1359           1413   
1359           1414   state4_done: 
1359 753A00    1415       mov State_time, #0
135C 02135F    1416       ljmp state5_beginning 
135F           1417   
135F           1418   
135F           1419   ; cooling
135F           1420   state5_beginning: ; turn oven off
135F C287      1421       clr OVEN_POWER
1361           1422   
1361           1423   ;***clear the screen and set new display***
1361 120CB7    1424       lcall Initialize_State_Display
1364 C083      1425            push dph
1366 C082      1425            push dpl
1368 C0E0      1425            push acc
136A 9003E7    1425            mov dptr, #Cooling
136D 1200B2    1425            lcall ?Send_Constant_String
1370 D0E0      1425            pop acc
1372 D082      1425            pop dpl
1374 D083      1425            pop dph
1376           1426   
1376           1427       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
1376 754F00    1428            mov pwm_ratio+0, #low(0)
1379 755000    1429            mov pwm_ratio+1, #high(0)
137C           1430   
137C           1431       ; Produces COOLING on speaker
137C           1432       ; ***play audio***
137C           1432       ;cjne sound_flag, #0, $
137C           1432       
137C 121036    1432       lcall Wait_Half_Second
137F C28E      1432       clr TR1 ; Stop Timer 1 ISR from playing previous request
1381 D2A5      1432       setb FLASH_CE
1383           1432       ;setb sound_flag ; sound starts
1383 C2A6      1432       clr SPEAKER ; Turn off speaker
1385 C2A5      1432       clr FLASH_CE ; Enable SPI Flash
1387 7403      1432       mov a, #READ_BYTES
1389 12040D    1432       lcall Send_SPI
138C           1432       ; Set the initial position in memory where to start playing
138C           1432       
138C 7401      1432       mov a, #0x01 ; change initial position
138E 12040D    1432       lcall Send_SPI
1391 7448      1432       mov a, #0x48 ; next memory position
1393 12040D    1432       lcall Send_SPI
1396 749A      1432       mov a, #0x9a ; next memory position
1398 12040D    1432       lcall Send_SPI
139B 7401      1432       mov a, #0x01 ; request first byte to send to DAC
139D 12040D    1432       lcall Send_SPI
13A0           1432       
13A0           1432       ; How many bytes to play?
13A0 754E00    1432       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
13A3 754D6B    1432       mov w+1, #0x6b ; Load the middle byte of the number of bytes to play
13A6 754C6C    1432       mov w+0, #0x6c ; Load the low byte of the number of bytes to play
13A9           1432       
13A9           1432       
13A9 D2A6      1432       setb SPEAKER ;Turn on speaker
13AB D28E      1432       setb TR1 ;Start playback by enabling Timer1
13AD           1432       ;clr sound_flag ; sound ends
13AD           1433   
13AD           1434   state5:
13AD           1435       ;check power on
13AD 1204F6    1436       lcall CHECK_POWER
13B0           1437       
13B0           1438       ; update display
13B0 120D36    1439       lcall Update_Display
13B3 120F8C    1440       lcall Average_Temp
13B6           1441   
13B6 120525    1442       lcall SOUND_FSM
13B9           1443   
13B9 E53B      1444       mov a, Temp_oven
13BB 943C      1445       subb a, #60
13BD 50EE      1446       JNC state5    ; if greater, jump back to state 5
13BF 60EC      1447       JZ state5 ; if equal to, go back to state5
13C1 4000      1448       JC state5_done ; if less than, go back to state 0
13C3           1449   
13C3           1450       ;*Checking moving to states with buttons---- 
13C3           1451   ;*Will remove after proper temperature reading----
13C3           1452   
13C3           1453       ;jb NEXT_STATE_BUTTON, state5
13C3           1454       ;Wait_Milli_Seconds(#50) ; debounce time
13C3           1455            ;jb NEXT_STATE_BUTTON, state5 ; if button not pressed, loop
13C3           1456            ;jnb NEXT_STATE_BUTTON, $ 
13C3           1457   
13C3           1458   state5_done:
13C3 753A00    1459       mov State_time, #0
13C6 753300    1460       mov States, #0
13C9 0210FA    1461       ljmp main
13CC           1462   
13CC           1463   EN
