                  2   $LIST
0000              4   
0000              5   
0000              6   ;-------------------------------------------------------------------------------------------------------------------------------
0000              7   ;These EQU must match the wiring between the microcontroller and ADC
0000              8   CLK  EQU 22118400
0000              9   TIMER1_RATE    EQU 25000 ;22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             10   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             11   BAUD equ 115200
0000             12   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000             13   
0000             14   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             15   TIMER2_RELOAD EQU (65536-(CLK/TIMER2_RATE))
0000             16   
0000             17   ;shjfjdfs
0000             18   ;-------------------------------------------------------------------------------------------------------------------------------
0000             19   ;Button Pin Mapping
0000             20   NEXT_STATE_BUTTON  equ P0.5
0000             21   STIME_BUTTON    equ P0.2
0000             22   STEMP_BUTTON    equ P0.3
0000             23   RTIME_BUTTON    equ P0.4
0000             24   RTEMP_BUTTON    equ P0.6
0000             25   
0000             26   POWER_BUTTON    equ P4.5
0000             27   SHIFT_BUTTON    equ p0.1
0000             28   
0000             29   ;Output Pins
0000             30   OVEN_POWER      equ P0.7
0000             31   SPEAKER         equ P2.6
0000             32   
0000             33   PWM_OUTPUT    equ P1.0 ; Attach an LED (with 1k resistor in series) to P1.0
0000             34   
0000             35   
0000             36   ;FLASH pins
0000             37   MY_MOSI_SOUND EQU P2.4
0000             38   MY_MISO_SOUND EQU P2.1
0000             39   MY_SCLK_SOUND EQU P2.0
0000             40   FLASH_CE      EQU P2.5
0000             41   
0000             42   ;Thermowire Pins
0000             43   CE_ADC    EQU  P1.7
0000             44   MY_MOSI   EQU  P1.6
0000             45   MY_MISO   EQU  P1.5
0000             46   MY_SCLK   EQU  P1.4 
0000             47   
0000             48   ; Commands supported by the SPI flash memory according to the datasheet
0000             49   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             50   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             51   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             52   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             53   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             54   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             55   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             56   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             57   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             58   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             59   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             60   
0000             61   ; These 'equ' must match the hardware wiring
0000             62   LCD_RS equ P3.2
0000             63   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
0000             64   LCD_E  equ P3.3
0000             65   LCD_D4 equ P3.4
0000             66   LCD_D5 equ P3.5
0000             67   LCD_D6 equ P3.6
0000             68   LCD_D7 equ P3.7
0000             69   
0000             70   ;-------------------------------------------------------------------------------------------------------------------------------
0000             71   
0000             72   org 0x0000
0000 021181      73       ljmp main
0003             74   
0003             75   ; External interrupt 0 vector (not used in this code)
0003             76   org 0x0003
0003 32          77            reti
0004             78   
0004             79   ; Timer/Counter 0 overflow interrupt vector
000B             80   org 0x000B
000B 32          81            reti
000C             82   
000C             83   ; External interrupt 1 vector (not used in this code)
0013             84   org 0x0013
0013 32          85            reti
0014             86   
0014             87   ; Timer/Counter 1 overflow interrupt vector
001B             88   org 0x001B
001B 0210D5      89            ljmp Timer1_ISR
001E             90   
001E             91   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             92   org 0x0023 
0023 32          93            reti
0024             94            
0024             95   ; Timer/Counter 2 overflow interrupt vector
002B             96   org 0x002B
002B 02112B      97       ljmp Timer2_ISR
002E             98   ;-------------------------------------------------------------------------------------------------------------------------------
002E             99   ; Place our variables here
0030            100   DSEG at 0x30 ; Before the state machine!
0030            101   Count1ms:         ds 2 ; Used to determine when one second has passed
0032            102   Count5sec:        ds 1
0033            103   States:           ds 1
0034            104   Temp_soak:        ds 1
0035            105   Time_soak:        ds 1
0036            106   Temp_refl:        ds 1
0037            107   Time_refl:        ds 1
0038            108   Run_time_seconds: ds 1
0039            109   Run_time_minutes: ds 1
003A            110   State_time:       ds 1
003B            111   Temp_oven:        ds 1
003C            112   KTemp_oven:       ds 1
003D            113   x:                ds 4
0041            114   y:                ds 4
0045            115   bcd:              ds 5
004A            116   Result:           ds 2
004C            117   w:                ds 3
004F            118   pwm_ratio:        ds 2
0051            119   average_count:    ds 1
0052            120   K_or_C:           ds 1
0053            121   
                123   $LIST
00F0            125   
                546   $LIST
                127   $LIST
0360            129   
                131   $LIST
03E7            133   
0000            134   bseg
0000            135   one_seconds_flag:  dbit 1
0001            136   five_seconds_flag: dbit 1
0002            137   enable_clk:        dbit 1
0003            138   mf:                dbit 1
0004            139   ;sound_flag: dbit 1
0004            140   
03E7            141   cseg
03E7            142   
03E7            143   ;-------------------------------------------------------------------------------------------------------------------------------
03E7            144   ;***Messages To Display*** 
03E7            145   
03E7            146   ;shortened labels
03E7 53546D70   147   STemp:  db 'STmp:', 0
     3A00
03ED 53546D3A   148   STime:  db 'STm:', 0
     00
03F2 52546D70   149   RTemp:  db 'RTmp:', 0
     3A00
03F8 52546D3A   150   RTime:  db 'RTm:', 0
     00
03FD            151   
03FD            152   ;lables for runnning oven
03FD 53746174   153   state:     db 'State>' , 0
     653E00
0404 546D653E   154   time:      db 'Tme>' , 0
     00
0409 3A00       155   colon:     db ':', 0
040B 546D703E   156   temp:      db 'Tmp>', 0
     00
0410            157   
0410            158   ;labels for changin parameters
0410 5265666C   159   ReflowTemp:  db 'Reflow Temperature:', 0
     6F772054
     656D7065
     72617475
     72653A00
0424 5265666C   160   ReflowTime:  db 'Reflow Time:', 0
     6F772054
     696D653A
     00
0431 536F616B   161   SoakTime:    db 'Soak Time:', 0
     2054696D
     653A00
043C 536F616B   162   SoakTemp:    db 'Soak Temperature:', 0
     2054656D
     70657261
     74757265
     3A00
044E            163   
044E            164   
044E            165   ;Current State in Oven
044E 52616D70   166   Ramp2Soak: db 'Ramp-Soak' , 0
     2D536F61
     6B00
0458 536F616B   167   Soak:      db 'Soak' , 0
     00
045D 52616D70   168   Ramp2Peak: db 'Ramp-Peak' , 0
     2D506561
     6B00
0467 5265666C   169   Reflow:    db 'Reflow' , 0
     6F7700
046E 436F6F6C   170   Cooling:   db 'Cooling' , 0
     696E6700
0476            171   
0476            172   ;-------------------------------------------------------------------------------------------------------------------------------
0476            173   ;FXNS FOR THERMOWIRE
0476            174   
0476            175   ;initialize SPI 
0476            176   INI_SPI:
0476 D295       177            setb MY_MISO          ; Make MISO an input pin
0478 C294       178            clr MY_SCLK           ; Mode 0,0 default
047A 22         179            ret
047B            180   DO_SPI_G:
047B C0E0       181            push acc
047D 7900       182            mov R1, #0            ; Received byte stored in R1
047F 7A08       183            mov R2, #8            ; Loop counter (8-bits)
0481            184   DO_SPI_G_LOOP:
0481 E8         185            mov a, R0             ; Byte to write is in R0
0482 33         186            rlc a                 ; Carry flag has bit to write
0483 F8         187            mov R0, a
0484 9296       188            mov MY_MOSI, c
0486 D294       189            setb MY_SCLK          ; Transmit
0488 A295       190            mov c, MY_MISO        ; Read received bit
048A E9         191            mov a, R1             ; Save received bit in R1
048B 33         192            rlc a
048C F9         193            mov R1, a
048D C294       194            clr MY_SCLK
048F DAF0       195            djnz R2, DO_SPI_G_LOOP
0491 D0E0       196            pop acc
0493 22         197   ret
0494            198   
0494            199   Send_SPI:
                200   	SPIBIT MAC
                201   	    ; Send/Receive bit %0
                202   		rlc a
                203   		mov MY_MOSI_SOUND, c
                204   		setb MY_SCLK_SOUND
                205   		mov c, MY_MISO_SOUND
                206   		clr MY_SCLK_SOUND
                207   		mov acc.0, c
                208   	ENDMAC
0494            209            
0494            210                ; Send/Receive bit 7
0494 33         210                    rlc a
0495 92A4       210                    mov MY_MOSI_SOUND, c
0497 D2A0       210                    setb MY_SCLK_SOUND
0499 A2A1       210                    mov c, MY_MISO_SOUND
049B C2A0       210                    clr MY_SCLK_SOUND
049D 92E0       210                    mov acc.0, c
049F            211                ; Send/Receive bit 6
049F 33         211                    rlc a
04A0 92A4       211                    mov MY_MOSI_SOUND, c
04A2 D2A0       211                    setb MY_SCLK_SOUND
04A4 A2A1       211                    mov c, MY_MISO_SOUND
04A6 C2A0       211                    clr MY_SCLK_SOUND
04A8 92E0       211                    mov acc.0, c
04AA            212                ; Send/Receive bit 5
04AA 33         212                    rlc a
04AB 92A4       212                    mov MY_MOSI_SOUND, c
04AD D2A0       212                    setb MY_SCLK_SOUND
04AF A2A1       212                    mov c, MY_MISO_SOUND
04B1 C2A0       212                    clr MY_SCLK_SOUND
04B3 92E0       212                    mov acc.0, c
04B5            213                ; Send/Receive bit 4
04B5 33         213                    rlc a
04B6 92A4       213                    mov MY_MOSI_SOUND, c
04B8 D2A0       213                    setb MY_SCLK_SOUND
04BA A2A1       213                    mov c, MY_MISO_SOUND
04BC C2A0       213                    clr MY_SCLK_SOUND
04BE 92E0       213                    mov acc.0, c
04C0            214                ; Send/Receive bit 3
04C0 33         214                    rlc a
04C1 92A4       214                    mov MY_MOSI_SOUND, c
04C3 D2A0       214                    setb MY_SCLK_SOUND
04C5 A2A1       214                    mov c, MY_MISO_SOUND
04C7 C2A0       214                    clr MY_SCLK_SOUND
04C9 92E0       214                    mov acc.0, c
04CB            215                ; Send/Receive bit 2
04CB 33         215                    rlc a
04CC 92A4       215                    mov MY_MOSI_SOUND, c
04CE D2A0       215                    setb MY_SCLK_SOUND
04D0 A2A1       215                    mov c, MY_MISO_SOUND
04D2 C2A0       215                    clr MY_SCLK_SOUND
04D4 92E0       215                    mov acc.0, c
04D6            216                ; Send/Receive bit 1
04D6 33         216                    rlc a
04D7 92A4       216                    mov MY_MOSI_SOUND, c
04D9 D2A0       216                    setb MY_SCLK_SOUND
04DB A2A1       216                    mov c, MY_MISO_SOUND
04DD C2A0       216                    clr MY_SCLK_SOUND
04DF 92E0       216                    mov acc.0, c
04E1            217                ; Send/Receive bit 0
04E1 33         217                    rlc a
04E2 92A4       217                    mov MY_MOSI_SOUND, c
04E4 D2A0       217                    setb MY_SCLK_SOUND
04E6 A2A1       217                    mov c, MY_MISO_SOUND
04E8 C2A0       217                    clr MY_SCLK_SOUND
04EA 92E0       217                    mov acc.0, c
04EC            218   
04EC 22         219   ret
04ED            220   
                221   Change_8bit_Variable MAC
                222       jb %0, %2
                223       Wait_Milli_Seconds(#50) ; de-bounce
                224       jb %0, %2
                225       jnb %0, $
                226       jb SHIFT_BUTTON, skip%Mb
                227       dec %1
                228       sjmp skip%Ma
                229       skip%Mb:
                230       inc %1
                231       skip%Ma:
                232   ENDMAC
04ED            233   
04ED            234   ;Change_8bit_Variable(MY_VARIABLE_BUTTON, my_variable, loop_c)
04ED            235   ;    Set_Cursor(2, 14)
04ED            236   ;    mov a, my_variable
04ED            237   ;    lcall SendToLCD
04ED            238   ;lcall Save_Configuration
04ED            239   
04ED            240   ;-------------------------------------------------------------------------------------------------------------------------------
04ED            241   ;***FXNS For Serial Port
04ED            242   
04ED            243   ; Configure the serial port and baud rate
04ED            244   InitSerialPort:
04ED            245       ; Since the reset button bounces, we need to wait a bit before
04ED            246       ; sending messages, otherwise we risk displaying gibberish!
04ED 79DE       247       mov R1, #222
04EF 78A6       248       mov R0, #166
04F1 D8FE       249       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
04F3 D9FA       250       djnz R1, $-4 ; 22.51519us*222=4.998ms
04F5            251       ; Now we can proceed with the configuration
04F5 438780     252            orl     PCON,#0x80
04F8 759852     253            mov     SCON,#0x52
04FB 759B00     254            mov     BDRCON,#0x00
04FE 759AF4     255            mov     BRL,#BRG_VAL
0501 759B1E     256            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0504 22         257   ret
0505            258   
0505            259   
0505            260   putchar:
0505 3099FD     261       jnb TI, putchar
0508 C299       262       clr TI
050A F599       263       mov SBUF, a
050C 22         264   ret
050D            265   
050D            266   ;-------------------------------------------------------------------------------------------------------------------------------
050D            267   ;***FXNS to CHECK BUTTONS
050D            268   
050D            269   CHECK_STIME:
050D            270   
050D 208218     271       jb STIME_BUTTON, CHECK_STIME_END
0510 C002       271            push AR2
0512 7A32       271            mov R2, #50
0514 120039     271            lcall ?Wait_Milli_Seconds
0517 D002       271            pop AR2 ; de-bounce
0519 20820C     271       jb STIME_BUTTON, CHECK_STIME_END
051C 3082FD     271       jnb STIME_BUTTON, $
051F 208104     271       jb SHIFT_BUTTON, skip16b
0522 1535       271       dec Time_soak
0524 8002       271       sjmp skip16a
0526            271       skip16b:
0526 0535       271       inc Time_soak
0528            271       skip16a:
0528            272            
0528            273   CHECK_STIME_END:
0528 22         274   ret
0529            275   
0529            276   CHECK_STEMP:
0529 208318     277       jb STEMP_BUTTON, CHECK_STEMP_END
052C C002       277            push AR2
052E 7A32       277            mov R2, #50
0530 120039     277            lcall ?Wait_Milli_Seconds
0533 D002       277            pop AR2 ; de-bounce
0535 20830C     277       jb STEMP_BUTTON, CHECK_STEMP_END
0538 3083FD     277       jnb STEMP_BUTTON, $
053B 208104     277       jb SHIFT_BUTTON, skip18b
053E 1534       277       dec Temp_soak
0540 8002       277       sjmp skip18a
0542            277       skip18b:
0542 0534       277       inc Temp_soak
0544            277       skip18a:
0544            278       ;lcall Save_Configuration
0544            279            
0544            280   CHECK_STEMP_END:
0544 22         281   ret
0545            282   
0545            283   CHECK_RTIME:
0545 208418     284       jb RTIME_BUTTON, CHECK_RTIME_END
0548 C002       284            push AR2
054A 7A32       284            mov R2, #50
054C 120039     284            lcall ?Wait_Milli_Seconds
054F D002       284            pop AR2 ; de-bounce
0551 20840C     284       jb RTIME_BUTTON, CHECK_RTIME_END
0554 3084FD     284       jnb RTIME_BUTTON, $
0557 208104     284       jb SHIFT_BUTTON, skip20b
055A 1537       284       dec Time_refl
055C 8002       284       sjmp skip20a
055E            284       skip20b:
055E 0537       284       inc Time_refl
0560            284       skip20a:
0560            285   CHECK_RTIME_END:
0560 22         286   ret
0561            287   
0561            288   CHECK_RTEMP:
0561 208618     289       jb RTEMP_BUTTON, CHECK_RTEMP_END
0564 C002       289            push AR2
0566 7A32       289            mov R2, #50
0568 120039     289            lcall ?Wait_Milli_Seconds
056B D002       289            pop AR2 ; de-bounce
056D 20860C     289       jb RTEMP_BUTTON, CHECK_RTEMP_END
0570 3086FD     289       jnb RTEMP_BUTTON, $
0573 208104     289       jb SHIFT_BUTTON, skip22b
0576 1536       289       dec Temp_refl
0578 8002       289       sjmp skip22a
057A            289       skip22b:
057A 0536       289       inc Temp_refl
057C            289       skip22a:
057C            290   CHECK_RTEMP_END:
057C 22         291   ret
057D            292   
057D            293   CHECK_POWER:
057D            294   
057D 20C518     295       jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
0580 C002       296            push AR2
0582 7A32       296            mov R2, #50
0584 120039     296            lcall ?Wait_Milli_Seconds
0587 D002       296            pop AR2 ; debounce time
0589 20C50C     297            jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
058C 30C5FD     298            jnb POWER_BUTTON, $ ; loop while the button is pressed
058F 754F00     299       mov pwm_ratio+0, #low(0)
0592 755000     300            mov pwm_ratio+1, #high(0)
0595 120FD0     301       lcall OFF_STATE
0598            302   
0598            303   CHECK_POWER_END:
0598 22         304   ret
0599            305   
0599            306   CHECK_K_OR_C:
0599            307   
0599 20860F     308       jb RTEMP_BUTTON, CHECK_K_OR_C_END ; if button not pressed, stop checking
059C C002       309            push AR2
059E 7A32       309            mov R2, #50
05A0 120039     309            lcall ?Wait_Milli_Seconds
05A3 D002       309            pop AR2 ; debounce time
05A5 208603     310            jb RTEMP_BUTTON, CHECK_K_OR_C_END ; if button not pressed, stop checking
05A8 3086FD     311            jnb RTEMP_BUTTON, $ ; loop while the button is pressed
05AB            312       
05AB            313       ;mov a, K_or_C
05AB            314       ;anl a,
05AB            315       ;anl a, #00000001B  ; We need only the two least significant bits
05AB            316   
05AB            317   
05AB            318   CHECK_K_OR_C_END:
05AB 22         319   ret
05AC            320   
05AC            321   ; Playback MACRO for sound --------------------------------------------------
05AC            322   
                323   PLAYBACK_TEMP MAC
                324       ; ***play audio***
                325       ;cjne sound_flag, #0, $
                326       
                327       lcall Wait_Half_Second
                328       clr TR1 ; Stop Timer 1 ISR from playing previous request
                329       setb FLASH_CE
                330       ;setb sound_flag ; sound starts
                331       clr SPEAKER ; Turn off speaker
                332       clr FLASH_CE ; Enable SPI Flash
                333       mov a, #READ_BYTES
                334       lcall Send_SPI
                335       ; Set the initial position in memory where to start playing
                336       
                337       mov a, %0 ; change initial position
                338       lcall Send_SPI
                339       mov a, %1 ; next memory position
                340       lcall Send_SPI
                341       mov a, %2 ; next memory position
                342       lcall Send_SPI
                343       mov a, %0 ; request first byte to send to DAC
                344       lcall Send_SPI
                345       
                346       ; How many bytes to play?
                347       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
                348       mov w+1, %3 ; Load the middle byte of the number of bytes to play
                349       mov w+0, %4 ; Load the low byte of the number of bytes to play
                350       
                351       
                352       setb SPEAKER ;Turn on speaker
                353       setb TR1 ;Start playback by enabling Timer1
                354       ;clr sound_flag ; sound ends
                355   ENDMAC
05AC            356   
05AC            357   
05AC            358   
05AC            359   ;**SOUND STUFF---------------------------------------------------------------
05AC            360   
05AC            361   SOUND_FSM:
05AC            362   state_0_sound:
05AC            363   ;check if 5 seconds has passed, if yes go to state 1, if no exit function 
05AC 300104     364       jnb five_seconds_flag, Sound_ret
05AF C201       365       clr five_seconds_flag
05B1 8001       366       sjmp state_1_sound
05B3            367   Sound_ret:
05B3 22         368       ret
05B4            369   
05B4            370   state_1_sound:
05B4            371   ; check if temp is greater than or equal to 100, if yes go to state 2
05B4            372   ; check if temp is less than 100, if yes go to state 4
05B4 E53B       373       mov a, Temp_oven
05B6 9464       374       subb a, #100
05B8 5002       375       jnc state_2_sound_hop
05BA 4002       376       jc state_4_sound_hop
05BC            377   
05BC            378       state_2_sound_hop:
05BC 8003       379           sjmp state_2_sound
05BE            380   
05BE            381       state_4_sound_hop:
05BE 0206BA     382           ljmp state_4_sound
05C1            383   
05C1            384   state_2_sound:
05C1            385   ;divide temp by 100, if it is 1 play sound: "100", if it is 2 play sound: "200"
05C1            386   ; go to state_3_sound
05C1 75F064     387       mov b, #100
05C4 E53B       388       mov a, Temp_oven
05C6 84         389       div ab
05C7 9401       390       subb a, #1
05C9 600A       391       jz play_sound_100
05CB            392   
05CB 75F064     393       mov b, #100
05CE E53B       394       mov a, Temp_oven
05D0 84         395       div ab
05D1 9402       396       subb a, #2
05D3 6065       397       jz play_sound_200
05D5            398      
05D5            399       play_sound_100: 
05D5            400       ; ***play audio***
05D5            400       ;cjne sound_flag, #0, $
05D5            400       
05D5 1210BD     400       lcall Wait_Half_Second
05D8 C28E       400       clr TR1 ; Stop Timer 1 ISR from playing previous request
05DA D2A5       400       setb FLASH_CE
05DC            400       ;setb sound_flag ; sound starts
05DC C2A6       400       clr SPEAKER ; Turn off speaker
05DE C2A5       400       clr FLASH_CE ; Enable SPI Flash
05E0 7403       400       mov a, #READ_BYTES
05E2 120494     400       lcall Send_SPI
05E5            400       ; Set the initial position in memory where to start playing
05E5            400       
05E5 7401       400       mov a, #0x01 ; change initial position
05E7 120494     400       lcall Send_SPI
05EA 7493       400       mov a, #0x93 ; next memory position
05EC 120494     400       lcall Send_SPI
05EF 7484       400       mov a, #0x84 ; next memory position
05F1 120494     400       lcall Send_SPI
05F4 7401       400       mov a, #0x01 ; request first byte to send to DAC
05F6 120494     400       lcall Send_SPI
05F9            400       
05F9            400       ; How many bytes to play?
05F9 754E00     400       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
05FC 754D36     400       mov w+1, #0x36 ; Load the middle byte of the number of bytes to play
05FF 754CB0     400       mov w+0, #0xb0 ; Load the low byte of the number of bytes to play
0602            400       
0602            400       
0602 D2A6       400       setb SPEAKER ;Turn on speaker
0604 D28E       400       setb TR1 ;Start playback by enabling Timer1
0606            400       ;clr sound_flag ; sound ends ;one
0606            401       ; ***play audio***
0606            401       ;cjne sound_flag, #0, $
0606            401       
0606 1210BD     401       lcall Wait_Half_Second
0609 C28E       401       clr TR1 ; Stop Timer 1 ISR from playing previous request
060B D2A5       401       setb FLASH_CE
060D            401       ;setb sound_flag ; sound starts
060D C2A6       401       clr SPEAKER ; Turn off speaker
060F C2A5       401       clr FLASH_CE ; Enable SPI Flash
0611 7403       401       mov a, #READ_BYTES
0613 120494     401       lcall Send_SPI
0616            401       ; Set the initial position in memory where to start playing
0616            401       
0616 7405       401       mov a, #0x05 ; change initial position
0618 120494     401       lcall Send_SPI
061B 7409       401       mov a, #0x09 ; next memory position
061D 120494     401       lcall Send_SPI
0620 7410       401       mov a, #0x10 ; next memory position
0622 120494     401       lcall Send_SPI
0625 7405       401       mov a, #0x05 ; request first byte to send to DAC
0627 120494     401       lcall Send_SPI
062A            401       
062A            401       ; How many bytes to play?
062A 754E00     401       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
062D 754D27     401       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0630 754C10     401       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0633            401       
0633            401       
0633 D2A6       401       setb SPEAKER ;Turn on speaker
0635 D28E       401       setb TR1 ;Start playback by enabling Timer1
0637            401       ;clr sound_flag ; sound ends ;hundred
0637 02069F     402           ljmp state_3_sound
063A            403   
063A            404       play_sound_200:
063A            405       ; ***play audio***
063A            405       ;cjne sound_flag, #0, $
063A            405       
063A 1210BD     405       lcall Wait_Half_Second
063D C28E       405       clr TR1 ; Stop Timer 1 ISR from playing previous request
063F D2A5       405       setb FLASH_CE
0641            405       ;setb sound_flag ; sound starts
0641 C2A6       405       clr SPEAKER ; Turn off speaker
0643 C2A5       405       clr FLASH_CE ; Enable SPI Flash
0645 7403       405       mov a, #READ_BYTES
0647 120494     405       lcall Send_SPI
064A            405       ; Set the initial position in memory where to start playing
064A            405       
064A 7401       405       mov a, #0x01 ; change initial position
064C 120494     405       lcall Send_SPI
064F 74C7       405       mov a, #0xc7 ; next memory position
0651 120494     405       lcall Send_SPI
0654 7414       405       mov a, #0x14 ; next memory position
0656 120494     405       lcall Send_SPI
0659 7401       405       mov a, #0x01 ; request first byte to send to DAC
065B 120494     405       lcall Send_SPI
065E            405       
065E            405       ; How many bytes to play?
065E 754E00     405       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0661 754D13     405       mov w+1, #0x13 ; Load the middle byte of the number of bytes to play
0664 754C88     405       mov w+0, #0x88 ; Load the low byte of the number of bytes to play
0667            405       
0667            405       
0667 D2A6       405       setb SPEAKER ;Turn on speaker
0669 D28E       405       setb TR1 ;Start playback by enabling Timer1
066B            405       ;clr sound_flag ; sound ends ;two
066B            406       ; ***play audio***
066B            406       ;cjne sound_flag, #0, $
066B            406       
066B 1210BD     406       lcall Wait_Half_Second
066E C28E       406       clr TR1 ; Stop Timer 1 ISR from playing previous request
0670 D2A5       406       setb FLASH_CE
0672            406       ;setb sound_flag ; sound starts
0672 C2A6       406       clr SPEAKER ; Turn off speaker
0674 C2A5       406       clr FLASH_CE ; Enable SPI Flash
0676 7403       406       mov a, #READ_BYTES
0678 120494     406       lcall Send_SPI
067B            406       ; Set the initial position in memory where to start playing
067B            406       
067B 7405       406       mov a, #0x05 ; change initial position
067D 120494     406       lcall Send_SPI
0680 7409       406       mov a, #0x09 ; next memory position
0682 120494     406       lcall Send_SPI
0685 7410       406       mov a, #0x10 ; next memory position
0687 120494     406       lcall Send_SPI
068A 7405       406       mov a, #0x05 ; request first byte to send to DAC
068C 120494     406       lcall Send_SPI
068F            406       
068F            406       ; How many bytes to play?
068F 754E00     406       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0692 754D27     406       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0695 754C10     406       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0698            406       
0698            406       
0698 D2A6       406       setb SPEAKER ;Turn on speaker
069A D28E       406       setb TR1 ;Start playback by enabling Timer1
069C            406       ;clr sound_flag ; sound ends ;hundred
069C 02069F     407           ljmp state_3_sound
069F            408   
069F            409   state_3_sound:
069F            410   ; check remainder of temp, if it is 0, exit
069F            411   ; if not 0, go to state_4_sound
069F            412   
069F            413   
069F 75F064     414       mov b, #100
06A2 E53B       415       mov a, Temp_oven
06A4 95F0       416       subb a, b
06A6 E5F0       417       mov a, b
06A8 600D       418       jz state_3_sound_hop
06AA            419       
06AA 75F0C8     420       mov b, #200
06AD E53B       421       mov a, Temp_oven
06AF 95F0       422       subb a, b
06B1 E5F0       423       mov a, b
06B3 6002       424       jz state_3_sound_hop
06B5            425   
06B5 8003       426       sjmp state_4_sound
06B7            427   
06B7            428       state_3_sound_hop:
06B7 0205B3     429           ljmp Sound_ret
06BA            430   
06BA            431   state_4_sound:
06BA            432   ; if T % 100 greater or equal to 20, go to state_5_sound,
06BA 75F064     433       mov b, #100
06BD E53B       434       mov a, Temp_oven
06BF 84         435       div ab
06C0            436       ;mov R0, b
06C0 E5F0       437       mov a, b 
06C2            438   
06C2            439   
06C2 9414       440       subb a, #20
06C4 5027       441       jnc state_5_sound
06C6 6025       442       jz state_5_sound
06C8 E4         443       clr a
06C9            444   ; if T % 100 is less than 10, go to state_6_sound
06C9 75F064     445       mov b, #100
06CC E53B       446       mov a, Temp_oven
06CE 84         447       div ab
06CF E5F0       448       mov a, b
06D1 940A       449       subb a, #10
06D3 4015       450       jc state_6_sound_hop0
06D5            451       
06D5            452       ;mov a, b
06D5            453       
06D5            454       ; ubb a, #0
06D5            455       ;jc state_6_sound_hop0
06D5            456       ;clr a
06D5            457   ; if T % 100 is greater than or equal to 10 and less than 20, go to state_7_sound
06D5            458   
06D5 75F064     459       mov b, #100
06D8 E53B       460       mov a, Temp_oven
06DA 84         461       div ab
06DB E5F0       462       mov a, b
06DD 940A       463       subb a, #10
06DF 6000       464       jz and_branch
06E1            465   
06E1            466       and_branch:
06E1 E5F0       467           mov a, b
06E3 9414       468           subb a, #20
06E5 4000       469           jc state_7_sound_hop0
06E7            470       
06E7            471       state_7_sound_hop0:
06E7 020AAE     472           ljmp state_7_sound
06EA            473   
06EA            474       state_6_sound_hop0:
06EA 0208AE     475           ljmp state_6_sound
06ED            476       
06ED            477   
06ED            478   state_5_sound:
06ED            479   ; play number from 20 to 90 in decades (20, 30, 40, 50, 60, 70, 80, 90), based off remainder from temp divided by 100
06ED            480   ; if (T % 100) % 10 is not equal to 0, go to state_6_sound
06ED            481   ; if (T % 100) % 10 is equal to 0, go to state_8_sound
06ED            482   
06ED            483       play_sound:
06ED            484           ;ljmp PLAYBACK_TEMP
06ED E53B       485           mov a, Temp_oven
06EF 75F064     486           mov b, #100
06F2 84         487           div ab
06F3 E5F0       488           mov a, b
06F5 75F00A     489           mov b, #10
06F8 84         490           div ab
06F9 B40234     491           cjne a, #2, play_30
06FC            492           ;mov    
06FC            493   
06FC            494           play_20:
06FC            495       ; ***play audio***
06FC            495       ;cjne sound_flag, #0, $
06FC            495       
06FC 1210BD     495       lcall Wait_Half_Second
06FF C28E       495       clr TR1 ; Stop Timer 1 ISR from playing previous request
0701 D2A5       495       setb FLASH_CE
0703            495       ;setb sound_flag ; sound starts
0703 C2A6       495       clr SPEAKER ; Turn off speaker
0705 C2A5       495       clr FLASH_CE ; Enable SPI Flash
0707 7403       495       mov a, #READ_BYTES
0709 120494     495       lcall Send_SPI
070C            495       ; Set the initial position in memory where to start playing
070C            495       
070C 7403       495       mov a, #0x03 ; change initial position
070E 120494     495       lcall Send_SPI
0711 74EF       495       mov a, #0xef ; next memory position
0713 120494     495       lcall Send_SPI
0716 74D0       495       mov a, #0xd0 ; next memory position
0718 120494     495       lcall Send_SPI
071B 7403       495       mov a, #0x03 ; request first byte to send to DAC
071D 120494     495       lcall Send_SPI
0720            495       
0720            495       ; How many bytes to play?
0720 754E00     495       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0723 754D27     495       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0726 754C10     495       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0729            495       
0729            495       
0729 D2A6       495       setb SPEAKER ;Turn on speaker
072B D28E       495       setb TR1 ;Start playback by enabling Timer1
072D            495       ;clr sound_flag ; sound ends
072D            496               ;lcall Wait_One_Second
072D 0208AB     497               ljmp state_6_sound_hop1
0730            498   
0730            499           play_30:
0730            500               
0730 B40334     501               cjne a, #3, play_40   
0733            502       ; ***play audio***
0733            502       ;cjne sound_flag, #0, $
0733            502       
0733 1210BD     502       lcall Wait_Half_Second
0736 C28E       502       clr TR1 ; Stop Timer 1 ISR from playing previous request
0738 D2A5       502       setb FLASH_CE
073A            502       ;setb sound_flag ; sound starts
073A C2A6       502       clr SPEAKER ; Turn off speaker
073C C2A5       502       clr FLASH_CE ; Enable SPI Flash
073E 7403       502       mov a, #READ_BYTES
0740 120494     502       lcall Send_SPI
0743            502       ; Set the initial position in memory where to start playing
0743            502       
0743 7404       502       mov a, #0x04 ; change initial position
0745 120494     502       lcall Send_SPI
0748 7416       502       mov a, #0x16 ; next memory position
074A 120494     502       lcall Send_SPI
074D 74E0       502       mov a, #0xe0 ; next memory position
074F 120494     502       lcall Send_SPI
0752 7404       502       mov a, #0x04 ; request first byte to send to DAC
0754 120494     502       lcall Send_SPI
0757            502       
0757            502       ; How many bytes to play?
0757 754E00     502       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
075A 754D23     502       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
075D 754C28     502       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0760            502       
0760            502       
0760 D2A6       502       setb SPEAKER ;Turn on speaker
0762 D28E       502       setb TR1 ;Start playback by enabling Timer1
0764            502       ;clr sound_flag ; sound ends
0764 0208AB     503               ljmp state_6_sound_hop1
0767            504   
0767            505           play_40:
0767            506               
0767 B40434     507               cjne a, #4, play_50  
076A            508       ; ***play audio***
076A            508       ;cjne sound_flag, #0, $
076A            508       
076A 1210BD     508       lcall Wait_Half_Second
076D C28E       508       clr TR1 ; Stop Timer 1 ISR from playing previous request
076F D2A5       508       setb FLASH_CE
0771            508       ;setb sound_flag ; sound starts
0771 C2A6       508       clr SPEAKER ; Turn off speaker
0773 C2A5       508       clr FLASH_CE ; Enable SPI Flash
0775 7403       508       mov a, #READ_BYTES
0777 120494     508       lcall Send_SPI
077A            508       ; Set the initial position in memory where to start playing
077A            508       
077A 7404       508       mov a, #0x04 ; change initial position
077C 120494     508       lcall Send_SPI
077F 743D       508       mov a, #0x3d ; next memory position
0781 120494     508       lcall Send_SPI
0784 74F0       508       mov a, #0xf0 ; next memory position
0786 120494     508       lcall Send_SPI
0789 7404       508       mov a, #0x04 ; request first byte to send to DAC
078B 120494     508       lcall Send_SPI
078E            508       
078E            508       ; How many bytes to play?
078E 754E00     508       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0791 754D1F     508       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0794 754C40     508       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0797            508       
0797            508       
0797 D2A6       508       setb SPEAKER ;Turn on speaker
0799 D28E       508       setb TR1 ;Start playback by enabling Timer1
079B            508       ;clr sound_flag ; sound ends
079B 0208AB     509               ljmp state_6_sound_hop1
079E            510   
079E            511           play_50:
079E            512              
079E B40534     513               cjne a, #5, play_60  
07A1            514       ; ***play audio***
07A1            514       ;cjne sound_flag, #0, $
07A1            514       
07A1 1210BD     514       lcall Wait_Half_Second
07A4 C28E       514       clr TR1 ; Stop Timer 1 ISR from playing previous request
07A6 D2A5       514       setb FLASH_CE
07A8            514       ;setb sound_flag ; sound starts
07A8 C2A6       514       clr SPEAKER ; Turn off speaker
07AA C2A5       514       clr FLASH_CE ; Enable SPI Flash
07AC 7403       514       mov a, #READ_BYTES
07AE 120494     514       lcall Send_SPI
07B1            514       ; Set the initial position in memory where to start playing
07B1            514       
07B1 7404       514       mov a, #0x04 ; change initial position
07B3 120494     514       lcall Send_SPI
07B6 7451       514       mov a, #0x51 ; next memory position
07B8 120494     514       lcall Send_SPI
07BB 7478       514       mov a, #0x78 ; next memory position
07BD 120494     514       lcall Send_SPI
07C0 7404       514       mov a, #0x04 ; request first byte to send to DAC
07C2 120494     514       lcall Send_SPI
07C5            514       
07C5            514       ; How many bytes to play?
07C5 754E00     514       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
07C8 754D23     514       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
07CB 754C28     514       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
07CE            514       
07CE            514       
07CE D2A6       514       setb SPEAKER ;Turn on speaker
07D0 D28E       514       setb TR1 ;Start playback by enabling Timer1
07D2            514       ;clr sound_flag ; sound ends
07D2 0208AB     515               ljmp state_6_sound_hop1
07D5            516   
07D5            517           play_60:
07D5            518               
07D5 B40634     519               cjne a, #6, play_70  
07D8            520       ; ***play audio***
07D8            520       ;cjne sound_flag, #0, $
07D8            520       
07D8 1210BD     520       lcall Wait_Half_Second
07DB C28E       520       clr TR1 ; Stop Timer 1 ISR from playing previous request
07DD D2A5       520       setb FLASH_CE
07DF            520       ;setb sound_flag ; sound starts
07DF C2A6       520       clr SPEAKER ; Turn off speaker
07E1 C2A5       520       clr FLASH_CE ; Enable SPI Flash
07E3 7403       520       mov a, #READ_BYTES
07E5 120494     520       lcall Send_SPI
07E8            520       ; Set the initial position in memory where to start playing
07E8            520       
07E8 7404       520       mov a, #0x04 ; change initial position
07EA 120494     520       lcall Send_SPI
07ED 7474       520       mov a, #0x74 ; next memory position
07EF 120494     520       lcall Send_SPI
07F2 74A0       520       mov a, #0xa0 ; next memory position
07F4 120494     520       lcall Send_SPI
07F7 7404       520       mov a, #0x04 ; request first byte to send to DAC
07F9 120494     520       lcall Send_SPI
07FC            520       
07FC            520       ; How many bytes to play?
07FC 754E00     520       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
07FF 754D27     520       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0802 754C10     520       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0805            520       
0805            520       
0805 D2A6       520       setb SPEAKER ;Turn on speaker
0807 D28E       520       setb TR1 ;Start playback by enabling Timer1
0809            520       ;clr sound_flag ; sound ends
0809 0208AB     521               ljmp state_6_sound_hop1
080C            522   
080C            523           play_70:
080C            524              
080C B40734     525               cjne a, #7, play_80  
080F            526       ; ***play audio***
080F            526       ;cjne sound_flag, #0, $
080F            526       
080F 1210BD     526       lcall Wait_Half_Second
0812 C28E       526       clr TR1 ; Stop Timer 1 ISR from playing previous request
0814 D2A5       526       setb FLASH_CE
0816            526       ;setb sound_flag ; sound starts
0816 C2A6       526       clr SPEAKER ; Turn off speaker
0818 C2A5       526       clr FLASH_CE ; Enable SPI Flash
081A 7403       526       mov a, #READ_BYTES
081C 120494     526       lcall Send_SPI
081F            526       ; Set the initial position in memory where to start playing
081F            526       
081F 7404       526       mov a, #0x04 ; change initial position
0821 120494     526       lcall Send_SPI
0824 749B       526       mov a, #0x9b ; next memory position
0826 120494     526       lcall Send_SPI
0829 74B0       526       mov a, #0xb0 ; next memory position
082B 120494     526       lcall Send_SPI
082E 7404       526       mov a, #0x04 ; request first byte to send to DAC
0830 120494     526       lcall Send_SPI
0833            526       
0833            526       ; How many bytes to play?
0833 754E00     526       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0836 754D32     526       mov w+1, #0x32 ; Load the middle byte of the number of bytes to play
0839 754CC8     526       mov w+0, #0xc8 ; Load the low byte of the number of bytes to play
083C            526       
083C            526       
083C D2A6       526       setb SPEAKER ;Turn on speaker
083E D28E       526       setb TR1 ;Start playback by enabling Timer1
0840            526       ;clr sound_flag ; sound ends
0840 0208AB     527               ljmp state_6_sound_hop1
0843            528   
0843            529           play_80:
0843            530               
0843 B40834     531               cjne a, #8, play_90  
0846            532       ; ***play audio***
0846            532       ;cjne sound_flag, #0, $
0846            532       
0846 1210BD     532       lcall Wait_Half_Second
0849 C28E       532       clr TR1 ; Stop Timer 1 ISR from playing previous request
084B D2A5       532       setb FLASH_CE
084D            532       ;setb sound_flag ; sound starts
084D C2A6       532       clr SPEAKER ; Turn off speaker
084F C2A5       532       clr FLASH_CE ; Enable SPI Flash
0851 7403       532       mov a, #READ_BYTES
0853 120494     532       lcall Send_SPI
0856            532       ; Set the initial position in memory where to start playing
0856            532       
0856 7404       532       mov a, #0x04 ; change initial position
0858 120494     532       lcall Send_SPI
085B 74C6       532       mov a, #0xc6 ; next memory position
085D 120494     532       lcall Send_SPI
0860 74A8       532       mov a, #0xa8 ; next memory position
0862 120494     532       lcall Send_SPI
0865 7404       532       mov a, #0x04 ; request first byte to send to DAC
0867 120494     532       lcall Send_SPI
086A            532       
086A            532       ; How many bytes to play?
086A 754E00     532       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
086D 754D23     532       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
0870 754C28     532       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0873            532       
0873            532       
0873 D2A6       532       setb SPEAKER ;Turn on speaker
0875 D28E       532       setb TR1 ;Start playback by enabling Timer1
0877            532       ;clr sound_flag ; sound ends
0877 0208AB     533               ljmp state_6_sound_hop1
087A            534   
087A            535           play_90:
087A            536       ; ***play audio***
087A            536       ;cjne sound_flag, #0, $
087A            536       
087A 1210BD     536       lcall Wait_Half_Second
087D C28E       536       clr TR1 ; Stop Timer 1 ISR from playing previous request
087F D2A5       536       setb FLASH_CE
0881            536       ;setb sound_flag ; sound starts
0881 C2A6       536       clr SPEAKER ; Turn off speaker
0883 C2A5       536       clr FLASH_CE ; Enable SPI Flash
0885 7403       536       mov a, #READ_BYTES
0887 120494     536       lcall Send_SPI
088A            536       ; Set the initial position in memory where to start playing
088A            536       
088A 7404       536       mov a, #0x04 ; change initial position
088C 120494     536       lcall Send_SPI
088F 74ED       536       mov a, #0xed ; next memory position
0891 120494     536       lcall Send_SPI
0894 74B8       536       mov a, #0xb8 ; next memory position
0896 120494     536       lcall Send_SPI
0899 7404       536       mov a, #0x04 ; request first byte to send to DAC
089B 120494     536       lcall Send_SPI
089E            536       
089E            536       ; How many bytes to play?
089E 754E00     536       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
08A1 754D1F     536       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
08A4 754C40     536       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
08A7            536       
08A7            536       
08A7 D2A6       536       setb SPEAKER ;Turn on speaker
08A9 D28E       536       setb TR1 ;Start playback by enabling Timer1
08AB            536       ;clr sound_flag ; sound ends
08AB            537   
08AB            538       ;mov a, Temp_oven
08AB            539       ;mov b, #100 
08AB            540       ;div ab
08AB            541       ;mov a, b
08AB            542       ;mov b, #10
08AB            543       ;div ab
08AB            544       ;mov a, b
08AB            545       ;jnz state_6_sound_hop1
08AB            546       
08AB            547       ;jz play_sound
08AB            548       
08AB            549       ;lcall Wait_One_Second
08AB            550       ;lcall Wait_One_Second
08AB            551       ;lcall Wait_One_Second
08AB            552   
08AB            553   
08AB            554       state_6_sound_hop1:
08AB 0208AE     555           ljmp state_6_sound
08AE            556           
08AE            557       ;state_8_hop0:
08AE            558           ;ljmp state_6_sound ;state_8_sound
08AE            559   
08AE            560   
08AE            561   state_6_sound:
08AE            562   ; play 1 - 9
08AE            563       ;ljmp PLAYBACK_TEMP
08AE 75F064     564       mov b, #100
08B1 E53B       565       mov a, Temp_oven
08B3 84         566       div ab
08B4 E5F0       567       mov a, b
08B6 75F00A     568       mov b, #10
08B9 84         569       div ab
08BA E5F0       570       mov a, b
08BC            571       
08BC B40003     572       cjne a, #0x00, play_1
08BF 020AAB     573       ljmp state_8_hop1
08C2            574   
08C2            575       play_1:
08C2 B40134     576           cjne a, #0x01, play_2
08C5            577       ; ***play audio***
08C5            577       ;cjne sound_flag, #0, $
08C5            577       
08C5 1210BD     577       lcall Wait_Half_Second
08C8 C28E       577       clr TR1 ; Stop Timer 1 ISR from playing previous request
08CA D2A5       577       setb FLASH_CE
08CC            577       ;setb sound_flag ; sound starts
08CC C2A6       577       clr SPEAKER ; Turn off speaker
08CE C2A5       577       clr FLASH_CE ; Enable SPI Flash
08D0 7403       577       mov a, #READ_BYTES
08D2 120494     577       lcall Send_SPI
08D5            577       ; Set the initial position in memory where to start playing
08D5            577       
08D5 7401       577       mov a, #0x01 ; change initial position
08D7 120494     577       lcall Send_SPI
08DA 7493       577       mov a, #0x93 ; next memory position
08DC 120494     577       lcall Send_SPI
08DF 7484       577       mov a, #0x84 ; next memory position
08E1 120494     577       lcall Send_SPI
08E4 7401       577       mov a, #0x01 ; request first byte to send to DAC
08E6 120494     577       lcall Send_SPI
08E9            577       
08E9            577       ; How many bytes to play?
08E9 754E00     577       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
08EC 754D36     577       mov w+1, #0x36 ; Load the middle byte of the number of bytes to play
08EF 754CB0     577       mov w+0, #0xb0 ; Load the low byte of the number of bytes to play
08F2            577       
08F2            577       
08F2 D2A6       577       setb SPEAKER ;Turn on speaker
08F4 D28E       577       setb TR1 ;Start playback by enabling Timer1
08F6            577       ;clr sound_flag ; sound ends 
08F6 020AAB     578           ljmp state_8_hop1
08F9            579   
08F9            580       play_2:
08F9 B40234     581           cjne a, #0x02, play_3
08FC            582       ; ***play audio***
08FC            582       ;cjne sound_flag, #0, $
08FC            582       
08FC 1210BD     582       lcall Wait_Half_Second
08FF C28E       582       clr TR1 ; Stop Timer 1 ISR from playing previous request
0901 D2A5       582       setb FLASH_CE
0903            582       ;setb sound_flag ; sound starts
0903 C2A6       582       clr SPEAKER ; Turn off speaker
0905 C2A5       582       clr FLASH_CE ; Enable SPI Flash
0907 7403       582       mov a, #READ_BYTES
0909 120494     582       lcall Send_SPI
090C            582       ; Set the initial position in memory where to start playing
090C            582       
090C 7401       582       mov a, #0x01 ; change initial position
090E 120494     582       lcall Send_SPI
0911 74C7       582       mov a, #0xc7 ; next memory position
0913 120494     582       lcall Send_SPI
0916 7414       582       mov a, #0x14 ; next memory position
0918 120494     582       lcall Send_SPI
091B 7401       582       mov a, #0x01 ; request first byte to send to DAC
091D 120494     582       lcall Send_SPI
0920            582       
0920            582       ; How many bytes to play?
0920 754E00     582       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0923 754D13     582       mov w+1, #0x13 ; Load the middle byte of the number of bytes to play
0926 754C88     582       mov w+0, #0x88 ; Load the low byte of the number of bytes to play
0929            582       
0929            582       
0929 D2A6       582       setb SPEAKER ;Turn on speaker
092B D28E       582       setb TR1 ;Start playback by enabling Timer1
092D            582       ;clr sound_flag ; sound ends
092D 020AAB     583           ljmp state_8_hop1
0930            584   
0930            585       play_3:
0930 B40334     586           cjne a, #0x03, play_4
0933            587       ; ***play audio***
0933            587       ;cjne sound_flag, #0, $
0933            587       
0933 1210BD     587       lcall Wait_Half_Second
0936 C28E       587       clr TR1 ; Stop Timer 1 ISR from playing previous request
0938 D2A5       587       setb FLASH_CE
093A            587       ;setb sound_flag ; sound starts
093A C2A6       587       clr SPEAKER ; Turn off speaker
093C C2A5       587       clr FLASH_CE ; Enable SPI Flash
093E 7403       587       mov a, #READ_BYTES
0940 120494     587       lcall Send_SPI
0943            587       ; Set the initial position in memory where to start playing
0943            587       
0943 7401       587       mov a, #0x01 ; change initial position
0945 120494     587       lcall Send_SPI
0948 74D6       587       mov a, #0xd6 ; next memory position
094A 120494     587       lcall Send_SPI
094D 7468       587       mov a, #0x68 ; next memory position
094F 120494     587       lcall Send_SPI
0952 7401       587       mov a, #0x01 ; request first byte to send to DAC
0954 120494     587       lcall Send_SPI
0957            587       
0957            587       ; How many bytes to play?
0957 754E00     587       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
095A 754D23     587       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
095D 754C28     587       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0960            587       
0960            587       
0960 D2A6       587       setb SPEAKER ;Turn on speaker
0962 D28E       587       setb TR1 ;Start playback by enabling Timer1
0964            587       ;clr sound_flag ; sound ends
0964 020AAB     588           ljmp state_8_hop1
0967            589   
0967            590       play_4:
0967 B40434     591           cjne a, #0x04, play_5
096A            592       ; ***play audio***
096A            592       ;cjne sound_flag, #0, $
096A            592       
096A 1210BD     592       lcall Wait_Half_Second
096D C28E       592       clr TR1 ; Stop Timer 1 ISR from playing previous request
096F D2A5       592       setb FLASH_CE
0971            592       ;setb sound_flag ; sound starts
0971 C2A6       592       clr SPEAKER ; Turn off speaker
0973 C2A5       592       clr FLASH_CE ; Enable SPI Flash
0975 7403       592       mov a, #READ_BYTES
0977 120494     592       lcall Send_SPI
097A            592       ; Set the initial position in memory where to start playing
097A            592       
097A 7401       592       mov a, #0x01 ; change initial position
097C 120494     592       lcall Send_SPI
097F 74F4       592       mov a, #0xf4 ; next memory position
0981 120494     592       lcall Send_SPI
0984 7400       592       mov a, #0x00 ; next memory position
0986 120494     592       lcall Send_SPI
0989 7401       592       mov a, #0x01 ; request first byte to send to DAC
098B 120494     592       lcall Send_SPI
098E            592       
098E            592       ; How many bytes to play?
098E 754E00     592       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0991 754D1B     592       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
0994 754C58     592       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
0997            592       
0997            592       
0997 D2A6       592       setb SPEAKER ;Turn on speaker
0999 D28E       592       setb TR1 ;Start playback by enabling Timer1
099B            592       ;clr sound_flag ; sound ends
099B 020AAB     593           ljmp state_8_hop1
099E            594   
099E            595       play_5:
099E B40534     596           cjne a, #0x05, play_6
09A1            597       ; ***play audio***
09A1            597       ;cjne sound_flag, #0, $
09A1            597       
09A1 1210BD     597       lcall Wait_Half_Second
09A4 C28E       597       clr TR1 ; Stop Timer 1 ISR from playing previous request
09A6 D2A5       597       setb FLASH_CE
09A8            597       ;setb sound_flag ; sound starts
09A8 C2A6       597       clr SPEAKER ; Turn off speaker
09AA C2A5       597       clr FLASH_CE ; Enable SPI Flash
09AC 7403       597       mov a, #READ_BYTES
09AE 120494     597       lcall Send_SPI
09B1            597       ; Set the initial position in memory where to start playing
09B1            597       
09B1 7402       597       mov a, #0x02 ; change initial position
09B3 120494     597       lcall Send_SPI
09B6 7407       597       mov a, #0x07 ; next memory position
09B8 120494     597       lcall Send_SPI
09BB 7488       597       mov a, #0x88 ; next memory position
09BD 120494     597       lcall Send_SPI
09C0 7402       597       mov a, #0x02 ; request first byte to send to DAC
09C2 120494     597       lcall Send_SPI
09C5            597       
09C5            597       ; How many bytes to play?
09C5 754E00     597       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
09C8 754D1B     597       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
09CB 754C58     597       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
09CE            597       
09CE            597       
09CE D2A6       597       setb SPEAKER ;Turn on speaker
09D0 D28E       597       setb TR1 ;Start playback by enabling Timer1
09D2            597       ;clr sound_flag ; sound ends
09D2 020AAB     598           ljmp state_8_hop1
09D5            599   
09D5            600       play_6:
09D5 B40634     601           cjne a, #0x06, play_7
09D8            602       ; ***play audio***
09D8            602       ;cjne sound_flag, #0, $
09D8            602       
09D8 1210BD     602       lcall Wait_Half_Second
09DB C28E       602       clr TR1 ; Stop Timer 1 ISR from playing previous request
09DD D2A5       602       setb FLASH_CE
09DF            602       ;setb sound_flag ; sound starts
09DF C2A6       602       clr SPEAKER ; Turn off speaker
09E1 C2A5       602       clr FLASH_CE ; Enable SPI Flash
09E3 7403       602       mov a, #READ_BYTES
09E5 120494     602       lcall Send_SPI
09E8            602       ; Set the initial position in memory where to start playing
09E8            602       
09E8 7402       602       mov a, #0x02 ; change initial position
09EA 120494     602       lcall Send_SPI
09ED 7426       602       mov a, #0x26 ; next memory position
09EF 120494     602       lcall Send_SPI
09F2 74C8       602       mov a, #0xc8 ; next memory position
09F4 120494     602       lcall Send_SPI
09F7 7402       602       mov a, #0x02 ; request first byte to send to DAC
09F9 120494     602       lcall Send_SPI
09FC            602       
09FC            602       ; How many bytes to play?
09FC 754E00     602       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
09FF 754D1F     602       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0A02 754C40     602       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0A05            602       
0A05            602       
0A05 D2A6       602       setb SPEAKER ;Turn on speaker
0A07 D28E       602       setb TR1 ;Start playback by enabling Timer1
0A09            602       ;clr sound_flag ; sound ends
0A09 020AAB     603           ljmp state_8_hop1
0A0C            604   
0A0C            605       play_7:
0A0C B40734     606           cjne a, #0x07, play_8
0A0F            607       ; ***play audio***
0A0F            607       ;cjne sound_flag, #0, $
0A0F            607       
0A0F 1210BD     607       lcall Wait_Half_Second
0A12 C28E       607       clr TR1 ; Stop Timer 1 ISR from playing previous request
0A14 D2A5       607       setb FLASH_CE
0A16            607       ;setb sound_flag ; sound starts
0A16 C2A6       607       clr SPEAKER ; Turn off speaker
0A18 C2A5       607       clr FLASH_CE ; Enable SPI Flash
0A1A 7403       607       mov a, #READ_BYTES
0A1C 120494     607       lcall Send_SPI
0A1F            607       ; Set the initial position in memory where to start playing
0A1F            607       
0A1F 7402       607       mov a, #0x02 ; change initial position
0A21 120494     607       lcall Send_SPI
0A24 7436       607       mov a, #0x36 ; next memory position
0A26 120494     607       lcall Send_SPI
0A29 7468       607       mov a, #0x68 ; next memory position
0A2B 120494     607       lcall Send_SPI
0A2E 7402       607       mov a, #0x02 ; request first byte to send to DAC
0A30 120494     607       lcall Send_SPI
0A33            607       
0A33            607       ; How many bytes to play?
0A33 754E00     607       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0A36 754D23     607       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
0A39 754C28     607       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0A3C            607       
0A3C            607       
0A3C D2A6       607       setb SPEAKER ;Turn on speaker
0A3E D28E       607       setb TR1 ;Start playback by enabling Timer1
0A40            607       ;clr sound_flag ; sound ends
0A40 020AAB     608           ljmp state_8_hop1
0A43            609   
0A43            610       play_8:
0A43 B40834     611           cjne a, #0x08, play_9
0A46            612       ; ***play audio***
0A46            612       ;cjne sound_flag, #0, $
0A46            612       
0A46 1210BD     612       lcall Wait_Half_Second
0A49 C28E       612       clr TR1 ; Stop Timer 1 ISR from playing previous request
0A4B D2A5       612       setb FLASH_CE
0A4D            612       ;setb sound_flag ; sound starts
0A4D C2A6       612       clr SPEAKER ; Turn off speaker
0A4F C2A5       612       clr FLASH_CE ; Enable SPI Flash
0A51 7403       612       mov a, #READ_BYTES
0A53 120494     612       lcall Send_SPI
0A56            612       ; Set the initial position in memory where to start playing
0A56            612       
0A56 7402       612       mov a, #0x02 ; change initial position
0A58 120494     612       lcall Send_SPI
0A5B 7457       612       mov a, #0x57 ; next memory position
0A5D 120494     612       lcall Send_SPI
0A60 749C       612       mov a, #0x9c ; next memory position
0A62 120494     612       lcall Send_SPI
0A65 7402       612       mov a, #0x02 ; request first byte to send to DAC
0A67 120494     612       lcall Send_SPI
0A6A            612       
0A6A            612       ; How many bytes to play?
0A6A 754E00     612       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0A6D 754D1B     612       mov w+1, #0x1b ; Load the middle byte of the number of bytes to play
0A70 754C58     612       mov w+0, #0x58 ; Load the low byte of the number of bytes to play
0A73            612       
0A73            612       
0A73 D2A6       612       setb SPEAKER ;Turn on speaker
0A75 D28E       612       setb TR1 ;Start playback by enabling Timer1
0A77            612       ;clr sound_flag ; sound ends
0A77 020AAB     613           ljmp state_8_hop1
0A7A            614   
0A7A            615       play_9:
0A7A            616       ; ***play audio***
0A7A            616       ;cjne sound_flag, #0, $
0A7A            616       
0A7A 1210BD     616       lcall Wait_Half_Second
0A7D C28E       616       clr TR1 ; Stop Timer 1 ISR from playing previous request
0A7F D2A5       616       setb FLASH_CE
0A81            616       ;setb sound_flag ; sound starts
0A81 C2A6       616       clr SPEAKER ; Turn off speaker
0A83 C2A5       616       clr FLASH_CE ; Enable SPI Flash
0A85 7403       616       mov a, #READ_BYTES
0A87 120494     616       lcall Send_SPI
0A8A            616       ; Set the initial position in memory where to start playing
0A8A            616       
0A8A 7402       616       mov a, #0x02 ; change initial position
0A8C 120494     616       lcall Send_SPI
0A8F 7469       616       mov a, #0x69 ; next memory position
0A91 120494     616       lcall Send_SPI
0A94 7430       616       mov a, #0x30 ; next memory position
0A96 120494     616       lcall Send_SPI
0A99 7402       616       mov a, #0x02 ; request first byte to send to DAC
0A9B 120494     616       lcall Send_SPI
0A9E            616       
0A9E            616       ; How many bytes to play?
0A9E 754E00     616       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0AA1 754D1F     616       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0AA4 754C40     616       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0AA7            616       
0AA7            616       
0AA7 D2A6       616       setb SPEAKER ;Turn on speaker
0AA9 D28E       616       setb TR1 ;Start playback by enabling Timer1
0AAB            616       ;clr sound_flag ; sound ends
0AAB            617   
0AAB            618   state_8_hop1:
0AAB            619   ; go to state_8_sound
0AAB 020CD9     620       ljmp state_8_sound
0AAE            621   
0AAE            622   
0AAE            623   state_7_sound:
0AAE            624   ; play 10 - 19
0AAE            625       ;ljmp PLAYBACK_TEMP
0AAE 75F064     626       mov b, #100
0AB1 E53B       627       mov a, Temp_oven
0AB3 84         628       div ab
0AB4 E5F0       629       mov a, b
0AB6 B40A34     630       cjne a, #0x0a, play_11
0AB9            631       
0AB9            632       ; ***play audio***
0AB9            632       ;cjne sound_flag, #0, $
0AB9            632       
0AB9 1210BD     632       lcall Wait_Half_Second
0ABC C28E       632       clr TR1 ; Stop Timer 1 ISR from playing previous request
0ABE D2A5       632       setb FLASH_CE
0AC0            632       ;setb sound_flag ; sound starts
0AC0 C2A6       632       clr SPEAKER ; Turn off speaker
0AC2 C2A5       632       clr FLASH_CE ; Enable SPI Flash
0AC4 7403       632       mov a, #READ_BYTES
0AC6 120494     632       lcall Send_SPI
0AC9            632       ; Set the initial position in memory where to start playing
0AC9            632       
0AC9 7402       632       mov a, #0x02 ; change initial position
0ACB 120494     632       lcall Send_SPI
0ACE 7484       632       mov a, #0x84 ; next memory position
0AD0 120494     632       lcall Send_SPI
0AD3 7488       632       mov a, #0x88 ; next memory position
0AD5 120494     632       lcall Send_SPI
0AD8 7402       632       mov a, #0x02 ; request first byte to send to DAC
0ADA 120494     632       lcall Send_SPI
0ADD            632       
0ADD            632       ; How many bytes to play?
0ADD 754E00     632       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0AE0 754D17     632       mov w+1, #0x17 ; Load the middle byte of the number of bytes to play
0AE3 754C70     632       mov w+0, #0x70 ; Load the low byte of the number of bytes to play
0AE6            632       
0AE6            632       
0AE6 D2A6       632       setb SPEAKER ;Turn on speaker
0AE8 D28E       632       setb TR1 ;Start playback by enabling Timer1
0AEA            632       ;clr sound_flag ; sound ends
0AEA 020CD6     633       ljmp state_8_hop2
0AED            634   
0AED            635       play_11:
0AED B40B34     636           cjne a, #0x0b, play_12
0AF0            637       ; ***play audio***
0AF0            637       ;cjne sound_flag, #0, $
0AF0            637       
0AF0 1210BD     637       lcall Wait_Half_Second
0AF3 C28E       637       clr TR1 ; Stop Timer 1 ISR from playing previous request
0AF5 D2A5       637       setb FLASH_CE
0AF7            637       ;setb sound_flag ; sound starts
0AF7 C2A6       637       clr SPEAKER ; Turn off speaker
0AF9 C2A5       637       clr FLASH_CE ; Enable SPI Flash
0AFB 7403       637       mov a, #READ_BYTES
0AFD 120494     637       lcall Send_SPI
0B00            637       ; Set the initial position in memory where to start playing
0B00            637       
0B00 7402       637       mov a, #0x02 ; change initial position
0B02 120494     637       lcall Send_SPI
0B05 749B       637       mov a, #0x9b ; next memory position
0B07 120494     637       lcall Send_SPI
0B0A 74F8       637       mov a, #0xf8 ; next memory position
0B0C 120494     637       lcall Send_SPI
0B0F 7402       637       mov a, #0x02 ; request first byte to send to DAC
0B11 120494     637       lcall Send_SPI
0B14            637       
0B14            637       ; How many bytes to play?
0B14 754E00     637       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0B17 754D1F     637       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0B1A 754C40     637       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0B1D            637       
0B1D            637       
0B1D D2A6       637       setb SPEAKER ;Turn on speaker
0B1F D28E       637       setb TR1 ;Start playback by enabling Timer1
0B21            637       ;clr sound_flag ; sound ends
0B21 020CD6     638           ljmp state_8_hop2
0B24            639   
0B24            640       play_12:
0B24 B40C34     641           cjne a, #0x0c, play_13
0B27            642       ; ***play audio***
0B27            642       ;cjne sound_flag, #0, $
0B27            642       
0B27 1210BD     642       lcall Wait_Half_Second
0B2A C28E       642       clr TR1 ; Stop Timer 1 ISR from playing previous request
0B2C D2A5       642       setb FLASH_CE
0B2E            642       ;setb sound_flag ; sound starts
0B2E C2A6       642       clr SPEAKER ; Turn off speaker
0B30 C2A5       642       clr FLASH_CE ; Enable SPI Flash
0B32 7403       642       mov a, #READ_BYTES
0B34 120494     642       lcall Send_SPI
0B37            642       ; Set the initial position in memory where to start playing
0B37            642       
0B37 7402       642       mov a, #0x02 ; change initial position
0B39 120494     642       lcall Send_SPI
0B3C 74B7       642       mov a, #0xb7 ; next memory position
0B3E 120494     642       lcall Send_SPI
0B41 7450       642       mov a, #0x50 ; next memory position
0B43 120494     642       lcall Send_SPI
0B46 7402       642       mov a, #0x02 ; request first byte to send to DAC
0B48 120494     642       lcall Send_SPI
0B4B            642       
0B4B            642       ; How many bytes to play?
0B4B 754E00     642       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0B4E 754D1F     642       mov w+1, #0x1f ; Load the middle byte of the number of bytes to play
0B51 754C40     642       mov w+0, #0x40 ; Load the low byte of the number of bytes to play
0B54            642       
0B54            642       
0B54 D2A6       642       setb SPEAKER ;Turn on speaker
0B56 D28E       642       setb TR1 ;Start playback by enabling Timer1
0B58            642       ;clr sound_flag ; sound ends
0B58 020CD6     643           ljmp state_8_hop2
0B5B            644   
0B5B            645       play_13:
0B5B B40D34     646           cjne a, #0x0d, play_14
0B5E            647       ; ***play audio***
0B5E            647       ;cjne sound_flag, #0, $
0B5E            647       
0B5E 1210BD     647       lcall Wait_Half_Second
0B61 C28E       647       clr TR1 ; Stop Timer 1 ISR from playing previous request
0B63 D2A5       647       setb FLASH_CE
0B65            647       ;setb sound_flag ; sound starts
0B65 C2A6       647       clr SPEAKER ; Turn off speaker
0B67 C2A5       647       clr FLASH_CE ; Enable SPI Flash
0B69 7403       647       mov a, #READ_BYTES
0B6B 120494     647       lcall Send_SPI
0B6E            647       ; Set the initial position in memory where to start playing
0B6E            647       
0B6E 7402       647       mov a, #0x02 ; change initial position
0B70 120494     647       lcall Send_SPI
0B73 74CE       647       mov a, #0xce ; next memory position
0B75 120494     647       lcall Send_SPI
0B78 74C0       647       mov a, #0xc0 ; next memory position
0B7A 120494     647       lcall Send_SPI
0B7D 7402       647       mov a, #0x02 ; request first byte to send to DAC
0B7F 120494     647       lcall Send_SPI
0B82            647       
0B82            647       ; How many bytes to play?
0B82 754E00     647       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0B85 754D2E     647       mov w+1, #0x2e ; Load the middle byte of the number of bytes to play
0B88 754CE0     647       mov w+0, #0xe0 ; Load the low byte of the number of bytes to play
0B8B            647       
0B8B            647       
0B8B D2A6       647       setb SPEAKER ;Turn on speaker
0B8D D28E       647       setb TR1 ;Start playback by enabling Timer1
0B8F            647       ;clr sound_flag ; sound ends
0B8F 020CD6     648           ljmp state_8_hop2
0B92            649   
0B92            650       play_14:
0B92 B40E34     651           cjne a, #0x0e, play_15
0B95            652       ; ***play audio***
0B95            652       ;cjne sound_flag, #0, $
0B95            652       
0B95 1210BD     652       lcall Wait_Half_Second
0B98 C28E       652       clr TR1 ; Stop Timer 1 ISR from playing previous request
0B9A D2A5       652       setb FLASH_CE
0B9C            652       ;setb sound_flag ; sound starts
0B9C C2A6       652       clr SPEAKER ; Turn off speaker
0B9E C2A5       652       clr FLASH_CE ; Enable SPI Flash
0BA0 7403       652       mov a, #READ_BYTES
0BA2 120494     652       lcall Send_SPI
0BA5            652       ; Set the initial position in memory where to start playing
0BA5            652       
0BA5 7402       652       mov a, #0x02 ; change initial position
0BA7 120494     652       lcall Send_SPI
0BAA 74F5       652       mov a, #0xf5 ; next memory position
0BAC 120494     652       lcall Send_SPI
0BAF 74D0       652       mov a, #0xd0 ; next memory position
0BB1 120494     652       lcall Send_SPI
0BB4 7402       652       mov a, #0x02 ; request first byte to send to DAC
0BB6 120494     652       lcall Send_SPI
0BB9            652       
0BB9            652       ; How many bytes to play?
0BB9 754E00     652       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0BBC 754D36     652       mov w+1, #0x36 ; Load the middle byte of the number of bytes to play
0BBF 754CB0     652       mov w+0, #0xb0 ; Load the low byte of the number of bytes to play
0BC2            652       
0BC2            652       
0BC2 D2A6       652       setb SPEAKER ;Turn on speaker
0BC4 D28E       652       setb TR1 ;Start playback by enabling Timer1
0BC6            652       ;clr sound_flag ; sound ends
0BC6 020CD6     653           ljmp state_8_hop2
0BC9            654   
0BC9            655       play_15:
0BC9 B40F34     656           cjne a, #0x0f, play_16
0BCC            657       ; ***play audio***
0BCC            657       ;cjne sound_flag, #0, $
0BCC            657       
0BCC 1210BD     657       lcall Wait_Half_Second
0BCF C28E       657       clr TR1 ; Stop Timer 1 ISR from playing previous request
0BD1 D2A5       657       setb FLASH_CE
0BD3            657       ;setb sound_flag ; sound starts
0BD3 C2A6       657       clr SPEAKER ; Turn off speaker
0BD5 C2A5       657       clr FLASH_CE ; Enable SPI Flash
0BD7 7403       657       mov a, #READ_BYTES
0BD9 120494     657       lcall Send_SPI
0BDC            657       ; Set the initial position in memory where to start playing
0BDC            657       
0BDC 7403       657       mov a, #0x03 ; change initial position
0BDE 120494     657       lcall Send_SPI
0BE1 7428       657       mov a, #0x28 ; next memory position
0BE3 120494     657       lcall Send_SPI
0BE6 7498       657       mov a, #0x98 ; next memory position
0BE8 120494     657       lcall Send_SPI
0BEB 7403       657       mov a, #0x03 ; request first byte to send to DAC
0BED 120494     657       lcall Send_SPI
0BF0            657       
0BF0            657       ; How many bytes to play?
0BF0 754E00     657       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0BF3 754D23     657       mov w+1, #0x23 ; Load the middle byte of the number of bytes to play
0BF6 754C28     657       mov w+0, #0x28 ; Load the low byte of the number of bytes to play
0BF9            657       
0BF9            657       
0BF9 D2A6       657       setb SPEAKER ;Turn on speaker
0BFB D28E       657       setb TR1 ;Start playback by enabling Timer1
0BFD            657       ;clr sound_flag ; sound ends
0BFD 020CD6     658           ljmp state_8_hop2
0C00            659   
0C00            660       play_16:
0C00 B41034     661           cjne a, #0x10, play_17
0C03            662       ; ***play audio***
0C03            662       ;cjne sound_flag, #0, $
0C03            662       
0C03 1210BD     662       lcall Wait_Half_Second
0C06 C28E       662       clr TR1 ; Stop Timer 1 ISR from playing previous request
0C08 D2A5       662       setb FLASH_CE
0C0A            662       ;setb sound_flag ; sound starts
0C0A C2A6       662       clr SPEAKER ; Turn off speaker
0C0C C2A5       662       clr FLASH_CE ; Enable SPI Flash
0C0E 7403       662       mov a, #READ_BYTES
0C10 120494     662       lcall Send_SPI
0C13            662       ; Set the initial position in memory where to start playing
0C13            662       
0C13 7403       662       mov a, #0x03 ; change initial position
0C15 120494     662       lcall Send_SPI
0C18 7447       662       mov a, #0x47 ; next memory position
0C1A 120494     662       lcall Send_SPI
0C1D 74D8       662       mov a, #0xd8 ; next memory position
0C1F 120494     662       lcall Send_SPI
0C22 7403       662       mov a, #0x03 ; request first byte to send to DAC
0C24 120494     662       lcall Send_SPI
0C27            662       
0C27            662       ; How many bytes to play?
0C27 754E00     662       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0C2A 754D32     662       mov w+1, #0x32 ; Load the middle byte of the number of bytes to play
0C2D 754CC8     662       mov w+0, #0xc8 ; Load the low byte of the number of bytes to play
0C30            662       
0C30            662       
0C30 D2A6       662       setb SPEAKER ;Turn on speaker
0C32 D28E       662       setb TR1 ;Start playback by enabling Timer1
0C34            662       ;clr sound_flag ; sound ends
0C34 020CD6     663           ljmp state_8_hop2
0C37            664   
0C37            665       play_17:
0C37 B41134     666           cjne a, #0x11, play_18
0C3A            667       ; ***play audio***
0C3A            667       ;cjne sound_flag, #0, $
0C3A            667       
0C3A 1210BD     667       lcall Wait_Half_Second
0C3D C28E       667       clr TR1 ; Stop Timer 1 ISR from playing previous request
0C3F D2A5       667       setb FLASH_CE
0C41            667       ;setb sound_flag ; sound starts
0C41 C2A6       667       clr SPEAKER ; Turn off speaker
0C43 C2A5       667       clr FLASH_CE ; Enable SPI Flash
0C45 7403       667       mov a, #READ_BYTES
0C47 120494     667       lcall Send_SPI
0C4A            667       ; Set the initial position in memory where to start playing
0C4A            667       
0C4A 7403       667       mov a, #0x03 ; change initial position
0C4C 120494     667       lcall Send_SPI
0C4F 7476       667       mov a, #0x76 ; next memory position
0C51 120494     667       lcall Send_SPI
0C54 74B8       667       mov a, #0xb8 ; next memory position
0C56 120494     667       lcall Send_SPI
0C59 7403       667       mov a, #0x03 ; request first byte to send to DAC
0C5B 120494     667       lcall Send_SPI
0C5E            667       
0C5E            667       ; How many bytes to play?
0C5E 754E00     667       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0C61 754D2E     667       mov w+1, #0x2e ; Load the middle byte of the number of bytes to play
0C64 754C20     667       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
0C67            667       
0C67            667       
0C67 D2A6       667       setb SPEAKER ;Turn on speaker
0C69 D28E       667       setb TR1 ;Start playback by enabling Timer1
0C6B            667       ;clr sound_flag ; sound ends
0C6B 020CD6     668           ljmp state_8_hop2
0C6E            669   
0C6E            670       play_18:
0C6E B41234     671           cjne a, #0x12, play_19
0C71            672       ; ***play audio***
0C71            672       ;cjne sound_flag, #0, $
0C71            672       
0C71 1210BD     672       lcall Wait_Half_Second
0C74 C28E       672       clr TR1 ; Stop Timer 1 ISR from playing previous request
0C76 D2A5       672       setb FLASH_CE
0C78            672       ;setb sound_flag ; sound starts
0C78 C2A6       672       clr SPEAKER ; Turn off speaker
0C7A C2A5       672       clr FLASH_CE ; Enable SPI Flash
0C7C 7403       672       mov a, #READ_BYTES
0C7E 120494     672       lcall Send_SPI
0C81            672       ; Set the initial position in memory where to start playing
0C81            672       
0C81 7403       672       mov a, #0x03 ; change initial position
0C83 120494     672       lcall Send_SPI
0C86 74A1       672       mov a, #0xa1 ; next memory position
0C88 120494     672       lcall Send_SPI
0C8B 74B0       672       mov a, #0xb0 ; next memory position
0C8D 120494     672       lcall Send_SPI
0C90 7403       672       mov a, #0x03 ; request first byte to send to DAC
0C92 120494     672       lcall Send_SPI
0C95            672       
0C95            672       ; How many bytes to play?
0C95 754E00     672       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0C98 754D27     672       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0C9B 754C10     672       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0C9E            672       
0C9E            672       
0C9E D2A6       672       setb SPEAKER ;Turn on speaker
0CA0 D28E       672       setb TR1 ;Start playback by enabling Timer1
0CA2            672       ;clr sound_flag ; sound ends
0CA2 020CD6     673           ljmp state_8_hop2
0CA5            674   
0CA5            675       play_19:
0CA5            676       ; ***play audio***
0CA5            676       ;cjne sound_flag, #0, $
0CA5            676       
0CA5 1210BD     676       lcall Wait_Half_Second
0CA8 C28E       676       clr TR1 ; Stop Timer 1 ISR from playing previous request
0CAA D2A5       676       setb FLASH_CE
0CAC            676       ;setb sound_flag ; sound starts
0CAC C2A6       676       clr SPEAKER ; Turn off speaker
0CAE C2A5       676       clr FLASH_CE ; Enable SPI Flash
0CB0 7403       676       mov a, #READ_BYTES
0CB2 120494     676       lcall Send_SPI
0CB5            676       ; Set the initial position in memory where to start playing
0CB5            676       
0CB5 7403       676       mov a, #0x03 ; change initial position
0CB7 120494     676       lcall Send_SPI
0CBA 74C8       676       mov a, #0xc8 ; next memory position
0CBC 120494     676       lcall Send_SPI
0CBF 74C0       676       mov a, #0xc0 ; next memory position
0CC1 120494     676       lcall Send_SPI
0CC4 7403       676       mov a, #0x03 ; request first byte to send to DAC
0CC6 120494     676       lcall Send_SPI
0CC9            676       
0CC9            676       ; How many bytes to play?
0CC9 754E00     676       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0CCC 754D27     676       mov w+1, #0x27 ; Load the middle byte of the number of bytes to play
0CCF 754C10     676       mov w+0, #0x10 ; Load the low byte of the number of bytes to play
0CD2            676       
0CD2            676       
0CD2 D2A6       676       setb SPEAKER ;Turn on speaker
0CD4 D28E       676       setb TR1 ;Start playback by enabling Timer1
0CD6            676       ;clr sound_flag ; sound ends
0CD6            677   
0CD6            678       state_8_hop2:
0CD6            679       ; go to state_8_sound
0CD6 020CD9     680           ljmp state_8_sound
0CD9            681   
0CD9            682   state_8_sound:
0CD9            683   ; go to state_0_sound
0CD9 0205B3     684       ljmp Sound_ret
0CDC            685   
0CDC            686   
0CDC            687   
0CDC            688   
0CDC            689   INI_PLAYBACK_TEMP:
0CDC            690       ; ****INITIALIZATION****
0CDC            691       ; Configure SPI pins and turn off speaker
0CDC            692            ;anl P2M0, #0b_1100_1110
0CDC 43CE90     693       orl P2M0, #0b_1001_0000
0CDF            694       ;orl P2M0, #0b_0011_0001
0CDF            695            ;orl P2M1, #0b_0011_0001
0CDF 43CF90     696       orl P2M1, #0b_1001_0000
0CE2 D2A1       697            setb MY_MISO_SOUND  ; Configured as input
0CE4 D2A5       698            setb FLASH_CE ; CS=1 for SPI flash memory
0CE6 C2A0       699            clr MY_SCLK_SOUND   ; Rest state of SCLK=0
0CE8 C2A6       700            clr SPEAKER   ; Turn off speaker.
0CEA            701            
0CEA            702            ; Configure timer 1
0CEA 53890F     703            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
0CED 438910     704            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
0CF0 758DFC     705            mov TH1, #high(TIMER1_RELOAD)
0CF3 758B8C     706            mov TL1, #low(TIMER1_RELOAD)
0CF6            707            ; Set autoreload value
0CF6 75F5FC     708            mov RH1, #high(TIMER1_RELOAD)
0CF9 75F38C     709            mov RL1, #low(TIMER1_RELOAD)
0CFC            710   
0CFC            711            ;Enable the timer and interrupts
0CFC D2AB       712       setb ET1  ; Enable timer 1 interrupt
0CFE D28E       713            setb TR1 ; Timer 1 is only enabled to play stored sound
0D00            714   
0D00            715            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
0D00 75A5A0     716            mov DADI, #0b_1010_0000 ; ACON=1
0D03 75A43A     717            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0D06 75AD80     718            mov DADH, #0x80 ; Middle of scale
0D09 75AC00     719            mov DADL, #0
0D0C 43A440     720            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
0D0F            721       check_DAC_init:
0D0F E5A4       722            mov a, DADC
0D11 20E6FB     723            jb acc.6, check_DAC_init ; Wait for DAC to finish
0D14            724            
0D14 22         725   ret
0D15            726   
0D15            727       
0D15            728   ;-------------------------------------------------------------------------------------------------------------------------------
0D15            729   ;***LCD FXNS
0D15            730   
                731   Display_lower_BCD mac
                732       push ar0
                733       mov r0, %0
                734       lcall ?Display_lower_BCD
                735       pop ar0
                736   endmac
0D15            737   
0D15            738   ?Display_lower_BCD:
0D15 C0E0       739       push acc
0D17            740       ; write least significant digit
0D17 E8         741       mov a, r0
0D18 540F       742       anl a, #0fh
0D1A 4430       743       orl a, #30h
0D1C 12007E     744       lcall ?WriteData
0D1F D0E0       745       pop acc
0D21 22         746   ret
0D22            747   
0D22            748   
0D22            749   SendToLCD:
0D22 75F064     750       mov b, #100
0D25 84         751       div ab
0D26 4430       752       orl a, #0x30h ; Convert hundreds to ASCII
0D28 12007E     753       lcall ?WriteData ; Send to LCD
0D2B E5F0       754       mov a, b    ; Remainder is in register b
0D2D 75F00A     755       mov b, #10
0D30 84         756       div ab
0D31 4430       757       orl a, #0x30h ; Convert tens to ASCII
0D33 12007E     758       lcall ?WriteData; Send to LCD
0D36 E5F0       759       mov a, b
0D38 4430       760       orl a, #0x30h ; Convert units to ASCII
0D3A 12007E     761       lcall ?WriteData; Send to LCD
0D3D 22         762   ret
0D3E            763   
0D3E            764   Initialize_State_Display:
0D3E            765   
0D3E            766       ;***clear the screen and set new display***
0D3E 7401       767            mov a, #0x01
0D40 120083     767            lcall ?WriteCommand
0D43 C002       768            push AR2
0D45 7A02       768            mov R2, #2
0D47 120039     768            lcall ?Wait_Milli_Seconds
0D4A D002       768            pop AR2
0D4C            769       
0D4C C0E0       770            push acc
0D4E 7401       770            mov a, #1
0D50 14         770            dec a
0D51 1200BF     770            lcall ?Set_Cursor_1 ; Select column and row
0D54 D0E0       770            pop acc
0D56 C083       771            push dph
0D58 C082       771            push dpl
0D5A C0E0       771            push acc
0D5C 900404     771            mov dptr, #time
0D5F 1200B2     771            lcall ?Send_Constant_String
0D62 D0E0       771            pop acc
0D64 D082       771            pop dpl
0D66 D083       771            pop dph
0D68            772            
0D68 C0E0       773            push acc
0D6A 7406       773            mov a, #6
0D6C 14         773            dec a
0D6D 1200BF     773            lcall ?Set_Cursor_1 ; Select column and row
0D70 D0E0       773            pop acc
0D72 C083       774            push dph
0D74 C082       774            push dpl
0D76 C0E0       774            push acc
0D78 900409     774            mov dptr, #colon
0D7B 1200B2     774            lcall ?Send_Constant_String
0D7E D0E0       774            pop acc
0D80 D082       774            pop dpl
0D82 D083       774            pop dph
0D84            775      
0D84 C0E0       776            push acc
0D86 740A       776            mov a, #10
0D88 14         776            dec a
0D89 1200BF     776            lcall ?Set_Cursor_1 ; Select column and row
0D8C D0E0       776            pop acc
0D8E C083       777            push dph
0D90 C082       777            push dpl
0D92 C0E0       777            push acc
0D94 90040B     777            mov dptr, #temp
0D97 1200B2     777            lcall ?Send_Constant_String
0D9A D0E0       777            pop acc
0D9C D082       777            pop dpl
0D9E D083       777            pop dph
0DA0            778       
0DA0 C0E0       779            push acc
0DA2 7401       779            mov a, #1
0DA4 14         779            dec a
0DA5 1200BD     779            lcall ?Set_Cursor_2 ; Select column and row
0DA8 D0E0       779            pop acc
0DAA C083       780            push dph
0DAC C082       780            push dpl
0DAE C0E0       780            push acc
0DB0 9003FD     780            mov dptr, #state
0DB3 1200B2     780            lcall ?Send_Constant_String
0DB6 D0E0       780            pop acc
0DB8 D082       780            pop dpl
0DBA D083       780            pop dph
0DBC 22         781   ret
0DBD            782   
0DBD            783   Update_Display:
0DBD C0E0       784            push acc
0DBF 7405       784            mov a, #5
0DC1 14         784            dec a
0DC2 1200BF     784            lcall ?Set_Cursor_1 ; Select column and row
0DC5 D0E0       784            pop acc
0DC7 C000       785       push ar0
0DC9 A839       785       mov r0, Run_time_minutes
0DCB 120D15     785       lcall ?Display_lower_BCD
0DCE D000       785       pop ar0
0DD0 C0E0       786            push acc
0DD2 7407       786            mov a, #7
0DD4 14         786            dec a
0DD5 1200BF     786            lcall ?Set_Cursor_1 ; Select column and row
0DD8 D0E0       786            pop acc
0DDA C000       787            push ar0
0DDC A838       787            mov r0, Run_time_seconds
0DDE 1200C4     787            lcall ?Display_BCD
0DE1 D000       787            pop ar0
0DE3            788       ;Set_Cursor(1,14)
0DE3            789       ;mov a, Temp_oven
0DE3            790       ;SendToLCD(Temp_oven)
0DE3 22         791   ret
0DE4            792   
0DE4            793   State0_display:
0DE4 C0E0       794            push acc
0DE6 7401       794            mov a, #1
0DE8 14         794            dec a
0DE9 1200BF     794            lcall ?Set_Cursor_1 ; Select column and row
0DEC D0E0       794            pop acc
0DEE C083       795            push dph
0DF0 C082       795            push dpl
0DF2 C0E0       795            push acc
0DF4 9003E7     795            mov dptr, #STemp
0DF7 1200B2     795            lcall ?Send_Constant_String
0DFA D0E0       795            pop acc
0DFC D082       795            pop dpl
0DFE D083       795            pop dph
0E00 C0E0       796            push acc
0E02 7406       796            mov a, #6
0E04 14         796            dec a
0E05 1200BF     796            lcall ?Set_Cursor_1 ; Select column and row
0E08 D0E0       796            pop acc
0E0A E534       797       mov a, Temp_soak
0E0C 120D22     798       lcall SendToLCD
0E0F            799       
0E0F C0E0       800            push acc
0E11 740A       800            mov a, #10
0E13 14         800            dec a
0E14 1200BF     800            lcall ?Set_Cursor_1 ; Select column and row
0E17 D0E0       800            pop acc
0E19 C083       801            push dph
0E1B C082       801            push dpl
0E1D C0E0       801            push acc
0E1F 9003ED     801            mov dptr, #STime
0E22 1200B2     801            lcall ?Send_Constant_String
0E25 D0E0       801            pop acc
0E27 D082       801            pop dpl
0E29 D083       801            pop dph
0E2B C0E0       802            push acc
0E2D 740E       802            mov a, #14
0E2F 14         802            dec a
0E30 1200BF     802            lcall ?Set_Cursor_1 ; Select column and row
0E33 D0E0       802            pop acc
0E35 E535       803       mov a, Time_soak
0E37 120D22     804            lcall SendToLCD
0E3A            805       ;Display_BCD(Time_soak)
0E3A            806   
0E3A            807       ;Displays Reflow Temp and Time
0E3A C0E0       808            push acc
0E3C 7401       808            mov a, #1
0E3E 14         808            dec a
0E3F 1200BD     808            lcall ?Set_Cursor_2 ; Select column and row
0E42 D0E0       808            pop acc
0E44 C083       809            push dph
0E46 C082       809            push dpl
0E48 C0E0       809            push acc
0E4A 9003F2     809            mov dptr, #RTemp
0E4D 1200B2     809            lcall ?Send_Constant_String
0E50 D0E0       809            pop acc
0E52 D082       809            pop dpl
0E54 D083       809            pop dph
0E56 C0E0       810            push acc
0E58 7406       810            mov a, #6
0E5A 14         810            dec a
0E5B 1200BD     810            lcall ?Set_Cursor_2 ; Select column and row
0E5E D0E0       810            pop acc
0E60 E536       811       mov a, Temp_refl
0E62 120D22     812       lcall SendToLCD
0E65            813       
0E65 C0E0       814            push acc
0E67 740A       814            mov a, #10
0E69 14         814            dec a
0E6A 1200BD     814            lcall ?Set_Cursor_2 ; Select column and row
0E6D D0E0       814            pop acc
0E6F C083       815            push dph
0E71 C082       815            push dpl
0E73 C0E0       815            push acc
0E75 9003F8     815            mov dptr, #RTime
0E78 1200B2     815            lcall ?Send_Constant_String
0E7B D0E0       815            pop acc
0E7D D082       815            pop dpl
0E7F D083       815            pop dph
0E81 C0E0       816            push acc
0E83 740E       816            mov a, #14
0E85 14         816            dec a
0E86 1200BD     816            lcall ?Set_Cursor_2 ; Select column and row
0E89 D0E0       816            pop acc
0E8B E537       817       mov a, Time_refl
0E8D 120D22     818            lcall SendToLCD
0E90 22         819   ret
0E91            820   
0E91            821   Display_3_digit_BCD:
0E91 C0E0       822            push acc
0E93 740E       822            mov a, #14
0E95 14         822            dec a
0E96 1200BF     822            lcall ?Set_Cursor_1 ; Select column and row
0E99 D0E0       822            pop acc
0E9B C000       823       push ar0
0E9D A846       823       mov r0, bcd+1
0E9F 120D15     823       lcall ?Display_lower_BCD
0EA2 D000       823       pop ar0
0EA4 C000       824            push ar0
0EA6 A845       824            mov r0, bcd+0
0EA8 1200C4     824            lcall ?Display_BCD
0EAB D000       824            pop ar0
0EAD 22         825   ret
0EAE            826   
0EAE            827   Animation:
0EAE 740F       828            mov a, #0x0f
0EB0 120083     828            lcall ?WriteCommand ;display cursor
0EB3            829   
0EB3            830       ;name ; Move cursor to line 1 column 1
0EB3 7480       831            mov a, #0x80
0EB5 120083     831            lcall ?WriteCommand
0EB8 7457       832            mov a, #'W'
0EBA 12007E     832            lcall ?WriteData
0EBD C002       833            push AR2
0EBF 7AFA       833            mov R2, #250
0EC1 120039     833            lcall ?Wait_Milli_Seconds
0EC4 D002       833            pop AR2
0EC6 7465       834            mov a, #'e'
0EC8 12007E     834            lcall ?WriteData
0ECB C002       835            push AR2
0ECD 7AFA       835            mov R2, #250
0ECF 120039     835            lcall ?Wait_Milli_Seconds
0ED2 D002       835            pop AR2
0ED4 746C       836            mov a, #'l'
0ED6 12007E     836            lcall ?WriteData
0ED9 C002       837            push AR2
0EDB 7AFA       837            mov R2, #250
0EDD 120039     837            lcall ?Wait_Milli_Seconds
0EE0 D002       837            pop AR2
0EE2 7463       838            mov a, #'c'
0EE4 12007E     838            lcall ?WriteData
0EE7 C002       839            push AR2
0EE9 7AFA       839            mov R2, #250
0EEB 120039     839            lcall ?Wait_Milli_Seconds
0EEE D002       839            pop AR2
0EF0 746F       840            mov a, #'o'
0EF2 12007E     840            lcall ?WriteData
0EF5 C002       841            push AR2
0EF7 7AFA       841            mov R2, #250
0EF9 120039     841            lcall ?Wait_Milli_Seconds
0EFC D002       841            pop AR2
0EFE 746D       842            mov a, #'m'
0F00 12007E     842            lcall ?WriteData
0F03 C002       843            push AR2
0F05 7AFA       843            mov R2, #250
0F07 120039     843            lcall ?Wait_Milli_Seconds
0F0A D002       843            pop AR2
0F0C 7465       844            mov a, #'e'
0F0E 12007E     844            lcall ?WriteData
0F11 C002       845            push AR2
0F13 7AFA       845            mov R2, #250
0F15 120039     845            lcall ?Wait_Milli_Seconds
0F18 D002       845            pop AR2
0F1A 7421       846            mov a, #'!'
0F1C 12007E     846            lcall ?WriteData
0F1F C002       847            push AR2
0F21 7AFA       847            mov R2, #250
0F23 120039     847            lcall ?Wait_Milli_Seconds
0F26 D002       847            pop AR2
0F28 7420       848            mov a, #' '
0F2A 12007E     848            lcall ?WriteData
0F2D C002       849            push AR2
0F2F 7AFA       849            mov R2, #250
0F31 120039     849            lcall ?Wait_Milli_Seconds
0F34 D002       849            pop AR2
0F36 7460       850            mov a, #96
0F38 12007E     850            lcall ?WriteData
0F3B C002       851            push AR2
0F3D 7AFA       851            mov R2, #250
0F3F 120039     851            lcall ?Wait_Milli_Seconds
0F42 D002       851            pop AR2
0F44 74EF       852            mov a, #239
0F46 12007E     852            lcall ?WriteData
0F49 C002       853            push AR2
0F4B 7AFA       853            mov R2, #250
0F4D 120039     853            lcall ?Wait_Milli_Seconds
0F50 D002       853            pop AR2
0F52 742F       854            mov a, #47
0F54 12007E     854            lcall ?WriteData
0F57 121098     855       lcall Wait_One_Second
0F5A 121098     856       lcall Wait_One_Second
0F5D 740C       857            mov a, #0x0c
0F5F 120083     857            lcall ?WriteCommand ;clear cursor
0F62 22         858   ret
0F63            859   
0F63            860   ;The following functions store and restore the values--------------------------------------------------------------------------
                861   loadbyte mac
                862       mov a, %0
                863       movx @dptr, a
                864       inc dptr
                865   endmac
0F63            866   
0F63            867   Save_Configuration:
0F63 C0A8       868       push IE ; Save the current state of bit EA in the stack
0F65 C2AF       869       clr EA ; Disable interrupts
0F67 75D108     870       mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
0F6A 907F80     871       mov dptr, #0x7f80 ; Last page of flash memory
0F6D            872       ; Save variables
0F6D E534       873       mov a, temp_soak
0F6F F0         873       movx @dptr, a
0F70 A3         873       inc dptr ; @0x7f80
0F71 E535       874       mov a, time_soak
0F73 F0         874       movx @dptr, a
0F74 A3         874       inc dptr ; @0x7f81
0F75 E536       875       mov a, temp_refl
0F77 F0         875       movx @dptr, a
0F78 A3         875       inc dptr ; @0x7f82
0F79 E537       876       mov a, time_refl
0F7B F0         876       movx @dptr, a
0F7C A3         876       inc dptr ; @0x7f83
0F7D 7455       877       mov a, #0x55
0F7F F0         877       movx @dptr, a
0F80 A3         877       inc dptr ; First key value @0x7f84
0F81 74AA       878       mov a, #0xAA
0F83 F0         878       movx @dptr, a
0F84 A3         878       inc dptr ; Second key value @0x7f85
0F85 75D100     879       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0) 
0F88 43D240     880       orl EECON, #0b01000000 ; Enable auto-erase on next write sequence  
0F8B 75D150     881       mov FCON, #0x50 ; Write trigger first byte
0F8E 75D1A0     882       mov FCON, #0xA0 ; Write trigger second byte
0F91            883       ; CPU idles until writing of flash completes.
0F91 75D100     884       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
0F94 53D2BF     885       anl EECON, #0b10111111 ; Disable auto-erase
0F97 D0A8       886       pop IE ; Restore the state of bit EA from the stack
0F99 22         887   ret
0F9A            888   
                889   getbyte mac
                890       clr a
                891       movc a, @a+dptr
                892       mov %0, a
                893       inc dptr
                894   endmac
0F9A            895   
0F9A            896   Load_Configuration:
0F9A 907F84     897       mov dptr, #0x7f84 ; First key value location.
0F9D E4         898       clr a
0F9E 93         898       movc a, @a+dptr
0F9F F8         898       mov R0, a
0FA0 A3         898       inc dptr ; 0x7f84 should contain 0x55
0FA1 B8551F     899       cjne R0, #0x55, Load_Defaults
0FA4 E4         900       clr a
0FA5 93         900       movc a, @a+dptr
0FA6 F8         900       mov R0, a
0FA7 A3         900       inc dptr ; 0x7f85 should contain 0xAA
0FA8 B8AA18     901       cjne R0, #0xAA, Load_Defaults
0FAB            902   ; Keys are good.  Get stored values.
0FAB 907F80     903       mov dptr, #0x7f80
0FAE E4         904       clr a
0FAF 93         904       movc a, @a+dptr
0FB0 F534       904       mov Temp_soak, a
0FB2 A3         904       inc dptr ; 0x7f80
0FB3 E4         905       clr a
0FB4 93         905       movc a, @a+dptr
0FB5 F535       905       mov Time_soak, a
0FB7 A3         905       inc dptr ; 0x7f81
0FB8 E4         906       clr a
0FB9 93         906       movc a, @a+dptr
0FBA F536       906       mov Temp_refl, a
0FBC A3         906       inc dptr ; 0x7f82
0FBD E4         907       clr a
0FBE 93         907       movc a, @a+dptr
0FBF F537       907       mov Time_refl, a
0FC1 A3         907       inc dptr ; 0x7f83
0FC2 22         908   ret
0FC3            909   
0FC3            910   Load_Defaults:
0FC3 753482     911       mov Temp_soak, #130 ; Soak Tmp Range is 130-170
0FC6 75353C     912       mov Time_soak, #0x3C ; Range 60-90 seconds
0FC9 7536DC     913       mov Temp_refl, #220 ; Range 220-240
0FCC 75371E     914       mov Time_refl, #0x1E ; Range 30-45 seconds
0FCF 22         915       ret 
0FD0            916   ;-------------------------------------------------------------------------------------------------------------------------------
0FD0            917   ;off state
0FD0            918   
0FD0            919   OFF_STATE:
0FD0            920       ;**CLEAR SCREEN**
0FD0 7401       921            mov a, #0x01
0FD2 120083     921            lcall ?WriteCommand
0FD5            922       ;OFF_STATE1:
0FD5            923       
0FD5 20C5FD     924       jb POWER_BUTTON, $ ; loop while the button is not pressed
0FD8 C002       925            push AR2
0FDA 7A32       925            mov R2, #50
0FDC 120039     925            lcall ?Wait_Milli_Seconds
0FDF D002       925            pop AR2 ; debounce time
0FE1 20C5EC     926            jb POWER_BUTTON, OFF_STATE ; it was a bounce, try again
0FE4 30C5FD     927            jnb POWER_BUTTON, $ ; loop while the button is pressed
0FE7 021181     928       ljmp main
0FEA 22         929   ret
0FEB            930   ;-------------------------------------------------------------------------------------------------------------------------------
0FEB            931   
0FEB            932   ;***CHECK TEMPERATURE BY READING VOLTAGE AND CONVERTING
0FEB            933   Check_Temp:
0FEB            934       
0FEB            935       ;jnb one_seconds_flag, Check_Temp_done
0FEB            936       ;clr one_seconds_flag
0FEB            937       
0FEB C297       938       clr CE_ADC
0FED 7801       939            mov R0, #00000001B ; Start bit:1
0FEF 12047B     940            lcall DO_SPI_G
0FF2 7880       941            mov R0, #10000000B ; Single ended, read channel 0
0FF4 12047B     942            lcall DO_SPI_G
0FF7 E9         943            mov a, R1          ; R1 contains bits 8 and 9
0FF8 5403       944            anl a, #00000011B  ; We need only the two least significant bits
0FFA F54B       945            mov Result+1, a    ; Save result high.
0FFC 7855       946            mov R0, #55H ; It doesn't matter what we transmit...
0FFE 12047B     947            lcall DO_SPI_G
1001 894A       948            mov Result+0, R1     ; R1 contains bits 0 to 7.  Save result low.
1003 D297       949            setb CE_ADC
1005            950   
1005 C002       951            push AR2
1007 7A0A       951            mov R2, #10
1009 120039     951            lcall ?Wait_Milli_Seconds
100C D002       951            pop AR2
100E            952       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
100E AE4A       953            mov R6, Result+0
1010 AF4B       954            mov R7, Result+1
1012 22         955   ret
1013            956   
1013            957       
1013            958       
1013            959   ;***CALCULATES THE TEMPERATURE
1013            960   Average_Temp:
1013 753D00     961            mov x+0, #low (0 % 0x10000) 
1016 753E00     961            mov x+1, #high(0 % 0x10000) 
1019 753F00     961            mov x+2, #low (0 / 0x10000) 
101C 754000     961            mov x+3, #high(0 / 0x10000) 
101F 7D64       962       mov R5, #100
1021            963   Ave_loop:
1021 120FEB     964       lcall Check_Temp
1024 754400     965       mov y+3, #0
1027 754300     966       mov y+2, #0
102A 8F42       967       mov y+1, R7
102C 8E41       968       mov y+0, R6
102E 1201B5     969       lcall add32
1031 1210D0     970       lcall Wait10us
1034 DDEB       971       djnz R5, Ave_loop
1036 754164     972            mov y+0, #low (100 % 0x10000) 
1039 754200     972            mov y+1, #high(100 % 0x10000) 
103C 754300     972            mov y+2, #low (100 / 0x10000) 
103F 754400     972            mov y+3, #high(100 / 0x10000) 
1042 1202F7     973       lcall div32
1045            974   
1045            975       ;**INSERT MATH FUNCTIONS
1045            976   
1045 75414E     977            mov y+0, #low (2894 % 0x10000) 
1048 75420B     977            mov y+1, #high(2894 % 0x10000) 
104B 754300     977            mov y+2, #low (2894 / 0x10000) 
104E 754400     977            mov y+3, #high(2894 / 0x10000)  ;6078; 2026
1051 12026A     978            lcall mul32
1054 754110     979            mov y+0, #low (10000 % 0x10000) 
1057 754227     979            mov y+1, #high(10000 % 0x10000) 
105A 754300     979            mov y+2, #low (10000 / 0x10000) 
105D 754400     979            mov y+3, #high(10000 / 0x10000)  ;14000; 7000
1060 1202F7     980            lcall div32
1063 754116     981            mov y+0, #low (22 % 0x10000) 
1066 754200     981            mov y+1, #high(22 % 0x10000) 
1069 754300     981            mov y+2, #low (22 / 0x10000) 
106C 754400     981            mov y+3, #high(22 / 0x10000) 
106F 1201B5     982       lcall add32
1072 853D3B     983       mov Temp_oven, x+0
1075            984       ;add KTemp_oven, Temp_oven, #273
1075            985   
1075            986   Display_Temp_BCD_Or_Kelvin:
1075 1200F0     987            lcall hex2bcd ; converts binary in x to BCD in BCD
1078            988       ;mov a, K_or_C
1078            989       ;cjne a, #1, Display_3_digit_BCD
1078            990       ;mov a, KTemp_oven
1078            991       ;SendToLCD
1078            992       ;sjmp Send_Temp_Port
1078            993   
1078            994   Display_Temp_BCD:    
1078 120E91     995       lcall Display_3_digit_BCD
107B            996   
107B            997   Send_Temp_Port:
107B            998       ;Send_BCD(bcd+4)
107B            999       ;Send_BCD(bcd+3)
107B           1000       ;Send_BCD(bcd+2)
107B C000      1001       push ar0
107D A846      1001       mov r0, bcd+1
107F 1200DA    1001       lcall ?Send_BCD
1082 D000      1001       pop ar0
1084           1001   
1084 C000      1002       push ar0
1086 A845      1002       mov r0, bcd+0
1088 1200DA    1002       lcall ?Send_BCD
108B D000      1002       pop ar0
108D           1002   
108D 740D      1003            mov a, #'\r'
108F 120505    1004            lcall putchar
1092 740A      1005            mov a, #'\n'
1094 120505    1006            lcall putchar
1097           1007   Check_Temp_done:
1097 22        1008   ret    
1098           1009   
1098           1010   ;-------------------------------------------------------------------------------------------------------------------------------
1098           1011   
1098           1012   ;Time wait
1098           1013   
1098           1014   Wait_One_Second:
1098 C002      1015            push AR2
109A 7AFA      1015            mov R2, #250
109C 120039    1015            lcall ?Wait_Milli_Seconds
109F D002      1015            pop AR2
10A1 C002      1016            push AR2
10A3 7AFA      1016            mov R2, #250
10A5 120039    1016            lcall ?Wait_Milli_Seconds
10A8 D002      1016            pop AR2
10AA C002      1017            push AR2
10AC 7AFA      1017            mov R2, #250
10AE 120039    1017            lcall ?Wait_Milli_Seconds
10B1 D002      1017            pop AR2
10B3 C002      1018            push AR2
10B5 7AFA      1018            mov R2, #250
10B7 120039    1018            lcall ?Wait_Milli_Seconds
10BA D002      1018            pop AR2
10BC 22        1019   ret
10BD           1020   
10BD           1021   Wait_Half_Second:
10BD C002      1022            push AR2
10BF 7AFA      1022            mov R2, #250
10C1 120039    1022            lcall ?Wait_Milli_Seconds
10C4 D002      1022            pop AR2
10C6 C002      1023            push AR2
10C8 7AFA      1023            mov R2, #250
10CA 120039    1023            lcall ?Wait_Milli_Seconds
10CD D002      1023            pop AR2
10CF 22        1024   ret
10D0           1025   
10D0           1026   
10D0           1027   
10D0           1028   Wait10us:
10D0 784A      1029       mov R0, #74
10D2 D8FE      1030       djnz R0, $
10D4 22        1031   ret
10D5           1032   ; ==================================================================================================
10D5           1033   
10D5           1034   ;-------------------------------------;
10D5           1035   ; ISR for Timer 1.  Used to playback  ;
10D5           1036   ; the WAV file stored in the SPI      ;
10D5           1037   ; flash memory.                       ;
10D5           1038   ;-------------------------------------;
10D5           1039   Timer1_ISR:
10D5           1040            ; The registers used in the ISR must be saved in the stack
10D5 C0E0      1041            push acc
10D7 C0D0      1042            push psw
10D9           1043            
10D9           1044            ; Check if the play counter is zero.  If so, stop playing sound.
10D9 E54C      1045            mov a, w+0
10DB 454D      1046            orl a, w+1
10DD 454E      1047            orl a, w+2
10DF 601C      1048            jz stop_playing
10E1           1049            
10E1           1050            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
10E1 74FF      1051            mov a, #0xff
10E3 154C      1052            dec w+0
10E5 B54C07    1053            cjne a, w+0, keep_playing
10E8 154D      1054            dec w+1
10EA B54D02    1055            cjne a, w+1, keep_playing
10ED 154E      1056            dec w+2
10EF           1057            
10EF           1058   keep_playing:
10EF D2A6      1059            setb SPEAKER
10F1 120494    1060            lcall Send_SPI ; Read the next byte from the SPI Flash...
10F4           1061            ;mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
10F4 2480      1062            add a, #0x80
10F6 F5AD      1063            mov DADH, a ; Output to DAC. DAC output is pin P2.3
10F8 43A440    1064            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
10FB 800C      1065            sjmp Timer1_ISR_Done
10FD           1066   
10FD           1067   stop_playing:
10FD C28E      1068            clr TR1 ; Stop timer 1
10FF D2A5      1069            setb FLASH_CE  ; Disable SPI Flash
1101 C2A6      1070            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
1103 75AD80    1071            mov DADH, #0x80 ; middle of range
1106 43A440    1072            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
1109           1073   
1109           1074   Timer1_ISR_Done:         
1109 D0D0      1075            pop psw
110B D0E0      1076            pop acc
110D 32        1077            reti
110E           1078   ; ==================================================================================================
110E           1079   
110E           1080   ;---------------------------------;
110E           1081   ; Routine to initialize the ISR   ;
110E           1082   ; for timer 2                     ;
110E           1083   ;---------------------------------;
110E           1084   Timer2_init:
110E 75C800    1085       mov T2CON, #0
1111 75CDA9    1086       mov TH2, #high(TIMER2_RELOAD)
1114 75CC9A    1087       mov TL2, #low(TIMER2_RELOAD)
1117           1088   
1117 75CBA9    1089       mov RCAP2H, #high(TIMER2_RELOAD)
111A 75CA9A    1090       mov RCAP2L, #low(TIMER2_RELOAD)
111D           1091   
111D E4        1092       clr a
111E F530      1093       mov Count1ms+0, a
1120 F531      1094       mov Count1ms+1, a
1122 F532      1095       mov Count5sec , a
1124 D2AD      1096       setb ET2
1126 D2CA      1097       setb TR2
1128 C202      1098       clr enable_clk
112A 22        1099       ret
112B           1100   
112B           1101   ;---------------------------------;
112B           1102   ; ISR for timer 2                 ;
112B           1103   ;---------------------------------;
112B           1104   Timer2_ISR:
112B C2CF      1105       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
112D B290      1106       cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
112F           1107            
112F           1108            ; The two registers used in the ISR must be saved in the stack
112F C0E0      1109       push acc
1131 C0D0      1110       push psw
1133           1111            
1133           1112            ; Increment the 16-bit one mili second counter
1133 0530      1113            inc Count1ms+0    ; Increment the low 8-bits first
1135 E530      1114            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
1137 7002      1115            jnz Inc_Done
1139 0531      1116            inc Count1ms+1
113B           1117   
113B           1118   Inc_Done:
113B           1119   
113B           1120   ;**Oven Power Output-------------------
113B           1121       ; Do the PWM thing
113B           1122            ; Check if Count1ms > pwm_ratio (this is a 16-bit compare)
113B C3        1123            clr c
113C E54F      1124            mov a, pwm_ratio+0
113E 9530      1125            subb a, Count1ms+0
1140 E550      1126            mov a, pwm_ratio+1
1142 9531      1127            subb a, Count1ms+1
1144           1128            ; if Count1ms > pwm_ratio  the carry is set.  Just copy the carry to the pwm output pin:
1144 9290      1129            mov PWM_OUTPUT, c
1146           1130   ;**----------------------------------
1146           1131            ; Check if one second has passed
1146 E530      1132            mov a, Count1ms+0
1148 B4E831    1133            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
114B E531      1134            mov a, Count1ms+1
114D B4032C    1135            cjne a, #high(1000), Timer2_ISR_done
1150           1136            
1150           1137            ; 1000 milliseconds have passed.  Set a flag so the main program knows
1150 D200      1138            setb one_seconds_flag ; Let the main program know one second had passed
1152           1139       
1152 0532      1140       inc Count5sec
1154 E532      1141       mov a, Count5sec
1156 B40505    1142       cjne a, #5, Set_5sec_flag_done
1159 D201      1143       setb five_seconds_flag
115B E4        1144       clr a
115C F532      1145       mov Count5sec, a
115E           1146       
115E           1147   Set_5sec_flag_done:
115E E4        1148            clr a
115F F530      1149            mov Count1ms+0, a
1161 F531      1150            mov Count1ms+1, a
1163           1151   
1163 300216    1152       jnb enable_clk, Timer2_ISR_done ;if the clk is enabled, increment the second. Otherwise skip
1166           1153   ; Increment the run time counter and state time counter
1166 E538      1154            mov a, Run_time_seconds
1168 2401      1155            add a, #0x01
116A D4        1156            da a
116B F538      1157       mov Run_time_seconds, a
116D           1158       ;check sec overflow
116D B4600A    1159       cjne a, #0x60, Check_sec_overflow_done
1170 753800    1160       mov Run_time_seconds, #0x00
1173 E539      1161       mov a, Run_time_minutes ;inc min
1175 2401      1162       add a, #1
1177 D4        1163       da a
1178 F539      1164       mov Run_time_minutes, a
117A           1165   Check_sec_overflow_done:
117A 053A      1166       inc State_time
117C           1167   Timer2_ISR_done:
117C D0D0      1168            pop psw
117E D0E0      1169            pop acc
1180 32        1170            reti
1181           1171   
1181           1172   
1181           1173   ; ==================================================================================================
1181           1174   
1181           1175   main:
1181 75817F    1176       mov SP, #0x7F
1184 12110E    1177       lcall Timer2_Init
1187           1178       ;lcall INI_SPI
1187 120088    1179       lcall LCD_4BIT
118A 1204ED    1180       lcall InitSerialPort
118D 120CDC    1181       lcall INI_PLAYBACK_TEMP
1190           1182       ; In case you decide to use the pins of P0, configure the port in bidirectional mode. Can be ignored
1190 75E600    1183       mov P0M0, #0
1193 75E700    1184       mov P0M1, #0
1196 D2AF      1185       setb EA   ;Enable global enterupt
1198           1186   
1198 120F9A    1187       lcall Load_Configuration
119B           1188   
119B           1189       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
119B 754F00    1190            mov pwm_ratio+0, #low(0)
119E 755000    1191            mov pwm_ratio+1, #high(0)
11A1 753300    1192       mov States, #0
11A4 120EAE    1193       lcall Animation
11A7           1194       
11A7           1195       
11A7           1196   state0: ; idle
11A7           1197       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
11A7           1198            ;mov pwm_ratio+0, #low(0)
11A7           1199            ;mov pwm_ratio+1, #high(0)
11A7           1200       ;mov States, #0
11A7           1201   
11A7           1202   ;***initial parameters displayed***
11A7           1203       
11A7           1204       ;Displays Soak Temp and Time
11A7 120DE4    1205       lcall State0_display
11AA           1206       ;check power on
11AA 12057D    1207       lcall CHECK_POWER
11AD           1208       ; check the parameters being pressed
11AD 12050D    1209       lcall CHECK_STIME
11B0 120529    1210       lcall CHECK_STEMP
11B3 120545    1211       lcall CHECK_RTIME
11B6 120561    1212       lcall CHECK_RTEMP
11B9 120F63    1213       lcall Save_Configuration
11BC           1214       
11BC           1215       ;lcall Check_Temp
11BC           1216       ;lcall PLAYBACK_TEMP
11BC           1217   
11BC 2085E8    1218       jb NEXT_STATE_BUTTON, state0
11BF C002      1219            push AR2
11C1 7A32      1219            mov R2, #50
11C3 120039    1219            lcall ?Wait_Milli_Seconds
11C6 D002      1219            pop AR2 ; debounce time
11C8 2085DC    1220            jb NEXT_STATE_BUTTON, state0 ; if button not pressed, loop
11CB 3085FD    1221            jnb NEXT_STATE_BUTTON, $
11CE           1222   state0_done:
11CE 753301    1223       mov States, #1
11D1 753A00    1224       mov State_time, #0
11D4 D202      1225       setb enable_clk
11D6           1226      
11D6           1227        
11D6           1228   
11D6           1229   state1_beginning:
11D6           1230       
11D6           1231       ;Start Run Time
11D6 753800    1232       mov Run_time_seconds, #0 ; time starts at 0:00
11D9 753900    1233       mov Run_time_minutes, #0
11DC 753A00    1234       mov State_time, #0
11DF           1235   
11DF           1236       ;***clear the screen and set new display***
11DF 120D3E    1237       lcall Initialize_State_Display
11E2 C0E0      1238            push acc
11E4 7407      1238            mov a, #7
11E6 14        1238            dec a
11E7 1200BD    1238            lcall ?Set_Cursor_2 ; Select column and row
11EA D0E0      1238            pop acc
11EC C083      1239            push dph
11EE C082      1239            push dpl
11F0 C0E0      1239            push acc
11F2 90044E    1239            mov dptr, #Ramp2Soak
11F5 1200B2    1239            lcall ?Send_Constant_String
11F8 D0E0      1239            pop acc
11FA D082      1239            pop dpl
11FC D083      1239            pop dph; displays current state
11FE           1240   
11FE           1241       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
11FE 754FE8    1242            mov pwm_ratio+0, #low(1000)
1201 755003    1243            mov pwm_ratio+1, #high(1000)
1204           1244       ; ***play audio***
1204           1244       ;cjne sound_flag, #0, $
1204           1244       
1204 1210BD    1244       lcall Wait_Half_Second
1207 C28E      1244       clr TR1 ; Stop Timer 1 ISR from playing previous request
1209 D2A5      1244       setb FLASH_CE
120B           1244       ;setb sound_flag ; sound starts
120B C2A6      1244       clr SPEAKER ; Turn off speaker
120D C2A5      1244       clr FLASH_CE ; Enable SPI Flash
120F 7403      1244       mov a, #READ_BYTES
1211 120494    1244       lcall Send_SPI
1214           1244       ; Set the initial position in memory where to start playing
1214           1244       
1214 7400      1244       mov a, #0x00 ; change initial position
1216 120494    1244       lcall Send_SPI
1219 7400      1244       mov a, #0x00 ; next memory position
121B 120494    1244       lcall Send_SPI
121E 742D      1244       mov a, #0x2d ; next memory position
1220 120494    1244       lcall Send_SPI
1223 7400      1244       mov a, #0x00 ; request first byte to send to DAC
1225 120494    1244       lcall Send_SPI
1228           1244       
1228           1244       ; How many bytes to play?
1228 754E00    1244       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
122B 754D4E    1244       mov w+1, #0x4e ; Load the middle byte of the number of bytes to play
122E 754C20    1244       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
1231           1244       
1231           1244       
1231 D2A6      1244       setb SPEAKER ;Turn on speaker
1233 D28E      1244       setb TR1 ;Start playback by enabling Timer1
1235           1244       ;clr sound_flag ; sound ends
1235 8003      1245       sjmp state1
1237           1246       
1237           1247   main_1:
1237 021181    1248            ljmp main
123A           1249   
123A           1250   state1: ; ramp to soak
123A           1251       
123A           1252       ;PLAYBACK_TEMP(#0x00,#0x00,#0x2d, #0x4e,#0x20)
123A           1253       ;check power on
123A 12057D    1254       lcall CHECK_POWER
123D           1255       ;Update Time and Temp
123D 120DBD    1256       lcall Update_Display
1240 121013    1257       lcall Average_Temp
1243           1258       
1243 1205AC    1259       lcall SOUND_FSM
1246           1260   
1246           1261   Check_Temp_done1:
1246           1262   
1246           1263       ;check if temp is below 150 
1246 E53B      1264       mov a, Temp_oven           
1248 9534      1265       subb a, Temp_soak
124A 5014      1266       jnc state1_done        ; if greater, jump to state 2
124C 6012      1267       jz state1_done         ; if equal to, jump to state 2
124E 4000      1268       jc Check_state1_safety ; if less than, check state time
1250           1269   Check_state1_safety:       ; safety
1250 E53B      1270       mov a, Temp_oven           
1252 9432      1271       subb a, #50
1254 50E4      1272       jnc state1             ; if greater, go back to state1
1256 E53A      1273       mov a, State_time      ; if less than 50C, check if state time is too long
1258 943C      1274       subb a, #60
125A 50DB      1275       jnc main_1             ; if greater, restart
125C 60D9      1276       jz main_1              ; if equal to, restart
125E 40DA      1277       jc state1              ; if less than, go back to state1
1260           1278   ;*Checking moving to states with buttons---- 
1260           1279   ;*Will remove after proper temperature reading----
1260           1280   
1260           1281       ;jb NEXT_STATE_BUTTON, state1
1260           1282       ;Wait_Milli_Seconds(#50) ; debounce time
1260           1283            ;jb NEXT_STATE_BUTTON, state1 ; if button not pressed, loop
1260           1284            ;jnb NEXT_STATE_BUTTON, $ 
1260           1285   
1260           1286   state1_done:
1260 753302    1287       mov States, #2
1263           1288   
1263           1289   ; preheat/soak
1263           1290   state2_beginning: 
1263 753A00    1291       mov State_time, #0;x00 ;clear the state time
1266           1292       ;***clear the screen and set new display***
1266 120D3E    1293       lcall Initialize_State_Display
1269 C0E0      1294            push acc
126B 7407      1294            mov a, #7
126D 14        1294            dec a
126E 1200BD    1294            lcall ?Set_Cursor_2 ; Select column and row
1271 D0E0      1294            pop acc
1273 C083      1295            push dph
1275 C082      1295            push dpl
1277 C0E0      1295            push acc
1279 900458    1295            mov dptr, #Soak
127C 1200B2    1295            lcall ?Send_Constant_String
127F D0E0      1295            pop acc
1281 D082      1295            pop dpl
1283 D083      1295            pop dph ;displays current state
1285           1296   
1285           1297       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
1285 754FC8    1298            mov pwm_ratio+0, #low(200)
1288 755000    1299            mov pwm_ratio+1, #high(000)
128B           1300       ; Produces SOAK on speaker
128B           1301       ; ***play audio***
128B           1301       ;cjne sound_flag, #0, $
128B           1301       
128B 1210BD    1301       lcall Wait_Half_Second
128E C28E      1301       clr TR1 ; Stop Timer 1 ISR from playing previous request
1290 D2A5      1301       setb FLASH_CE
1292           1301       ;setb sound_flag ; sound starts
1292 C2A6      1301       clr SPEAKER ; Turn off speaker
1294 C2A5      1301       clr FLASH_CE ; Enable SPI Flash
1296 7403      1301       mov a, #READ_BYTES
1298 120494    1301       lcall Send_SPI
129B           1301       ; Set the initial position in memory where to start playing
129B           1301       
129B 7400      1301       mov a, #0x00 ; change initial position
129D 120494    1301       lcall Send_SPI
12A0 7444      1301       mov a, #0x44 ; next memory position
12A2 120494    1301       lcall Send_SPI
12A5 74DD      1301       mov a, #0xdd ; next memory position
12A7 120494    1301       lcall Send_SPI
12AA 7400      1301       mov a, #0x00 ; request first byte to send to DAC
12AC 120494    1301       lcall Send_SPI
12AF           1301       
12AF           1301       ; How many bytes to play?
12AF 754E00    1301       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
12B2 754D4E    1301       mov w+1, #0x4e ; Load the middle byte of the number of bytes to play
12B5 754C20    1301       mov w+0, #0x20 ; Load the low byte of the number of bytes to play
12B8           1301       
12B8           1301       
12B8 D2A6      1301       setb SPEAKER ;Turn on speaker
12BA D28E      1301       setb TR1 ;Start playback by enabling Timer1
12BC           1301       ;clr sound_flag ; sound ends
12BC           1302   
12BC           1303   state2:
12BC           1304       ;check power on
12BC 12057D    1305       lcall CHECK_POWER 
12BF           1306       ;Update Time and Temp
12BF 120DBD    1307       lcall Update_Display
12C2 121013    1308       lcall Average_Temp
12C5           1309   
12C5 1205AC    1310       lcall SOUND_FSM
12C8           1311       
12C8           1312       ; loop back to state2 if run time is less than soak time. If greater than jump to state3 cuz of overflow of time
12C8           1313        
12C8 E53A      1314       mov a, State_time
12CA 9535      1315       subb a, Time_soak
12CC 5002      1316       jnc state2_done
12CE 40EC      1317       jc state2
12D0           1318   
12D0           1319   
12D0           1320   ;*Checking moving to states with buttons---- 
12D0           1321   ;*Will remove after proper temperature reading----
12D0           1322   
12D0           1323       ;jb NEXT_STATE_BUTTON, state2
12D0           1324       ;Wait_Milli_Seconds(#50) ; debounce time
12D0           1325            ;jb NEXT_STATE_BUTTON, state2 ; if button not pressed, loop
12D0           1326            ;jnb NEXT_STATE_BUTTON, $ 
12D0           1327       
12D0           1328   state2_done:
12D0 753A03    1329       mov State_time, #3
12D3           1330   
12D3           1331   ; ramp to peak
12D3           1332   state3_beginning:
12D3           1333       ;setb OVEN_POWER ;turn power on 100%
12D3           1334   
12D3           1335       ;***clear the screen and set new display***
12D3 120D3E    1336       lcall Initialize_State_Display
12D6 C0E0      1337            push acc
12D8 7407      1337            mov a, #7
12DA 14        1337            dec a
12DB 1200BD    1337            lcall ?Set_Cursor_2 ; Select column and row
12DE D0E0      1337            pop acc
12E0 C083      1338            push dph
12E2 C082      1338            push dpl
12E4 C0E0      1338            push acc
12E6 90045D    1338            mov dptr, #Ramp2Peak
12E9 1200B2    1338            lcall ?Send_Constant_String
12EC D0E0      1338            pop acc
12EE D082      1338            pop dpl
12F0 D083      1338            pop dph
12F2           1339   
12F2           1340       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
12F2 754FE8    1341            mov pwm_ratio+0, #low(1000)
12F5 755003    1342            mov pwm_ratio+1, #high(1000)
12F8           1343   
12F8           1344       ; Produces RAMP TO PEAK on speaker
12F8           1345       ; ***play audio***
12F8           1345       ;cjne sound_flag, #0, $
12F8           1345       
12F8 1210BD    1345       lcall Wait_Half_Second
12FB C28E      1345       clr TR1 ; Stop Timer 1 ISR from playing previous request
12FD D2A5      1345       setb FLASH_CE
12FF           1345       ;setb sound_flag ; sound starts
12FF C2A6      1345       clr SPEAKER ; Turn off speaker
1301 C2A5      1345       clr FLASH_CE ; Enable SPI Flash
1303 7403      1345       mov a, #READ_BYTES
1305 120494    1345       lcall Send_SPI
1308           1345       ; Set the initial position in memory where to start playing
1308           1345       
1308 7400      1345       mov a, #0x00 ; change initial position
130A 120494    1345       lcall Send_SPI
130D 748B      1345       mov a, #0x8b ; next memory position
130F 120494    1345       lcall Send_SPI
1312 74CA      1345       mov a, #0xca ; next memory position
1314 120494    1345       lcall Send_SPI
1317 7400      1345       mov a, #0x00 ; request first byte to send to DAC
1319 120494    1345       lcall Send_SPI
131C           1345       
131C           1345       ; How many bytes to play?
131C 754E00    1345       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
131F 754D75    1345       mov w+1, #0x75 ; Load the middle byte of the number of bytes to play
1322 754C30    1345       mov w+0, #0x30 ; Load the low byte of the number of bytes to play
1325           1345       
1325           1345       
1325 D2A6      1345       setb SPEAKER ;Turn on speaker
1327 D28E      1345       setb TR1 ;Start playback by enabling Timer1
1329           1345       ;clr sound_flag ; sound ends
1329           1346   
1329           1347   state3: 
1329           1348       ;check power on
1329 12057D    1349       lcall CHECK_POWER
132C 121013    1350       lcall Average_Temp
132F           1351       
132F           1352       
132F           1353       ;Update Time and Temp
132F 120DBD    1354       lcall Update_Display
1332 1205AC    1355       lcall SOUND_FSM
1335           1356   
1335           1357       
1335 E53B      1358       mov a, Temp_oven           
1337 9536      1359       subb a, Temp_refl
1339 5004      1360       jnc state3_done    ; if greater, jump to state 4
133B 6002      1361       jz state3_done ; if equal to, jump to state 4
133D 40EA      1362       jc state3 ; if less than, go back to state3
133F           1363       
133F           1364       ;jb NEXT_STATE_BUTTON, state3
133F           1365       ;Wait_Milli_Seconds(#50) ; debounce time
133F           1366            ;jb NEXT_STATE_BUTTON, state3 ; if button not pressed, loop
133F           1367            ;jnb NEXT_STATE_BUTTON, $
133F           1368   
133F           1369   state3_done:
133F 753A04    1370       mov State_time, #4
1342           1371   
1342           1372   ; reflow 
1342           1373   state4_beginning:
1342           1374       
1342 753A00    1375       mov State_time, #0;x00 clear the state time
1345           1376       ;***clear the screen and set new display***
1345 120D3E    1377       lcall Initialize_State_Display
1348 C0E0      1378            push acc
134A 7407      1378            mov a, #7
134C 14        1378            dec a
134D 1200BD    1378            lcall ?Set_Cursor_2 ; Select column and row
1350 D0E0      1378            pop acc
1352 C083      1379            push dph
1354 C082      1379            push dpl
1356 C0E0      1379            push acc
1358 900467    1379            mov dptr, #Reflow
135B 1200B2    1379            lcall ?Send_Constant_String
135E D0E0      1379            pop acc
1360 D082      1379            pop dpl
1362 D083      1379            pop dph
1364           1380   
1364           1381       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
1364 754FC8    1382            mov pwm_ratio+0, #low(200)
1367 755000    1383            mov pwm_ratio+1, #high(000)
136A           1384   
136A           1385       ; Produces REFLOW on speaker
136A           1386       ; ***play audio***
136A           1386       ;cjne sound_flag, #0, $
136A           1386       
136A 1210BD    1386       lcall Wait_Half_Second
136D C28E      1386       clr TR1 ; Stop Timer 1 ISR from playing previous request
136F D2A5      1386       setb FLASH_CE
1371           1386       ;setb sound_flag ; sound starts
1371 C2A6      1386       clr SPEAKER ; Turn off speaker
1373 C2A5      1386       clr FLASH_CE ; Enable SPI Flash
1375 7403      1386       mov a, #READ_BYTES
1377 120494    1386       lcall Send_SPI
137A           1386       ; Set the initial position in memory where to start playing
137A           1386       
137A 7400      1386       mov a, #0x00 ; change initial position
137C 120494    1386       lcall Send_SPI
137F 74F0      1386       mov a, #0xf0 ; next memory position
1381 120494    1386       lcall Send_SPI
1384 7463      1386       mov a, #0x63 ; next memory position
1386 120494    1386       lcall Send_SPI
1389 7400      1386       mov a, #0x00 ; request first byte to send to DAC
138B 120494    1386       lcall Send_SPI
138E           1386       
138E           1386       ; How many bytes to play?
138E 754E00    1386       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
1391 754D59    1386       mov w+1, #0x59 ; Load the middle byte of the number of bytes to play
1394 754CD8    1386       mov w+0, #0xd8 ; Load the low byte of the number of bytes to play
1397           1386       
1397           1386       
1397 D2A6      1386       setb SPEAKER ;Turn on speaker
1399 D28E      1386       setb TR1 ;Start playback by enabling Timer1
139B           1386       ;clr sound_flag ; sound ends
139B           1387   
139B           1388   
139B           1389   state4:
139B           1390       ;check power on
139B 12057D    1391       lcall CHECK_POWER
139E           1392       ;Update Time and Temp
139E 120DBD    1393       lcall Update_Display
13A1 121013    1394       lcall Average_Temp
13A4 1205AC    1395       lcall SOUND_FSM
13A7           1396   
13A7           1397       
13A7           1398       ; loop back to state2 if run time is less than soak time
13A7 E53A      1399       mov a, State_time
13A9 9537      1400       subb a, Time_refl
13AB 5002      1401       jnc state4_done
13AD 40EC      1402       jc state4
13AF           1403   
13AF           1404       ;*Checking moving to states with buttons---- 
13AF           1405   ;*Will remove after proper temperature reading----
13AF           1406   
13AF           1407       ;jb NEXT_STATE_BUTTON, state4
13AF           1408       ;Wait_Milli_Seconds(#50) ; debounce time
13AF           1409            ;jb NEXT_STATE_BUTTON, state4 ; if button not pressed, loop
13AF           1410            ;jnb NEXT_STATE_BUTTON, $ 
13AF           1411   
13AF           1412   state4_done: 
13AF 753A00    1413       mov State_time, #0
13B2 0213B5    1414       ljmp state5_beginning 
13B5           1415   
13B5           1416   
13B5           1417   ; cooling
13B5           1418   state5_beginning: ; turn oven off
13B5 C287      1419       clr OVEN_POWER
13B7           1420   
13B7           1421   ;***clear the screen and set new display***
13B7 120D3E    1422       lcall Initialize_State_Display
13BA C083      1423            push dph
13BC C082      1423            push dpl
13BE C0E0      1423            push acc
13C0 90046E    1423            mov dptr, #Cooling
13C3 1200B2    1423            lcall ?Send_Constant_String
13C6 D0E0      1423            pop acc
13C8 D082      1423            pop dpl
13CA D083      1423            pop dph
13CC           1424   
13CC           1425       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
13CC 754F00    1426            mov pwm_ratio+0, #low(0)
13CF 755000    1427            mov pwm_ratio+1, #high(0)
13D2           1428   
13D2           1429       ; Produces COOLING on speaker
13D2           1430       ; ***play audio***
13D2           1430       ;cjne sound_flag, #0, $
13D2           1430       
13D2 1210BD    1430       lcall Wait_Half_Second
13D5 C28E      1430       clr TR1 ; Stop Timer 1 ISR from playing previous request
13D7 D2A5      1430       setb FLASH_CE
13D9           1430       ;setb sound_flag ; sound starts
13D9 C2A6      1430       clr SPEAKER ; Turn off speaker
13DB C2A5      1430       clr FLASH_CE ; Enable SPI Flash
13DD 7403      1430       mov a, #READ_BYTES
13DF 120494    1430       lcall Send_SPI
13E2           1430       ; Set the initial position in memory where to start playing
13E2           1430       
13E2 7401      1430       mov a, #0x01 ; change initial position
13E4 120494    1430       lcall Send_SPI
13E7 7448      1430       mov a, #0x48 ; next memory position
13E9 120494    1430       lcall Send_SPI
13EC 749A      1430       mov a, #0x9a ; next memory position
13EE 120494    1430       lcall Send_SPI
13F1 7401      1430       mov a, #0x01 ; request first byte to send to DAC
13F3 120494    1430       lcall Send_SPI
13F6           1430       
13F6           1430       ; How many bytes to play?
13F6 754E00    1430       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
13F9 754D6B    1430       mov w+1, #0x6b ; Load the middle byte of the number of bytes to play
13FC 754C6C    1430       mov w+0, #0x6c ; Load the low byte of the number of bytes to play
13FF           1430       
13FF           1430       
13FF D2A6      1430       setb SPEAKER ;Turn on speaker
1401 D28E      1430       setb TR1 ;Start playback by enabling Timer1
1403           1430       ;clr sound_flag ; sound ends
1403           1431   
1403           1432   state5:
1403           1433       ;check power on
1403 12057D    1434       lcall CHECK_POWER
1406           1435       
1406           1436       ; update display
1406 120DBD    1437       lcall Update_Display
1409 121013    1438       lcall Average_Temp
140C           1439   
140C 1205AC    1440       lcall SOUND_FSM
140F           1441   
140F E53B      1442       mov a, Temp_oven
1411 943C      1443       subb a, #60
1413 50EE      1444       JNC state5    ; if greater, jump back to state 5
1415 60EC      1445       JZ state5 ; if equal to, go back to state5
1417 4000      1446       JC state5_done ; if less than, go back to state 0
1419           1447   
1419           1448       ;*Checking moving to states with buttons---- 
1419           1449   ;*Will remove after proper temperature reading----
1419           1450   
1419           1451       ;jb NEXT_STATE_BUTTON, state5
1419           1452       ;Wait_Milli_Seconds(#50) ; debounce time
1419           1453            ;jb NEXT_STATE_BUTTON, state5 ; if button not pressed, loop
1419           1454            ;jnb NEXT_STATE_BUTTON, $ 
1419           1455   
1419           1456   state5_done:
1419 753A00    1457       mov State_time, #0
141C 753300    1458       mov States, #0
141F 021181    1459       ljmp main
1422           1460   
1422           1461   EN
