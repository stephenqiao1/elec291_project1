                  2   $LIST
0000              4   
0000              5   
0000              6   
0000              7   ;-------------------------------------------------------------------------------------------------------------------------------
0000              8   ;These EQU must match the wiring between the microcontroller and ADC
0000              9   CLK  EQU 22118400
0000             10   TIMER1_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             11   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             12   BAUD equ 115200
0000             13   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000             14   
0000             15   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             16   TIMER2_RELOAD EQU (65536-(CLK/TIMER2_RATE))
0000             17   
0000             18   ;shjfjdfs
0000             19   ;-------------------------------------------------------------------------------------------------------------------------------
0000             20   ;Button Pin Mapping
0000             21   NEXT_STATE_BUTTON  equ P0.5
0000             22   STIME_BUTTON    equ P0.2
0000             23   STEMP_BUTTON    equ P0.3
0000             24   RTIME_BUTTON    equ P0.4
0000             25   RTEMP_BUTTON    equ P0.6
0000             26   POWER_BUTTON    equ P4.5
0000             27   SHIFT_BUTTON    equ p0.0
0000             28   
0000             29   ;Output Pins
0000             30   OVEN_POWER      equ P0.7
0000             31   SPEAKER         equ P2.6
0000             32   
0000             33   PWM_OUTPUT    equ P1.0 ; Attach an LED (with 1k resistor in series) to P1.0
0000             34   
0000             35   FLASH_CE        equ P0.0
0000             36   
0000             37   ;Thermowire Pins
0000             38   CE_ADC    EQU  P1.7
0000             39   MY_MOSI   EQU  P1.6
0000             40   MY_MISO   EQU  P1.5
0000             41   MY_SCLK   EQU  P1.4 
0000             42   
0000             43   ; Commands supported by the SPI flash memory according to the datasheet
0000             44   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             45   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             46   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             47   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             48   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             49   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             50   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             51   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             52   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             53   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             54   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             55   
0000             56   ; These 'equ' must match the hardware wiring
0000             57   LCD_RS equ P3.2
0000             58   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
0000             59   LCD_E  equ P3.3
0000             60   LCD_D4 equ P3.4
0000             61   LCD_D5 equ P3.5
0000             62   LCD_D6 equ P3.6
0000             63   LCD_D7 equ P3.7
0000             64   
0000             65   ;-------------------------------------------------------------------------------------------------------------------------------
0000             66   
0000             67   org 0x0000
0000 0209E9      68       ljmp main
0003             69   
0003             70   ; External interrupt 0 vector (not used in this code)
0003             71   org 0x0003
0003 32          72            reti
0004             73   
0004             74   ; Timer/Counter 0 overflow interrupt vector
000B             75   org 0x000B
000B 32          76            reti
000C             77   
000C             78   ; External interrupt 1 vector (not used in this code)
0013             79   org 0x0013
0013 32          80            reti
0014             81   
0014             82   ; Timer/Counter 1 overflow interrupt vector
001B             83   org 0x001B
001B 020938      84            ljmp Timer1_ISR
001E             85   
001E             86   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             87   org 0x0023 
0023 32          88            reti
0024             89            
0024             90   ; Timer/Counter 2 overflow interrupt vector
002B             91   org 0x002B
002B 02098E      92       ljmp Timer2_ISR
002E             93   ;-------------------------------------------------------------------------------------------------------------------------------
002E             94   ; Place our variables here
0030             95   DSEG at 0x30 ; Before the state machine!
0030             96   Count1ms:         ds 2 ; Used to determine when one second has passed
0032             97   Count5sec:        ds 1
0033             98   States:           ds 1
0034             99   Temp_soak:        ds 1
0035            100   Time_soak:        ds 1
0036            101   Temp_refl:        ds 1
0037            102   Time_refl:        ds 1
0038            103   Run_time_seconds: ds 1
0039            104   Run_time_minutes: ds 1
003A            105   State_time:       ds 1
003B            106   Temp_oven:        ds 1
003C            107   x:                ds 4
0040            108   y:                ds 4
0044            109   bcd:              ds 5
0049            110   Result:           ds 2
004B            111   w:                ds 3
004E            112   pwm_ratio:        ds 2
0050            113   
                115   $LIST
00F0            117   
                546   $LIST
                119   $LIST
0360            121   
                123   $LIST
03E7            125   
0000            126   bseg
0000            127   one_seconds_flag:  dbit 1
0001            128   five_seconds_flag: dbit 1
0002            129   enable_clk:        dbit 1
0003            130   mf:                dbit 1
0004            131   
03E7            132   cseg
03E7            133   
03E7            134   ;-------------------------------------------------------------------------------------------------------------------------------
03E7            135   ;***Messages To Display*** 
03E7            136   
03E7            137   ;shortened labels
03E7 53546D70   138   STemp:  db 'STmp:', 0
     3A00
03ED 53546D3A   139   STime:  db 'STm:', 0
     00
03F2 52546D70   140   RTemp:  db 'RTmp:', 0
     3A00
03F8 52546D3A   141   RTime:  db 'RTm:', 0
     00
03FD            142   
03FD            143   ;lables for runnning oven
03FD 53746174   144   state:     db 'State>' , 0
     653E00
0404 546D653E   145   time:      db 'Tme>' , 0
     00
0409 3A00       146   colon:     db ':', 0
040B 546D703E   147   temp:      db 'Tmp>', 0
     00
0410            148   
0410            149   ;labels for changin parameters
0410 5265666C   150   ReflowTemp:  db 'Reflow Temperature:', 0
     6F772054
     656D7065
     72617475
     72653A00
0424 5265666C   151   ReflowTime:  db 'Reflow Time:', 0
     6F772054
     696D653A
     00
0431 536F616B   152   SoakTime:    db 'Soak Time:', 0
     2054696D
     653A00
043C 536F616B   153   SoakTemp:    db 'Soak Temperature:', 0
     2054656D
     70657261
     74757265
     3A00
044E            154   
044E            155   
044E            156   ;Current State in Oven
044E 52616D70   157   Ramp2Soak: db 'Ramp-Soak' , 0
     2D536F61
     6B00
0458 536F616B   158   Soak:      db 'Soak' , 0
     00
045D 52616D70   159   Ramp2Peak: db 'Ramp-Peak' , 0
     2D506561
     6B00
0467 5265666C   160   Reflow:    db 'Reflow' , 0
     6F7700
046E 436F6F6C   161   Cooling:   db 'Cooling' , 0
     696E6700
0476            162   
0476            163   ;-------------------------------------------------------------------------------------------------------------------------------
0476            164   ;FXNS FOR THERMOWIRE
0476            165   
0476            166   ;initialize SPI 
0476            167   INI_SPI:
0476 D295       168            setb MY_MISO ; Make MISO an input pin
0478 C294       169            clr MY_SCLK           ; Mode 0,0 default
047A 22         170            ret
047B            171   DO_SPI_G:
047B C0E0       172            push acc
047D 7900       173            mov R1, #0 ; Received byte stored in R1
047F 7A08       174            mov R2, #8            ; Loop counter (8-bits)
0481            175   DO_SPI_G_LOOP:
0481 E8         176            mov a, R0             ; Byte to write is in R0
0482 33         177            rlc a                 ; Carry flag has bit to write
0483 F8         178            mov R0, a
0484 9296       179            mov MY_MOSI, c
0486 D294       180            setb MY_SCLK          ; Transmit
0488 A295       181            mov c, MY_MISO        ; Read received bit
048A E9         182            mov a, R1             ; Save received bit in R1
048B 33         183            rlc a
048C F9         184            mov R1, a
048D C294       185            clr MY_SCLK
048F DAF0       186            djnz R2, DO_SPI_G_LOOP
0491 D0E0       187            pop acc
0493 22         188   ret
0494            189   
0494            190   Send_SPI:
                191   	SPIBIT MAC
                192   	    ; Send/Receive bit %0
                193   		rlc a
                194   		mov MY_MOSI, c
                195   		setb MY_SCLK
                196   		mov c, MY_MISO
                197   		clr MY_SCLK
                198   		mov acc.0, c
                199   	ENDMAC
0494            200            
0494            201                ; Send/Receive bit 7
0494 33         201                    rlc a
0495 9296       201                    mov MY_MOSI, c
0497 D294       201                    setb MY_SCLK
0499 A295       201                    mov c, MY_MISO
049B C294       201                    clr MY_SCLK
049D 92E0       201                    mov acc.0, c
049F            202                ; Send/Receive bit 6
049F 33         202                    rlc a
04A0 9296       202                    mov MY_MOSI, c
04A2 D294       202                    setb MY_SCLK
04A4 A295       202                    mov c, MY_MISO
04A6 C294       202                    clr MY_SCLK
04A8 92E0       202                    mov acc.0, c
04AA            203                ; Send/Receive bit 5
04AA 33         203                    rlc a
04AB 9296       203                    mov MY_MOSI, c
04AD D294       203                    setb MY_SCLK
04AF A295       203                    mov c, MY_MISO
04B1 C294       203                    clr MY_SCLK
04B3 92E0       203                    mov acc.0, c
04B5            204                ; Send/Receive bit 4
04B5 33         204                    rlc a
04B6 9296       204                    mov MY_MOSI, c
04B8 D294       204                    setb MY_SCLK
04BA A295       204                    mov c, MY_MISO
04BC C294       204                    clr MY_SCLK
04BE 92E0       204                    mov acc.0, c
04C0            205                ; Send/Receive bit 3
04C0 33         205                    rlc a
04C1 9296       205                    mov MY_MOSI, c
04C3 D294       205                    setb MY_SCLK
04C5 A295       205                    mov c, MY_MISO
04C7 C294       205                    clr MY_SCLK
04C9 92E0       205                    mov acc.0, c
04CB            206                ; Send/Receive bit 2
04CB 33         206                    rlc a
04CC 9296       206                    mov MY_MOSI, c
04CE D294       206                    setb MY_SCLK
04D0 A295       206                    mov c, MY_MISO
04D2 C294       206                    clr MY_SCLK
04D4 92E0       206                    mov acc.0, c
04D6            207                ; Send/Receive bit 1
04D6 33         207                    rlc a
04D7 9296       207                    mov MY_MOSI, c
04D9 D294       207                    setb MY_SCLK
04DB A295       207                    mov c, MY_MISO
04DD C294       207                    clr MY_SCLK
04DF 92E0       207                    mov acc.0, c
04E1            208                ; Send/Receive bit 0
04E1 33         208                    rlc a
04E2 9296       208                    mov MY_MOSI, c
04E4 D294       208                    setb MY_SCLK
04E6 A295       208                    mov c, MY_MISO
04E8 C294       208                    clr MY_SCLK
04EA 92E0       208                    mov acc.0, c
04EC            209   
04EC 22         210   ret
04ED            211   
                212   Change_8bit_Variable MAC
                213       jb %0, %2
                214       Wait_Milli_Seconds(#50) ; de-bounce
                215       jb %0, %2
                216       jnb %0, $
                217       jb SHIFT_BUTTON, skip%Mb
                218       dec %1
                219       sjmp skip%Ma
                220       skip%Mb:
                221       inc %1
                222       skip%Ma:
                223   ENDMAC
04ED            224   
04ED            225   ;Change_8bit_Variable(MY_VARIABLE_BUTTON, my_variable, loop_c)
04ED            226   ;    Set_Cursor(2, 14)
04ED            227   ;    mov a, my_variable
04ED            228   ;    lcall SendToLCD
04ED            229   ;lcall Save_Configuration
04ED            230   
04ED            231   ;-------------------------------------------------------------------------------------------------------------------------------
04ED            232   ;***FXNS For Serial Port
04ED            233   
04ED            234   ; Configure the serial port and baud rate
04ED            235   InitSerialPort:
04ED            236       ; Since the reset button bounces, we need to wait a bit before
04ED            237       ; sending messages, otherwise we risk displaying gibberish!
04ED 79DE       238       mov R1, #222
04EF 78A6       239       mov R0, #166
04F1 D8FE       240       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
04F3 D9FA       241       djnz R1, $-4 ; 22.51519us*222=4.998ms
04F5            242       ; Now we can proceed with the configuration
04F5 438780     243            orl     PCON,#0x80
04F8 759852     244            mov     SCON,#0x52
04FB 759B00     245            mov     BDRCON,#0x00
04FE 759AF4     246            mov     BRL,#BRG_VAL
0501 759B1E     247            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
0504 22         248   ret
0505            249   
0505            250   
0505            251   putchar:
0505 3099FD     252       jnb TI, putchar
0508 C299       253       clr TI
050A F599       254       mov SBUF, a
050C 22         255   ret
050D            256   
050D            257   ;-------------------------------------------------------------------------------------------------------------------------------
050D            258   ;***FXNS to CHECK BUTTONS
050D            259   
050D            260   CHECK_STIME:
050D            261   
050D            262       ;jb STIME_BUTTON, CHECK_STIME_END ; if button not pressed, stop checking
050D            263            ;Wait_Milli_Seconds(#50) ; debounce time
050D            264            ;jb STIME_BUTTON, CHECK_STIME_END ; if button not pressed, stop checking
050D            265            ;jnb STIME_BUTTON, $ ; loop while the button is pressed
050D            266       
050D            267       ;inc Time_soak
050D            268   
050D            269       ;mov a, Time_soak ;increment STime by 1
050D            270       ;add a, #0x01
050D            271       ;da a
050D            272       ;mov Time_soak, a
050D            273       ;cjne a, #0x5B, CHECK_STIME_END
050D            274       ;mov Time_soak, #0x3C
050D            275       ;lcall Save_Configuration
050D            276   
050D 208218     277       jb STIME_BUTTON, CHECK_STIME_END
0510 C002       277            push AR2
0512 7A32       277            mov R2, #50
0514 120039     277            lcall ?Wait_Milli_Seconds
0517 D002       277            pop AR2 ; de-bounce
0519 20820C     277       jb STIME_BUTTON, CHECK_STIME_END
051C 3082FD     277       jnb STIME_BUTTON, $
051F 208004     277       jb SHIFT_BUTTON, skip16b
0522 1535       277       dec Time_soak
0524 8002       277       sjmp skip16a
0526            277       skip16b:
0526 0535       277       inc Time_soak
0528            277       skip16a:
0528            278       ;mov a, Time_soak
0528            279       ;lcall SendToLCD
0528            280       ;lcall Save_Configuration
0528            281            
0528            282   CHECK_STIME_END:
0528 22         283   ret
0529            284   
0529            285   CHECK_STEMP:
0529            286   
0529            287       ;jb STEMP_BUTTON, CHECK_STEMP_END ; if button not pressed, stop checking
0529            288            ;Wait_Milli_Seconds(#50) ; debounce time
0529            289            ;jb STEMP_BUTTON, CHECK_STEMP_END ; if button not pressed, stop checking
0529            290            ;jnb STEMP_BUTTON, $ ; loop while the button is pressed
0529            291       
0529            292       ;mov a, Temp_soak ;increment STEMP by 5
0529            293       ;add a, #5
0529            294       ;da a
0529            295       ;mov Temp_soak, a
0529            296       ;cjne a, #175, CHECK_STEMP_END
0529            297       ;mov Temp_soak, #130
0529            298   
0529 208318     299       jb STEMP_BUTTON, CHECK_STEMP_END
052C C002       299            push AR2
052E 7A32       299            mov R2, #50
0530 120039     299            lcall ?Wait_Milli_Seconds
0533 D002       299            pop AR2 ; de-bounce
0535 20830C     299       jb STEMP_BUTTON, CHECK_STEMP_END
0538 3083FD     299       jnb STEMP_BUTTON, $
053B 208004     299       jb SHIFT_BUTTON, skip18b
053E 1534       299       dec Temp_soak
0540 8002       299       sjmp skip18a
0542            299       skip18b:
0542 0534       299       inc Temp_soak
0544            299       skip18a:
0544            300       ;lcall Save_Configuration
0544            301            
0544            302   CHECK_STEMP_END:
0544 22         303   ret
0545            304   
0545            305   CHECK_RTIME:
0545            306   
0545            307       ;jb RTIME_BUTTON, CHECK_RTIME_END ; if button not pressed, stop checking
0545            308            ;Wait_Milli_Seconds(#50) ; debounce time
0545            309            ;jb RTIME_BUTTON, CHECK_RTIME_END ; if button not pressed, stop checking
0545            310            ;jnb RTIME_BUTTON, $ ; loop while the button is pressed
0545            311       
0545            312       ;mov a, Time_refl ;increment RTime by 1
0545            313       ;add a, #0x01
0545            314       ;da a
0545            315       ;mov Time_refl, a
0545            316       ;cjne a, #0x3D, CHECK_RTIME_END
0545            317       ;mov Time_refl, #0x1E
0545            318       ;lcall Save_Configuration
0545 208418     319       jb RTIME_BUTTON, CHECK_RTIME_END
0548 C002       319            push AR2
054A 7A32       319            mov R2, #50
054C 120039     319            lcall ?Wait_Milli_Seconds
054F D002       319            pop AR2 ; de-bounce
0551 20840C     319       jb RTIME_BUTTON, CHECK_RTIME_END
0554 3084FD     319       jnb RTIME_BUTTON, $
0557 208004     319       jb SHIFT_BUTTON, skip20b
055A 1537       319       dec Time_refl
055C 8002       319       sjmp skip20a
055E            319       skip20b:
055E 0537       319       inc Time_refl
0560            319       skip20a:
0560            320   
0560            321   CHECK_RTIME_END:
0560 22         322   ret
0561            323   
0561            324   CHECK_RTEMP:
0561            325   
0561            326       ;jb RTEMP_BUTTON, CHECK_RTEMP_END ; if button not pressed, stop checking
0561            327            ;Wait_Milli_Seconds(#50) ; debounce time
0561            328            ;jb RTEMP_BUTTON, CHECK_RTEMP_END ; if button not pressed, stop checking
0561            329            ;jnb RTEMP_BUTTON, $ ; loop while the button is pressed
0561            330       
0561            331       ;mov a, Temp_refl ;increment RTemp by 5
0561            332       ;add a, #5
0561            333       ;da a
0561            334       ;mov Temp_refl, a
0561            335       ;cjne a, #255, CHECK_RTEMP_END
0561            336       ;mov Temp_refl, #220
0561            337       ;lcall Save_Configuration
0561            338   
0561 208618     339       jb RTEMP_BUTTON, CHECK_RTEMP_END
0564 C002       339            push AR2
0566 7A32       339            mov R2, #50
0568 120039     339            lcall ?Wait_Milli_Seconds
056B D002       339            pop AR2 ; de-bounce
056D 20860C     339       jb RTEMP_BUTTON, CHECK_RTEMP_END
0570 3086FD     339       jnb RTEMP_BUTTON, $
0573 208004     339       jb SHIFT_BUTTON, skip22b
0576 1536       339       dec Temp_refl
0578 8002       339       sjmp skip22a
057A            339       skip22b:
057A 0536       339       inc Temp_refl
057C            339       skip22a:
057C            340            
057C            341   CHECK_RTEMP_END:
057C 22         342   ret
057D            343   
057D            344   CHECK_POWER:
057D            345   
057D 20C512     346       jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
0580 C002       347            push AR2
0582 7A32       347            mov R2, #50
0584 120039     347            lcall ?Wait_Milli_Seconds
0587 D002       347            pop AR2 ; debounce time
0589 20C506     348            jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
058C 30C5FD     349            jnb POWER_BUTTON, $ ; loop while the button is pressed
058F 120875     350       lcall OFF_STATE
0592            351   
0592            352   CHECK_POWER_END:
0592 22         353   ret
0593            354   
0593            355   SOUND_FSM:
0593            356   state_0_sound:
0593            357   ;check if 5 seconds has passed, if yes go to state 1, if no exit function 
0593 300105     358       jnb five_seconds_flag, Sound_ret
0596 C201       359       clr five_seconds_flag
0598 02059C     360       ljmp state_1_sound
059B            361   Sound_ret:
059B 22         362       ret
059C            363   
059C            364   state_1_sound:
059C            365   ; check if temp is greater than 100, if yes go to state 2
059C            366   ; check if temp is less than 100, if yes go to state 4
059C E53B       367       mov a, Temp_oven
059E 9464       368       subb a, #100
05A0 5002       369       jnc state_2_sound
05A2 4026       370       jc state_4_sound
05A4            371   
05A4            372   state_2_sound:
05A4            373   ;divide temp by 100, if it is 1 play sound: "100", if it is 2 play sound: "200"
05A4            374   ; go to state_3_sound
05A4 75F064     375       mov b, #100
05A7 E53B       376       mov a, Temp_oven
05A9 84         377       div ab
05AA 9401       378       subb a, #1
05AC 600A       379       jz play_sound_1
05AE            380   
05AE 75F064     381       mov b, #100
05B1 E53B       382       mov a, Temp_oven
05B3 84         383       div ab
05B4 9402       384       subb a, #2
05B6 6000       385       jz play_sound_1
05B8            386      
05B8            387      play_sound_1: 
05B8 02060E     388       ljmp PLAYBACK_TEMP
05BB            389   
05BB 0205BE     390       ljmp state_3_sound
05BE            391   
05BE            392   
05BE            393   state_3_sound:
05BE            394   ; check remainder of temp, if it is 0, go back to state_0_sound
05BE            395   ; if not 0, go to state_4_sound
05BE            396   
05BE 75F064     397       mov b, #100
05C1 E53B       398       mov a, Temp_oven
05C3 84         399       div ab
05C4 E5F0       400       mov a, b
05C6 60CB       401       jz state_0_sound
05C8 7000       402       jnz state_4_sound
05CA            403   
05CA            404   state_4_sound:
05CA            405   ; if T % 100 greater or equal to 20, go to state_5_sound,
05CA 75F064     406       mov b, #100
05CD E53B       407       mov a, Temp_oven
05CF 84         408       div ab
05D0 E5F0       409       mov a, b 
05D2 9414       410       subb a, #20
05D4 5011       411       jnc state_5_sound
05D6 E4         412       clr a
05D7            413   ; if T % 100 is less than 10, go to state_6_sound
05D7 75F064     414       mov b, #100
05DA E53B       415       mov a, Temp_oven
05DC 84         416       div ab
05DD E5F0       417       mov a, b
05DF 940A       418       subb a, #10
05E1 401C       419       jc state_6_sound
05E3 E4         420       clr a
05E4            421   ; if T % 100 is greater than 10 and less than 20, go to state_7_sound
05E4 020605     422       ljmp state_7_sound
05E7            423       
05E7            424   
05E7            425   state_5_sound:
05E7            426   ; play number from 20 to 90 in decades (20, 30, 40, 50, 60, 70, 80, 90), based off remainder from temp divided by 100
05E7            427   ; if (T % 100) % 10 is not equal to 0, go to state_6_sound
05E7            428   ; if (T % 100) % 10 is equal to 0, go to state_8_sound
05E7            429   
05E7 E53B       430       mov a, Temp_oven
05E9 75F064     431       mov b, #100
05EC 84         432       div ab
05ED E5F0       433       mov a, b
05EF 75F00A     434       mov b, #10
05F2 84         435       div ab
05F3 E5F0       436       mov a, b
05F5 6002       437       jz play_sound
05F7 7006       438       jnz state_6_sound
05F9            439       
05F9            440   
05F9            441       play_sound:
05F9 02060E     442           ljmp PLAYBACK_TEMP
05FC 02060B     443           ljmp state_8_sound
05FF            444   
05FF            445   
05FF            446   state_6_sound:
05FF            447   ; play 1 - 9
05FF 02060E     448       ljmp PLAYBACK_TEMP
0602            449   ; go to state_8_sound
0602 02060B     450       ljmp state_8_sound
0605            451   
0605            452   
0605            453   state_7_sound:
0605            454   ; play 10 - 19
0605 02060E     455       ljmp PLAYBACK_TEMP
0608            456   ; go to state_8_sound 
0608 02060B     457       ljmp state_8_sound
060B            458   
060B            459   state_8_sound:
060B            460   ; go to state_0_sound
060B 020593     461       ljmp state_0_sound
060E            462   
060E            463   
060E            464   PLAYBACK_TEMP:
060E            465       
060E            466   ; ****INITIALIZATION****
060E            467   ; Configure SPI pins and turn off speaker
060E 53CECE     468            anl P2M0, #0b_1100_1110
0611 43CF31     469            orl P2M1, #0b_0011_0001
0614 D295       470            setb MY_MISO  ; Configured as input
0616 D280       471            setb FLASH_CE ; CS=1 for SPI flash memory
0618 C294       472            clr MY_SCLK   ; Rest state of SCLK=0
061A C2A6       473            clr SPEAKER   ; Turn off speaker.
061C            474            
061C            475            ; Configure timer 1
061C 53890F     476            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
061F 438910     477            orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
0622 758DFC     478            mov TH1, #high(TIMER1_RELOAD)
0625 758B15     479            mov TL1, #low(TIMER1_RELOAD)
0628            480            ; Set autoreload value
0628 75F5FC     481            mov RH1, #high(TIMER1_RELOAD)
062B 75F315     482            mov RL1, #low(TIMER1_RELOAD)
062E            483   
062E            484            ;Enable the timer and interrupts
062E D2AB       485       setb ET1  ; Enable timer 1 interrupt
0630 D28E       486            setb TR1 ; Timer 1 is only enabled to play stored sound
0632            487   
0632            488            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
0632 75A5A0     489            mov DADI, #0b_1010_0000 ; ACON=1
0635 75A43A     490            mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
0638 75AD80     491            mov DADH, #0x80 ; Middle of scale
063B 75AC00     492            mov DADL, #0
063E 43A440     493            orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
0641            494   
0641            495       ; ***play audio***
0641 C28E       496       clr TR1 ; Stop Timer 1 ISR from playing previous request
0643 D280       497       setb FLASH_CE 
0645 C2A6       498       clr SPEAKER ; Turn off speaker
0647            499   
0647 C280       500       clr FLASH_CE ; Enable SPI Flash
0649            501       ;mov READ_BYTES, #3
0649 7403       502       mov a, #READ_BYTES
064B 120494     503       lcall Send_SPI
064E            504       ; Set the initial position in memory where to start playing
064E            505       
064E 7400       506       mov a, #0x00 ; change initial position
0650 120494     507       lcall Send_SPI
0653 744B       508       mov a, #0x4b ; next memory position
0655 120494     509       lcall Send_SPI 
0658 7431       510       mov a, #0x31 ; next memory position
065A 120494     511       lcall Send_SPI
065D            512       ;mov a, %0+5
065D            513       ;lcall Send_SPI
065D            514       ;mov a, %0+6
065D            515       ;lcall Send_SPI
065D            516       ;mov a, %0+7
065D            517       ;lcall Send_SPI
065D 7400       518       mov a, #0x00 ; request first byte to send to DAC
065F 120494     519       lcall Send_SPI
0662            520   
0662            521       ; How many bytes to play?
0662 754D00     522       mov w+2, #0x00 ; Load the high byte of the number of bytes to play
0665 754C40     523       mov w+1, #0x40 ; Load the middle byte of the number of bytes to play
0668 754B99     524       mov w+0, #0x99 ; Load the low byte of the number of bytes to play
066B            525    
066B D2A6       526       setb SPEAKER ;Turn on speaker
066D D28E       527       setb TR1 ;Start playback by enabling Timer1 
066F            528       
066F            529   ;-------------------------------------------------------------------------------------------------------------------------------
066F            530   ;***LCD FXNS
066F            531   
                532   Display_lower_BCD mac
                533       push ar0
                534       mov r0, %0
                535       lcall ?Display_lower_BCD
                536       pop ar0
                537   endmac
066F            538   
066F            539   ?Display_lower_BCD:
066F C0E0       540       push acc
0671            541       ; write least significant digit
0671 E8         542       mov a, r0
0672 540F       543       anl a, #0fh
0674 4430       544       orl a, #30h
0676 12007E     545       lcall ?WriteData
0679 D0E0       546       pop acc
067B 22         547   ret
067C            548   
067C            549   
067C            550   SendToLCD:
067C 75F064     551       mov b, #100
067F 84         552       div ab
0680 4430       553       orl a, #0x30h ; Convert hundreds to ASCII
0682 12007E     554       lcall ?WriteData ; Send to LCD
0685 E5F0       555       mov a, b    ; Remainder is in register b
0687 75F00A     556       mov b, #10
068A 84         557       div ab
068B 4430       558       orl a, #0x30h ; Convert tens to ASCII
068D 12007E     559       lcall ?WriteData; Send to LCD
0690 E5F0       560       mov a, b
0692 4430       561       orl a, #0x30h ; Convert units to ASCII
0694 12007E     562       lcall ?WriteData; Send to LCD
0697 22         563   ret
0698            564   
0698            565   Initialize_State_Display:
0698            566   
0698            567       ;***clear the screen and set new display***
0698 7401       568            mov a, #0x01
069A 120083     568            lcall ?WriteCommand
069D C002       569            push AR2
069F 7A02       569            mov R2, #2
06A1 120039     569            lcall ?Wait_Milli_Seconds
06A4 D002       569            pop AR2
06A6            570       
06A6 C0E0       571            push acc
06A8 7401       571            mov a, #1
06AA 14         571            dec a
06AB 1200BF     571            lcall ?Set_Cursor_1 ; Select column and row
06AE D0E0       571            pop acc
06B0 C083       572            push dph
06B2 C082       572            push dpl
06B4 C0E0       572            push acc
06B6 900404     572            mov dptr, #time
06B9 1200B2     572            lcall ?Send_Constant_String
06BC D0E0       572            pop acc
06BE D082       572            pop dpl
06C0 D083       572            pop dph
06C2            573            
06C2 C0E0       574            push acc
06C4 7406       574            mov a, #6
06C6 14         574            dec a
06C7 1200BF     574            lcall ?Set_Cursor_1 ; Select column and row
06CA D0E0       574            pop acc
06CC C083       575            push dph
06CE C082       575            push dpl
06D0 C0E0       575            push acc
06D2 900409     575            mov dptr, #colon
06D5 1200B2     575            lcall ?Send_Constant_String
06D8 D0E0       575            pop acc
06DA D082       575            pop dpl
06DC D083       575            pop dph
06DE            576      
06DE C0E0       577            push acc
06E0 740A       577            mov a, #10
06E2 14         577            dec a
06E3 1200BF     577            lcall ?Set_Cursor_1 ; Select column and row
06E6 D0E0       577            pop acc
06E8 C083       578            push dph
06EA C082       578            push dpl
06EC C0E0       578            push acc
06EE 90040B     578            mov dptr, #temp
06F1 1200B2     578            lcall ?Send_Constant_String
06F4 D0E0       578            pop acc
06F6 D082       578            pop dpl
06F8 D083       578            pop dph
06FA            579       
06FA C0E0       580            push acc
06FC 7401       580            mov a, #1
06FE 14         580            dec a
06FF 1200BD     580            lcall ?Set_Cursor_2 ; Select column and row
0702 D0E0       580            pop acc
0704 C083       581            push dph
0706 C082       581            push dpl
0708 C0E0       581            push acc
070A 9003FD     581            mov dptr, #state
070D 1200B2     581            lcall ?Send_Constant_String
0710 D0E0       581            pop acc
0712 D082       581            pop dpl
0714 D083       581            pop dph
0716 22         582   ret
0717            583   
0717            584   Update_Display:
0717 C0E0       585            push acc
0719 7405       585            mov a, #5
071B 14         585            dec a
071C 1200BF     585            lcall ?Set_Cursor_1 ; Select column and row
071F D0E0       585            pop acc
0721 C000       586       push ar0
0723 A839       586       mov r0, Run_time_minutes
0725 12066F     586       lcall ?Display_lower_BCD
0728 D000       586       pop ar0
072A C0E0       587            push acc
072C 7407       587            mov a, #7
072E 14         587            dec a
072F 1200BF     587            lcall ?Set_Cursor_1 ; Select column and row
0732 D0E0       587            pop acc
0734 C000       588            push ar0
0736 A838       588            mov r0, Run_time_seconds
0738 1200C4     588            lcall ?Display_BCD
073B D000       588            pop ar0
073D            589       ;Set_Cursor(1,14)
073D            590       ;mov a, Temp_oven
073D            591       ;SendToLCD(Temp_oven)
073D 22         592   ret
073E            593   
073E            594   State0_display:
073E C0E0       595            push acc
0740 7401       595            mov a, #1
0742 14         595            dec a
0743 1200BF     595            lcall ?Set_Cursor_1 ; Select column and row
0746 D0E0       595            pop acc
0748 C083       596            push dph
074A C082       596            push dpl
074C C0E0       596            push acc
074E 9003E7     596            mov dptr, #STemp
0751 1200B2     596            lcall ?Send_Constant_String
0754 D0E0       596            pop acc
0756 D082       596            pop dpl
0758 D083       596            pop dph
075A C0E0       597            push acc
075C 7406       597            mov a, #6
075E 14         597            dec a
075F 1200BF     597            lcall ?Set_Cursor_1 ; Select column and row
0762 D0E0       597            pop acc
0764 E534       598       mov a, Temp_soak
0766 12067C     599       lcall SendToLCD
0769            600       
0769 C0E0       601            push acc
076B 740A       601            mov a, #10
076D 14         601            dec a
076E 1200BF     601            lcall ?Set_Cursor_1 ; Select column and row
0771 D0E0       601            pop acc
0773 C083       602            push dph
0775 C082       602            push dpl
0777 C0E0       602            push acc
0779 9003ED     602            mov dptr, #STime
077C 1200B2     602            lcall ?Send_Constant_String
077F D0E0       602            pop acc
0781 D082       602            pop dpl
0783 D083       602            pop dph
0785 C0E0       603            push acc
0787 740E       603            mov a, #14
0789 14         603            dec a
078A 1200BF     603            lcall ?Set_Cursor_1 ; Select column and row
078D D0E0       603            pop acc
078F E535       604       mov a, Time_soak
0791 12067C     605            lcall SendToLCD
0794            606       ;Display_BCD(Time_soak)
0794            607   
0794            608       ;Displays Reflow Temp and Time
0794 C0E0       609            push acc
0796 7401       609            mov a, #1
0798 14         609            dec a
0799 1200BD     609            lcall ?Set_Cursor_2 ; Select column and row
079C D0E0       609            pop acc
079E C083       610            push dph
07A0 C082       610            push dpl
07A2 C0E0       610            push acc
07A4 9003F2     610            mov dptr, #RTemp
07A7 1200B2     610            lcall ?Send_Constant_String
07AA D0E0       610            pop acc
07AC D082       610            pop dpl
07AE D083       610            pop dph
07B0 C0E0       611            push acc
07B2 7406       611            mov a, #6
07B4 14         611            dec a
07B5 1200BD     611            lcall ?Set_Cursor_2 ; Select column and row
07B8 D0E0       611            pop acc
07BA E536       612       mov a, Temp_refl
07BC 12067C     613       lcall SendToLCD
07BF            614       
07BF C0E0       615            push acc
07C1 740A       615            mov a, #10
07C3 14         615            dec a
07C4 1200BD     615            lcall ?Set_Cursor_2 ; Select column and row
07C7 D0E0       615            pop acc
07C9 C083       616            push dph
07CB C082       616            push dpl
07CD C0E0       616            push acc
07CF 9003F8     616            mov dptr, #RTime
07D2 1200B2     616            lcall ?Send_Constant_String
07D5 D0E0       616            pop acc
07D7 D082       616            pop dpl
07D9 D083       616            pop dph
07DB C0E0       617            push acc
07DD 740E       617            mov a, #14
07DF 14         617            dec a
07E0 1200BD     617            lcall ?Set_Cursor_2 ; Select column and row
07E3 D0E0       617            pop acc
07E5 E537       618       mov a, Time_refl
07E7 12067C     619            lcall SendToLCD
07EA 22         620   ret
07EB            621   
07EB            622   Display_3_digit_BCD:
07EB C0E0       623            push acc
07ED 740E       623            mov a, #14
07EF 14         623            dec a
07F0 1200BF     623            lcall ?Set_Cursor_1 ; Select column and row
07F3 D0E0       623            pop acc
07F5 C000       624       push ar0
07F7 A845       624       mov r0, bcd+1
07F9 12066F     624       lcall ?Display_lower_BCD
07FC D000       624       pop ar0
07FE C000       625            push ar0
0800 A844       625            mov r0, bcd+0
0802 1200C4     625            lcall ?Display_BCD
0805 D000       625            pop ar0
0807 22         626   ret
0808            627   
0808            628   
0808            629   
0808            630   ;The following functions store and restore the values--------------------------------------------------------------------------
                631   loadbyte mac
                632       mov a, %0
                633       movx @dptr, a
                634       inc dptr
                635   endmac
0808            636   
0808            637   Save_Configuration:
0808 C0A8       638       push IE ; Save the current state of bit EA in the stack
080A C2AF       639       clr EA ; Disable interrupts
080C 75D108     640       mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
080F 907F80     641       mov dptr, #0x7f80 ; Last page of flash memory
0812            642       ; Save variables
0812 E534       643       mov a, temp_soak
0814 F0         643       movx @dptr, a
0815 A3         643       inc dptr ; @0x7f80
0816 E535       644       mov a, time_soak
0818 F0         644       movx @dptr, a
0819 A3         644       inc dptr ; @0x7f81
081A E536       645       mov a, temp_refl
081C F0         645       movx @dptr, a
081D A3         645       inc dptr ; @0x7f82
081E E537       646       mov a, time_refl
0820 F0         646       movx @dptr, a
0821 A3         646       inc dptr ; @0x7f83
0822 7455       647       mov a, #0x55
0824 F0         647       movx @dptr, a
0825 A3         647       inc dptr ; First key value @0x7f84
0826 74AA       648       mov a, #0xAA
0828 F0         648       movx @dptr, a
0829 A3         648       inc dptr ; Second key value @0x7f85
082A 75D100     649       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0) 
082D 43D240     650       orl EECON, #0b01000000 ; Enable auto-erase on next write sequence  
0830 75D150     651       mov FCON, #0x50 ; Write trigger first byte
0833 75D1A0     652       mov FCON, #0xA0 ; Write trigger second byte
0836            653       ; CPU idles until writing of flash completes.
0836 75D100     654       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
0839 53D2BF     655       anl EECON, #0b10111111 ; Disable auto-erase
083C D0A8       656       pop IE ; Restore the state of bit EA from the stack
083E 22         657   ret
083F            658   
                659   getbyte mac
                660       clr a
                661       movc a, @a+dptr
                662       mov %0, a
                663       inc dptr
                664   endmac
083F            665   
083F            666   Load_Configuration:
083F 907F84     667       mov dptr, #0x7f84 ; First key value location.
0842 E4         668       clr a
0843 93         668       movc a, @a+dptr
0844 F8         668       mov R0, a
0845 A3         668       inc dptr ; 0x7f84 should contain 0x55
0846 B8551F     669       cjne R0, #0x55, Load_Defaults
0849 E4         670       clr a
084A 93         670       movc a, @a+dptr
084B F8         670       mov R0, a
084C A3         670       inc dptr ; 0x7f85 should contain 0xAA
084D B8AA18     671       cjne R0, #0xAA, Load_Defaults
0850            672   ; Keys are good.  Get stored values.
0850 907F80     673       mov dptr, #0x7f80
0853 E4         674       clr a
0854 93         674       movc a, @a+dptr
0855 F534       674       mov Temp_soak, a
0857 A3         674       inc dptr ; 0x7f80
0858 E4         675       clr a
0859 93         675       movc a, @a+dptr
085A F535       675       mov Time_soak, a
085C A3         675       inc dptr ; 0x7f81
085D E4         676       clr a
085E 93         676       movc a, @a+dptr
085F F536       676       mov Temp_refl, a
0861 A3         676       inc dptr ; 0x7f82
0862 E4         677       clr a
0863 93         677       movc a, @a+dptr
0864 F537       677       mov Time_refl, a
0866 A3         677       inc dptr ; 0x7f83
0867 22         678   ret
0868            679   
0868            680   Load_Defaults:
0868 753482     681       mov Temp_soak, #130 ; Soak Tmp Range is 130-170
086B 75353C     682       mov Time_soak, #0x3C ; Range 60-90 seconds
086E 7536DC     683       mov Temp_refl, #220 ; Range 220-240
0871 75371E     684       mov Time_refl, #0x1E ; Range 30-45 seconds
0874 22         685       ret 
0875            686   ;-------------------------------------------------------------------------------------------------------------------------------
0875            687   ;off state
0875            688   
0875            689   OFF_STATE:
0875            690       ;**CLEAR SCREEN**
0875 7401       691            mov a, #0x01
0877 120083     691            lcall ?WriteCommand
087A            692       ;**TURN OFF OVEN
087A C287       693       clr OVEN_POWER
087C            694       ;OFF_STATE1:
087C            695       
087C 20C5FD     696       jb POWER_BUTTON, $ ; loop while the button is not pressed
087F C002       697            push AR2
0881 7A32       697            mov R2, #50
0883 120039     697            lcall ?Wait_Milli_Seconds
0886 D002       697            pop AR2 ; debounce time
0888 20C5EA     698            jb POWER_BUTTON, OFF_STATE ; it was a bounce, try again
088B 30C5FD     699            jnb POWER_BUTTON, $ ; loop while the button is pressed
088E 0209E9     700       ljmp main
0891 22         701   ret
0892            702   ;-------------------------------------------------------------------------------------------------------------------------------
0892            703   
0892            704   ;***CHECK TEMPERATURE BY READING VOLTAGE AND CONVERTING
0892            705   Check_Temp:
0892            706       
0892 30007D     707       jnb one_seconds_flag, Check_Temp_done
0895 C200       708       clr one_seconds_flag
0897            709       
0897 C297       710       clr CE_ADC
0899 7801       711            mov R0, #00000001B ; Start bit:1
089B 12047B     712            lcall DO_SPI_G
089E 7880       713            mov R0, #10000000B ; Single ended, read channel 0
08A0 12047B     714            lcall DO_SPI_G
08A3 E9         715            mov a, R1          ; R1 contains bits 8 and 9
08A4 5403       716            anl a, #00000011B  ; We need only the two least significant bits
08A6 F54A       717            mov Result+1, a    ; Save result high.
08A8 7855       718            mov R0, #55H ; It doesn't matter what we transmit...
08AA 12047B     719            lcall DO_SPI_G
08AD 8949       720            mov Result, R1     ; R1 contains bits 0 to 7.  Save result low.
08AF D297       721            setb CE_ADC
08B1            722   
08B1 C002       723            push AR2
08B3 7A0A       723            mov R2, #10
08B5 120039     723            lcall ?Wait_Milli_Seconds
08B8 D002       723            pop AR2
08BA            724       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
08BA 85493C     725            mov x+0, result+0
08BD 854A3D     726            mov x+1, result+1
08C0 753E00     727            mov x+2, #0
08C3 753F00     728            mov x+3, #0
08C6            729            
08C6 754016     730            mov y+0, #low (22 % 0x10000) 
08C9 754100     730            mov y+1, #high(22 % 0x10000) 
08CC 754200     730            mov y+2, #low (22 / 0x10000) 
08CF 754300     730            mov y+3, #high(22 / 0x10000) 
08D2 1201B5     731       lcall add32
08D5            732   
08D5            733   ;Check_Temp_done_2:
08D5            734       ;jnb one_seconds_flag, Check_Temp_done
08D5            735       ;mov a, result+1
08D5            736       ;Set_Cursor(1,14)
08D5            737       ;lcall SendToLCD 
08D5            738       ;Set_Cursor(1,14)
08D5            739       ;mov a, x+0
08D5            740       ;lcall SendToLCD
08D5            741       ;mov Temp_oven, a
08D5            742       
08D5            743       ;mov a, States
08D5            744       ;cjne a, #0, Display_Temp_BCD
08D5            745       ;sjmp Send_Temp_Port
08D5            746            
08D5            747       ; The 4-bytes of x have the temperature in binary
08D5            748   Display_Temp_BCD:
08D5 1200F0     749            lcall hex2bcd ; converts binary in x to BCD in BCD
08D8            750   
08D8 1207EB     751       lcall Display_3_digit_BCD
08DB            752   
08DB            753   Send_Temp_Port:
08DB C000       754       push ar0
08DD A848       754       mov r0, bcd+4
08DF 1200DA     754       lcall ?Send_BCD
08E2 D000       754       pop ar0
08E4            754   
08E4 C000       755       push ar0
08E6 A847       755       mov r0, bcd+3
08E8 1200DA     755       lcall ?Send_BCD
08EB D000       755       pop ar0
08ED            755   
08ED C000       756       push ar0
08EF A846       756       mov r0, bcd+2
08F1 1200DA     756       lcall ?Send_BCD
08F4 D000       756       pop ar0
08F6            756   
08F6 C000       757       push ar0
08F8 A845       757       mov r0, bcd+1
08FA 1200DA     757       lcall ?Send_BCD
08FD D000       757       pop ar0
08FF            757   
08FF C000       758       push ar0
0901 A844       758       mov r0, bcd+0
0903 1200DA     758       lcall ?Send_BCD
0906 D000       758       pop ar0
0908            758   
0908 740D       759            mov a, #'\r'
090A 120505     760            lcall putchar
090D 740A       761            mov a, #'\n'
090F 120505     762            lcall putchar
0912            763   Check_Temp_done:
0912 22         764       ret
0913            765       
0913            766   
0913            767   ;-------------------------------------------------------------------------------------------------------------------------------
0913            768   
0913            769   ;Time wait
0913            770   
0913            771   Wait_One_Second:
0913 C002       772            push AR2
0915 7AFA       772            mov R2, #250
0917 120039     772            lcall ?Wait_Milli_Seconds
091A D002       772            pop AR2
091C C002       773            push AR2
091E 7AFA       773            mov R2, #250
0920 120039     773            lcall ?Wait_Milli_Seconds
0923 D002       773            pop AR2
0925 C002       774            push AR2
0927 7AFA       774            mov R2, #250
0929 120039     774            lcall ?Wait_Milli_Seconds
092C D002       774            pop AR2
092E C002       775            push AR2
0930 7AFA       775            mov R2, #250
0932 120039     775            lcall ?Wait_Milli_Seconds
0935 D002       775            pop AR2
0937 22         776   ret
0938            777   
0938            778   ; ==================================================================================================
0938            779   
0938            780   ;-------------------------------------;
0938            781   ; ISR for Timer 1.  Used to playback  ;
0938            782   ; the WAV file stored in the SPI      ;
0938            783   ; flash memory.                       ;
0938            784   ;-------------------------------------;
0938            785   Timer1_ISR:
0938            786            ; The registers used in the ISR must be saved in the stack
0938 C0E0       787            push acc
093A C0D0       788            push psw
093C            789            
093C            790            ; Check if the play counter is zero.  If so, stop playing sound.
093C E54B       791            mov a, w+0
093E 454C       792            orl a, w+1
0940 454D       793            orl a, w+2
0942 601E       794            jz stop_playing
0944            795            
0944            796            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0944 74FF       797            mov a, #0xff
0946 154B       798            dec w+0
0948 B54B07     799            cjne a, w+0, keep_playing
094B 154C       800            dec w+1
094D B54C02     801            cjne a, w+1, keep_playing
0950 154D       802            dec w+2
0952            803            
0952            804   keep_playing:
0952 D2A6       805            setb SPEAKER
0954 120494     806            lcall Send_SPI ; Read the next byte from the SPI Flash...
0957 F580       807            mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
0959 2480       808            add a, #0x80
095B F5AD       809            mov DADH, a ; Output to DAC. DAC output is pin P2.3
095D 43A440     810            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0960 800A       811            sjmp Timer1_ISR_Done
0962            812   
0962            813   stop_playing:
0962 C28E       814            clr TR1 ; Stop timer 1
0964            815            ;setb FLASH_CE  ; Disable SPI Flash
0964 C2A6       816            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
0966 75AD80     817            mov DADH, #0x80 ; middle of range
0969 43A440     818            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
096C            819   
096C            820   Timer1_ISR_Done:         
096C D0D0       821            pop psw
096E D0E0       822            pop acc
0970 32         823            reti
0971            824   ; ==================================================================================================
0971            825   
0971            826   ;---------------------------------;
0971            827   ; Routine to initialize the ISR   ;
0971            828   ; for timer 2                     ;
0971            829   ;---------------------------------;
0971            830   Timer2_init:
0971 75C800     831       mov T2CON, #0
0974 75CDA9     832       mov TH2, #high(TIMER2_RELOAD)
0977 75CC9A     833       mov TL2, #low(TIMER2_RELOAD)
097A            834   
097A 75CBA9     835       mov RCAP2H, #high(TIMER2_RELOAD)
097D 75CA9A     836       mov RCAP2L, #low(TIMER2_RELOAD)
0980            837   
0980 E4         838       clr a
0981 F530       839       mov Count1ms+0, a
0983 F531       840       mov Count1ms+1, a
0985 F532       841       mov Count5sec , a
0987 D2AD       842       setb ET2
0989 D2CA       843       setb TR2
098B C202       844       clr enable_clk
098D 22         845       ret
098E            846   
098E            847   ;---------------------------------;
098E            848   ; ISR for timer 2                 ;
098E            849   ;---------------------------------;
098E            850   Timer2_ISR:
098E C2CF       851       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0990 B290       852       cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0992            853            
0992            854            ; The two registers used in the ISR must be saved in the stack
0992 C0E0       855       push acc
0994 C0D0       856       push psw
0996            857            
0996            858            ; Increment the 16-bit one mili second counter
0996 0530       859            inc Count1ms+0    ; Increment the low 8-bits first
0998 E530       860            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
099A 7002       861            jnz Inc_Done
099C 0531       862            inc Count1ms+1
099E            863   
099E            864   Inc_Done:
099E            865   
099E            866   ;**Oven Power Output-------------------
099E            867       ; Do the PWM thing
099E            868            ; Check if Count1ms > pwm_ratio (this is a 16-bit compare)
099E C3         869            clr c
099F E54E       870            mov a, pwm_ratio+0
09A1 9530       871            subb a, Count1ms+0
09A3 E54F       872            mov a, pwm_ratio+1
09A5 9531       873            subb a, Count1ms+1
09A7            874            ; if Count1ms > pwm_ratio  the carry is set.  Just copy the carry to the pwm output pin:
09A7 9290       875            mov PWM_OUTPUT, c
09A9            876   ;**----------------------------------
09A9            877            ; Check if one second has passed
09A9 E530       878            mov a, Count1ms+0
09AB B4E836     879            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
09AE E531       880            mov a, Count1ms+1
09B0 B40331     881            cjne a, #high(1000), Timer2_ISR_done
09B3            882            
09B3            883            ; 1000 milliseconds have passed.  Set a flag so the main program knows
09B3 D200       884            setb one_seconds_flag ; Let the main program know one second had passed
09B5            885       
09B5 0532       886       inc Count5sec
09B7 E532       887       mov a, Count5sec
09B9 B40505     888       cjne a, #5, Set_5sec_flag_done
09BC D201       889       setb five_seconds_flag
09BE E4         890       clr a
09BF F532       891       mov Count5sec, a
09C1            892       
09C1            893   Set_5sec_flag_done:
09C1 E4         894            clr a
09C2 F530       895            mov Count1ms+0, a
09C4 F531       896            mov Count1ms+1, a
09C6            897   
09C6 30021B     898       jnb enable_clk, Timer2_ISR_done ;if the clk is enabled, increment the second. Otherwise skip
09C9            899   ; Increment the run time counter and state time counter
09C9 E538       900            mov a, Run_time_seconds
09CB 2401       901            add a, #0x01
09CD D4         902            da a
09CE F538       903       mov Run_time_seconds, a
09D0            904       ;check sec overflow
09D0 B4600A     905       cjne a, #0x60, Check_sec_overflow_done
09D3 753800     906       mov Run_time_seconds, #0x00
09D6 E539       907       mov a, Run_time_minutes ;inc min
09D8 2401       908       add a, #1
09DA D4         909       da a
09DB F539       910       mov Run_time_minutes, a
09DD            911   Check_sec_overflow_done:
09DD E53A       912            mov a, State_time
09DF 2401       913            add a, #0x01
09E1 D4         914            da a
09E2 F53A       915            mov State_time, a
09E4            916   Timer2_ISR_done:
09E4 D0D0       917            pop psw
09E6 D0E0       918            pop acc
09E8 32         919            reti
09E9            920   
09E9            921   
09E9            922   ; ==================================================================================================
09E9            923   
09E9            924   main:
09E9 75817F     925       mov SP, #0x7F
09EC 120971     926       lcall Timer2_Init
09EF 120476     927       lcall INI_SPI
09F2 120088     928       lcall LCD_4BIT
09F5 1204ED     929       lcall InitSerialPort
09F8            930       ; In case you decide to use the pins of P0, configure the port in bidirectional mode. Can be ignored
09F8 75E600     931       mov P0M0, #0
09FB 75E700     932       mov P0M1, #0
09FE D2AF       933       setb EA   ;Enable global enterupt
0A00            934   
0A00 12083F     935       lcall Load_Configuration
0A03            936   
0A03            937       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0A03 754E00     938            mov pwm_ratio+0, #low(0)
0A06 754F00     939            mov pwm_ratio+1, #high(0)
0A09 753300     940       mov States, #0
0A0C            941       
0A0C            942   state0: ; idle
0A0C            943       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0A0C 754E00     944            mov pwm_ratio+0, #low(0)
0A0F 754F00     945            mov pwm_ratio+1, #high(0)
0A12            946       ;mov States, #0
0A12            947   
0A12            948   ;***initial parameters displayed***
0A12            949       
0A12            950       ;Displays Soak Temp and Time
0A12 12073E     951       lcall State0_display
0A15            952       ;check power on
0A15 12057D     953       lcall CHECK_POWER
0A18            954       ; check the parameters being pressed
0A18 12050D     955       lcall CHECK_STIME
0A1B 120529     956       lcall CHECK_STEMP
0A1E 120545     957       lcall CHECK_RTIME
0A21 120561     958       lcall CHECK_RTEMP
0A24 120808     959       lcall Save_Configuration
0A27            960   
0A27 12060E     961       lcall PLAYBACK_TEMP
0A2A            962       
0A2A            963       ;lcall Check_Temp
0A2A            964   
0A2A 2085DF     965       jb NEXT_STATE_BUTTON, state0
0A2D C002       966            push AR2
0A2F 7A32       966            mov R2, #50
0A31 120039     966            lcall ?Wait_Milli_Seconds
0A34 D002       966            pop AR2 ; debounce time
0A36 2085D3     967            jb NEXT_STATE_BUTTON, state0 ; if button not pressed, loop
0A39 3085FD     968            jnb NEXT_STATE_BUTTON, $ 
0A3C            969   state0_done:
0A3C 753301     970       mov States, #1
0A3F 753A00     971       mov State_time, #0
0A42 D202       972       setb enable_clk
0A44            973      
0A44            974        
0A44            975   
0A44            976   state1_beginning:
0A44            977       
0A44            978       ;Start Run Time
0A44 753800     979       mov Run_time_seconds, #0 ; time starts at 0:00
0A47 753900     980       mov Run_time_minutes, #0
0A4A            981   
0A4A            982       ;***clear the screen and set new display***
0A4A 120698     983       lcall Initialize_State_Display
0A4D C0E0       984            push acc
0A4F 7407       984            mov a, #7
0A51 14         984            dec a
0A52 1200BD     984            lcall ?Set_Cursor_2 ; Select column and row
0A55 D0E0       984            pop acc
0A57 C083       985            push dph
0A59 C082       985            push dpl
0A5B C0E0       985            push acc
0A5D 90044E     985            mov dptr, #Ramp2Soak
0A60 1200B2     985            lcall ?Send_Constant_String
0A63 D0E0       985            pop acc
0A65 D082       985            pop dpl
0A67 D083       985            pop dph; displays current state
0A69            986   
0A69            987       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0A69 754EE8     988            mov pwm_ratio+0, #low(1000)
0A6C 754F03     989            mov pwm_ratio+1, #high(1000)
0A6F            990       
0A6F            991   
0A6F            992   state1: ; ramp to soak
0A6F            993       
0A6F            994       
0A6F            995       ;check power on
0A6F 12057D     996       lcall CHECK_POWER
0A72            997       ;Update Time and Temp
0A72 120717     998       lcall Update_Display
0A75 120892     999       lcall Check_Temp
0A78           1000   
0A78           1001       ; check if temp is below 150 
0A78           1002       ;MOV A, Temp_soak           
0A78           1003       ;SUBB A, Temp_soak       
0A78           1004       ;JNC state1_done    ; if greater, jump to state 2
0A78           1005       ;JZ state1_done ; if equal to, jump to state 2
0A78           1006       ;JC state1 ; if less than, go back to state1
0A78           1007   
0A78           1008   ;*Checking moving to states with buttons---- 
0A78           1009   ;*Will remove after proper temperature reading----
0A78           1010   
0A78 2085F4    1011       jb NEXT_STATE_BUTTON, state1
0A7B C002      1012            push AR2
0A7D 7A32      1012            mov R2, #50
0A7F 120039    1012            lcall ?Wait_Milli_Seconds
0A82 D002      1012            pop AR2 ; debounce time
0A84 2085E8    1013            jb NEXT_STATE_BUTTON, state1 ; if button not pressed, loop
0A87 3085FD    1014            jnb NEXT_STATE_BUTTON, $ 
0A8A           1015   
0A8A           1016   state1_done:
0A8A 753302    1017       mov States, #2
0A8D           1018       ;set State_time = 0
0A8D 8000      1019       sjmp state2_beginning
0A8F           1020   
0A8F           1021   ;OFF_STATE2:
0A8F           1022       ;ljmp OFF_STATE
0A8F           1023   
0A8F           1024   ; preheat/soak
0A8F           1025   state2_beginning: 
0A8F 753A00    1026       mov State_time, #0x00 ;clear the state time
0A92           1027       ;***clear the screen and set new display***
0A92 120698    1028       lcall Initialize_State_Display
0A95 C0E0      1029            push acc
0A97 7407      1029            mov a, #7
0A99 14        1029            dec a
0A9A 1200BD    1029            lcall ?Set_Cursor_2 ; Select column and row
0A9D D0E0      1029            pop acc
0A9F C083      1030            push dph
0AA1 C082      1030            push dpl
0AA3 C0E0      1030            push acc
0AA5 900458    1030            mov dptr, #Soak
0AA8 1200B2    1030            lcall ?Send_Constant_String
0AAB D0E0      1030            pop acc
0AAD D082      1030            pop dpl
0AAF D083      1030            pop dph ;displays current state
0AB1           1031   
0AB1           1032       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
0AB1 754EC8    1033            mov pwm_ratio+0, #low(200)
0AB4 754F00    1034            mov pwm_ratio+1, #high(000)
0AB7           1035   
0AB7           1036   state2:
0AB7           1037       ;check power on
0AB7 12057D    1038       lcall CHECK_POWER
0ABA           1039       
0ABA           1040       ;Update Time and Temp
0ABA 120717    1041       lcall Update_Display
0ABD           1042   
0ABD           1043       ;Set_Cursor(1,14)
0ABD           1044       ;mov a, Temp_oven
0ABD           1045       ;lcall SendToLCD
0ABD           1046   
0ABD           1047       ;on
0ABD           1048       ;setb OVEN_POWER
0ABD           1049       ;lcall Wait_One_Second
0ABD           1050       ;off
0ABD           1051       ;clr OVEN_POWER
0ABD           1052       ;mov r5, #0
0ABD           1053   ;four_sec_loop:
0ABD           1054       ; loop back to state2 if run time is less than soak time
0ABD           1055    ;   mov a, Time_soak
0ABD           1056     ;  subb a, State_time
0ABD           1057      ; cjne a, #0, state2
0ABD           1058       ;Set_Cursor(1,5)
0ABD           1059            ;Display_BCD(Run_time_minutes)
0ABD           1060       ;Set_Cursor(1,7)
0ABD           1061       ;Send_Constant_String(#colon)
0ABD           1062       ;Set_Cursor(1,8)
0ABD           1063       ;Display_BCD(Run_time_seconds)
0ABD           1064       ;Wait_Milli_Seconds(#250)
0ABD           1065       ;inc r5
0ABD           1066       ;cjne r5, #16, four_sec_loop
0ABD           1067           
0ABD           1068       
0ABD           1069       ; loop back to state2 if run time is less than soak time
0ABD           1070       ;mov a, Time_soak
0ABD           1071       ;subb a, State_time
0ABD           1072       ;cjne a, #0, state2
0ABD           1073   
0ABD           1074   ;*Checking moving to states with buttons---- 
0ABD           1075   ;*Will remove after proper temperature reading----
0ABD           1076   
0ABD 2085F7    1077       jb NEXT_STATE_BUTTON, state2
0AC0 C002      1078            push AR2
0AC2 7A32      1078            mov R2, #50
0AC4 120039    1078            lcall ?Wait_Milli_Seconds
0AC7 D002      1078            pop AR2 ; debounce time
0AC9 2085EB    1079            jb NEXT_STATE_BUTTON, state2 ; if button not pressed, loop
0ACC 3085FD    1080            jnb NEXT_STATE_BUTTON, $ 
0ACF           1081       
0ACF           1082   state2_done:
0ACF 753A00    1083       mov State_time, #0
0AD2 020AD5    1084       ljmp state3_beginning
0AD5           1085   
0AD5           1086   ; ramp to peak
0AD5           1087   state3_beginning:
0AD5 D287      1088       setb OVEN_POWER ;turn power on 100%
0AD7           1089   
0AD7           1090       ;***clear the screen and set new display***
0AD7 120698    1091       lcall Initialize_State_Display
0ADA C0E0      1092            push acc
0ADC 7407      1092            mov a, #7
0ADE 14        1092            dec a
0ADF 1200BD    1092            lcall ?Set_Cursor_2 ; Select column and row
0AE2 D0E0      1092            pop acc
0AE4 C083      1093            push dph
0AE6 C082      1093            push dpl
0AE8 C0E0      1093            push acc
0AEA 90045D    1093            mov dptr, #Ramp2Peak
0AED 1200B2    1093            lcall ?Send_Constant_String
0AF0 D0E0      1093            pop acc
0AF2 D082      1093            pop dpl
0AF4 D083      1093            pop dph
0AF6           1094   
0AF6           1095       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0AF6 754EE8    1096            mov pwm_ratio+0, #low(1000)
0AF9 754F03    1097            mov pwm_ratio+1, #high(1000)
0AFC           1098   
0AFC           1099   state3: 
0AFC           1100       ;check power on
0AFC 12057D    1101       lcall CHECK_POWER
0AFF           1102       
0AFF           1103       
0AFF           1104       ;Update Time and Temp
0AFF 120717    1105       lcall Update_Display
0B02           1106       
0B02           1107       ;mov a, Temp_oven
0B02           1108       ;subb a, Temp_refl 
0B02           1109       ;JNC state3_done    ; if greater, jump to state 4
0B02           1110       ;JZ state3_done ; if equal to, jump to state 4
0B02           1111       ;JC state3 ; if less than, go back to state3
0B02           1112       
0B02 2085F7    1113   jb NEXT_STATE_BUTTON, state3
0B05 C002      1114            push AR2
0B07 7A32      1114            mov R2, #50
0B09 120039    1114            lcall ?Wait_Milli_Seconds
0B0C D002      1114            pop AR2 ; debounce time
0B0E 2085EB    1115            jb NEXT_STATE_BUTTON, state3 ; if button not pressed, loop
0B11 3085FD    1116            jnb NEXT_STATE_BUTTON, $
0B14           1117   
0B14           1118   state3_done:
0B14 753A00    1119       mov State_time, #0
0B17 020B1A    1120       ljmp state4_beginning
0B1A           1121   
0B1A           1122   
0B1A           1123   ; reflow 
0B1A           1124   state4_beginning:
0B1A           1125       ;***clear the screen and set new display***
0B1A 120698    1126       lcall Initialize_State_Display
0B1D C0E0      1127            push acc
0B1F 7407      1127            mov a, #7
0B21 14        1127            dec a
0B22 1200BD    1127            lcall ?Set_Cursor_2 ; Select column and row
0B25 D0E0      1127            pop acc
0B27 C083      1128            push dph
0B29 C082      1128            push dpl
0B2B C0E0      1128            push acc
0B2D 900467    1128            mov dptr, #Reflow
0B30 1200B2    1128            lcall ?Send_Constant_String
0B33 D0E0      1128            pop acc
0B35 D082      1128            pop dpl
0B37 D083      1128            pop dph
0B39           1129   
0B39           1130       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
0B39 754EC8    1131            mov pwm_ratio+0, #low(200)
0B3C 754F00    1132            mov pwm_ratio+1, #high(000)
0B3F           1133   
0B3F           1134   
0B3F           1135   state4:
0B3F           1136       ;check power on
0B3F 12057D    1137       lcall CHECK_POWER
0B42           1138       ;Update Time and Temp
0B42 120717    1139       lcall Update_Display
0B45           1140   
0B45           1141       ;on
0B45           1142       ;setb OVEN_POWER
0B45           1143       ;lcall Wait_One_Second
0B45           1144       ;off
0B45           1145       ;clr OVEN_POWER
0B45           1146       ;mov r5, #0
0B45           1147       ;four_sec_loop2:
0B45           1148           ; loop back to state2 if run time is less than soak time
0B45           1149       ;    mov a, Time_refl
0B45           1150       ;    subb a, State_time
0B45           1151       ;   cjne a, #0, state4
0B45           1152       ;    Set_Cursor(1, 5)
0B45           1153            ;    Display_BCD(Run_time_minutes)
0B45           1154       ;    Set_Cursor(1,7)
0B45           1155       ;    Display_BCD(Run_time_seconds)
0B45           1156       ;    Wait_Milli_Seconds(#250)
0B45           1157   
0B45           1158       ;    inc r5
0B45           1159       ;    cjne r5, #16, four_sec_loop2
0B45           1160           
0B45           1161       
0B45           1162       ; loop back to state2 if run time is less than soak time
0B45           1163       ;mov a, Time_refl
0B45           1164       ;subb a, State_time
0B45           1165       ;cjne a, #0, state4
0B45           1166   
0B45           1167       ;*Checking moving to states with buttons---- 
0B45           1168   ;*Will remove after proper temperature reading----
0B45           1169   
0B45 2085F7    1170       jb NEXT_STATE_BUTTON, state4
0B48 C002      1171            push AR2
0B4A 7A32      1171            mov R2, #50
0B4C 120039    1171            lcall ?Wait_Milli_Seconds
0B4F D002      1171            pop AR2 ; debounce time
0B51 2085EB    1172            jb NEXT_STATE_BUTTON, state4 ; if button not pressed, loop
0B54 3085FD    1173            jnb NEXT_STATE_BUTTON, $ 
0B57           1174   
0B57           1175   state4_done: 
0B57 753A00    1176       mov State_time, #0
0B5A 020B5D    1177       ljmp state5_beginning 
0B5D           1178   
0B5D           1179   
0B5D           1180   ; cooling
0B5D           1181   state5_beginning: ; turn oven off
0B5D C287      1182       clr OVEN_POWER
0B5F           1183   
0B5F           1184   ;***clear the screen and set new display***
0B5F 120698    1185       lcall Initialize_State_Display
0B62 C083      1186            push dph
0B64 C082      1186            push dpl
0B66 C0E0      1186            push acc
0B68 90046E    1186            mov dptr, #Cooling
0B6B 1200B2    1186            lcall ?Send_Constant_String
0B6E D0E0      1186            pop acc
0B70 D082      1186            pop dpl
0B72 D083      1186            pop dph
0B74           1187   
0B74           1188       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0B74 754E00    1189            mov pwm_ratio+0, #low(0)
0B77 754F00    1190            mov pwm_ratio+1, #high(0)
0B7A           1191   
0B7A           1192   state5:
0B7A           1193       ;check power on
0B7A 12057D    1194       lcall CHECK_POWER
0B7D           1195       
0B7D           1196       ; update display
0B7D 120717    1197       lcall Update_Display
0B80           1198   
0B80           1199       ;mov a, Temp_oven
0B80           1200       ;subb a, #60
0B80           1201       ;JNC state5    ; if greater, jump back to state 5
0B80           1202       ;JZ state5 ; if equal to, go back to state5
0B80           1203       ;JC state5_done ; if less than, go back to state 0
0B80           1204   
0B80           1205       ;*Checking moving to states with buttons---- 
0B80           1206   ;*Will remove after proper temperature reading----
0B80           1207   
0B80 2085F7    1208       jb NEXT_STATE_BUTTON, state5
0B83 C002      1209            push AR2
0B85 7A32      1209            mov R2, #50
0B87 120039    1209            lcall ?Wait_Milli_Seconds
0B8A D002      1209            pop AR2 ; debounce time
0B8C 2085EB    1210            jb NEXT_STATE_BUTTON, state5 ; if button not pressed, loop
0B8F 3085FD    1211            jnb NEXT_STATE_BUTTON, $ 
0B92           1212   
0B92           1213   state5_done:
0B92 753A00    1214       mov State_time, #0
0B95 753300    1215       mov States, #0
0B98 0209E9    1216       ljmp main
0B9B           1217   
0B9B           1218   EN
