                  2   $LIST
0000              4   
0000              5   ;-------------------------------------------------------------------------------------------------------------------------------
0000              6   ;These EQU must match the wiring between the microcontroller and ADC
0000              7   CLK  EQU 22118400
0000              8   TIMER1_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000              9   TIMER1_RELOAD  EQU 0x10000-(CLK/TIMER1_RATE)
0000             10   BAUD equ 115200
0000             11   BRG_VAL equ (0x100-(CLK/(16*BAUD)))
0000             12   
0000             13   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             14   TIMER2_RELOAD EQU (65536-(CLK/TIMER2_RATE))
0000             15   
0000             16   
0000             17   ;-------------------------------------------------------------------------------------------------------------------------------
0000             18   ;Button Pin Mapping
0000             19   NEXT_STATE_BUTTON  equ P0.5
0000             20   STIME_BUTTON    equ P0.2
0000             21   STEMP_BUTTON    equ P0.3
0000             22   RTIME_BUTTON    equ P0.4
0000             23   RTEMP_BUTTON    equ P0.6
0000             24   POWER_BUTTON    equ P4.5
0000             25   SHIFT_BUTTON    equ p0.0
0000             26   
0000             27   ;Output Pins
0000             28   OVEN_POWER      equ P0.7
0000             29   SPEAKER         equ P2.6
0000             30   
0000             31   PWM_OUTPUT    equ P1.0 ; Attach an LED (with 1k resistor in series) to P1.0
0000             32   
0000             33   FLASH_CE        equ P0.0
0000             34   
0000             35   ;Thermowire Pins
0000             36   CE_ADC    EQU  P1.7
0000             37   MY_MOSI   EQU  P1.6
0000             38   MY_MISO   EQU  P1.5
0000             39   MY_SCLK   EQU  P1.4 
0000             40   
0000             41   ; Commands supported by the SPI flash memory according to the datasheet
0000             42   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             43   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             44   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             45   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             46   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             47   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             48   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             49   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             50   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             51   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             52   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             53   
0000             54   ; These 'equ' must match the hardware wiring
0000             55   LCD_RS equ P3.2
0000             56   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
0000             57   LCD_E  equ P3.3
0000             58   LCD_D4 equ P3.4
0000             59   LCD_D5 equ P3.5
0000             60   LCD_D6 equ P3.6
0000             61   LCD_D7 equ P3.7
0000             62   
0000             63   ;-------------------------------------------------------------------------------------------------------------------------------
0000             64   
0000             65   org 0x0000
0000 020877      66       ljmp main
0003             67   
0003             68   ; External interrupt 0 vector (not used in this code)
0003             69   org 0x0003
0003 32          70            reti
0004             71   
0004             72   ; Timer/Counter 0 overflow interrupt vector
000B             73   org 0x000B
000B 32          74            reti
000C             75   
000C             76   ; External interrupt 1 vector (not used in this code)
0013             77   org 0x0013
0013 32          78            reti
0014             79   
0014             80   ; Timer/Counter 1 overflow interrupt vector
001B             81   org 0x001B
001B 0207C6      82            ljmp Timer1_ISR
001E             83   
001E             84   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             85   org 0x0023 
0023 32          86            reti
0024             87            
0024             88   ; Timer/Counter 2 overflow interrupt vector
002B             89   org 0x002B
002B 02081C      90       ljmp Timer2_ISR
002E             91   ;-------------------------------------------------------------------------------------------------------------------------------
002E             92   ; Place our variables here
0030             93   DSEG at 0x30 ; Before the state machine!
0030             94   Count1ms:         ds 2 ; Used to determine when one second has passed
0032             95   Count5sec:         ds 1
0033             96   States:           ds 1
0034             97   Temp_soak:        ds 1
0035             98   Time_soak:        ds 1
0036             99   Temp_refl:        ds 1
0037            100   Time_refl:        ds 1
0038            101   Run_time_seconds: ds 1
0039            102   Run_time_minutes: ds 1
003A            103   State_time:       ds 1
003B            104   Temp_oven:        ds 1
003C            105   x:                ds 4
0040            106   y:                ds 4
0044            107   bcd:              ds 5
0049            108   Result:           ds 2
004B            109   w:                ds 3
004E            110   pwm_ratio:        ds 2
0050            111   
                113   $LIST
00F0            115   
                546   $LIST
                117   $LIST
0360            119   
0000            120   bseg
0000            121   one_seconds_flag:  dbit 1
0001            122   five_seconds_flag: dbit 1
0002            123   enable_clk:        dbit 1
0003            124   mf:                dbit 1
0004            125   
0360            126   cseg
0360            127   
0360            128   ;-------------------------------------------------------------------------------------------------------------------------------
0360            129   ;***Messages To Display*** 
0360            130   
0360            131   ;shortened labels
0360 53546D70   132   STemp:  db 'STmp:', 0
     3A00
0366 53546D3A   133   STime:  db 'STm:', 0
     00
036B 52546D70   134   RTemp:  db 'RTmp:', 0
     3A00
0371 52546D3A   135   RTime:  db 'RTm:', 0
     00
0376            136   
0376            137   ;lables for runnning oven
0376 53746174   138   state:     db 'State>' , 0
     653E00
037D 546D653E   139   time:      db 'Tme>' , 0
     00
0382 3A00       140   colon:     db ':', 0
0384 546D703E   141   temp:      db 'Tmp>', 0
     00
0389            142   
0389            143   ;labels for changin parameters
0389 5265666C   144   ReflowTemp:  db 'Reflow Temperature:', 0
     6F772054
     656D7065
     72617475
     72653A00
039D 5265666C   145   ReflowTime:  db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03AA 536F616B   146   SoakTime:    db 'Soak Time:', 0
     2054696D
     653A00
03B5 536F616B   147   SoakTemp:    db 'Soak Temperature:', 0
     2054656D
     70657261
     74757265
     3A00
03C7            148   
03C7            149   
03C7            150   ;Current State in Oven
03C7 52616D70   151   Ramp2Soak: db 'Ramp-Soak' , 0
     2D536F61
     6B00
03D1 536F616B   152   Soak:      db 'Soak' , 0
     00
03D6 52616D70   153   Ramp2Peak: db 'Ramp-Peak' , 0
     2D506561
     6B00
03E0 5265666C   154   Reflow:    db 'Reflow' , 0
     6F7700
03E7 436F6F6C   155   Cooling:   db 'Cooling' , 0
     696E6700
03EF            156   
03EF            157   ;-------------------------------------------------------------------------------------------------------------------------------
03EF            158   ;FXNS FOR THERMOWIRE
03EF            159   
03EF            160   ;initialize SPI 
03EF            161   INI_SPI:
03EF D295       162            setb MY_MISO ; Make MISO an input pin
03F1 C294       163            clr MY_SCLK           ; Mode 0,0 default
03F3 22         164            ret
03F4            165   DO_SPI_G:
03F4 C0E0       166            push acc
03F6 7900       167            mov R1, #0 ; Received byte stored in R1
03F8 7A08       168            mov R2, #8            ; Loop counter (8-bits)
03FA            169   DO_SPI_G_LOOP:
03FA E8         170            mov a, R0             ; Byte to write is in R0
03FB 33         171            rlc a                 ; Carry flag has bit to write
03FC F8         172            mov R0, a
03FD 9296       173            mov MY_MOSI, c
03FF D294       174            setb MY_SCLK          ; Transmit
0401 A295       175            mov c, MY_MISO        ; Read received bit
0403 E9         176            mov a, R1             ; Save received bit in R1
0404 33         177            rlc a
0405 F9         178            mov R1, a
0406 C294       179            clr MY_SCLK
0408 DAF0       180            djnz R2, DO_SPI_G_LOOP
040A D0E0       181            pop acc
040C 22         182   ret
040D            183   
040D            184   Send_SPI:
                185   	SPIBIT MAC
                186   	    ; Send/Receive bit %0
                187   		rlc a
                188   		mov MY_MOSI, c
                189   		setb MY_SCLK
                190   		mov c, MY_MISO
                191   		clr MY_SCLK
                192   		mov acc.0, c
                193   	ENDMAC
040D            194            
040D            195                ; Send/Receive bit 7
040D 33         195                    rlc a
040E 9296       195                    mov MY_MOSI, c
0410 D294       195                    setb MY_SCLK
0412 A295       195                    mov c, MY_MISO
0414 C294       195                    clr MY_SCLK
0416 92E0       195                    mov acc.0, c
0418            196                ; Send/Receive bit 6
0418 33         196                    rlc a
0419 9296       196                    mov MY_MOSI, c
041B D294       196                    setb MY_SCLK
041D A295       196                    mov c, MY_MISO
041F C294       196                    clr MY_SCLK
0421 92E0       196                    mov acc.0, c
0423            197                ; Send/Receive bit 5
0423 33         197                    rlc a
0424 9296       197                    mov MY_MOSI, c
0426 D294       197                    setb MY_SCLK
0428 A295       197                    mov c, MY_MISO
042A C294       197                    clr MY_SCLK
042C 92E0       197                    mov acc.0, c
042E            198                ; Send/Receive bit 4
042E 33         198                    rlc a
042F 9296       198                    mov MY_MOSI, c
0431 D294       198                    setb MY_SCLK
0433 A295       198                    mov c, MY_MISO
0435 C294       198                    clr MY_SCLK
0437 92E0       198                    mov acc.0, c
0439            199                ; Send/Receive bit 3
0439 33         199                    rlc a
043A 9296       199                    mov MY_MOSI, c
043C D294       199                    setb MY_SCLK
043E A295       199                    mov c, MY_MISO
0440 C294       199                    clr MY_SCLK
0442 92E0       199                    mov acc.0, c
0444            200                ; Send/Receive bit 2
0444 33         200                    rlc a
0445 9296       200                    mov MY_MOSI, c
0447 D294       200                    setb MY_SCLK
0449 A295       200                    mov c, MY_MISO
044B C294       200                    clr MY_SCLK
044D 92E0       200                    mov acc.0, c
044F            201                ; Send/Receive bit 1
044F 33         201                    rlc a
0450 9296       201                    mov MY_MOSI, c
0452 D294       201                    setb MY_SCLK
0454 A295       201                    mov c, MY_MISO
0456 C294       201                    clr MY_SCLK
0458 92E0       201                    mov acc.0, c
045A            202                ; Send/Receive bit 0
045A 33         202                    rlc a
045B 9296       202                    mov MY_MOSI, c
045D D294       202                    setb MY_SCLK
045F A295       202                    mov c, MY_MISO
0461 C294       202                    clr MY_SCLK
0463 92E0       202                    mov acc.0, c
0465            203   
0465 22         204   ret
0466            205   
                206   Change_8bit_Variable MAC
                207       jb %0, %2
                208       Wait_Milli_Seconds(#50) ; de-bounce
                209       jb %0, %2
                210       jnb %0, $
                211       jb SHIFT_BUTTON, skip%Mb
                212       dec %1
                213       sjmp skip%Ma
                214       skip%Mb:
                215       inc %1
                216       skip%Ma:
                217   ENDMAC
0466            218   
0466            219   ;Change_8bit_Variable(MY_VARIABLE_BUTTON, my_variable, loop_c)
0466            220   ;    Set_Cursor(2, 14)
0466            221   ;    mov a, my_variable
0466            222   ;    lcall SendToLCD
0466            223   ;lcall Save_Configuration
0466            224   
0466            225   ;-------------------------------------------------------------------------------------------------------------------------------
0466            226   ;***FXNS For Serial Port
0466            227   
0466            228   ; Configure the serial port and baud rate
0466            229   InitSerialPort:
0466            230       ; Since the reset button bounces, we need to wait a bit before
0466            231       ; sending messages, otherwise we risk displaying gibberish!
0466 79DE       232       mov R1, #222
0468 78A6       233       mov R0, #166
046A D8FE       234       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
046C D9FA       235       djnz R1, $-4 ; 22.51519us*222=4.998ms
046E            236       ; Now we can proceed with the configuration
046E 438780     237            orl     PCON,#0x80
0471 759852     238            mov     SCON,#0x52
0474 759B00     239            mov     BDRCON,#0x00
0477 759AF4     240            mov     BRL,#BRG_VAL
047A 759B1E     241            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
047D 22         242   ret
047E            243   
047E            244   
047E            245   putchar:
047E 3099FD     246       jnb TI, putchar
0481 C299       247       clr TI
0483 F599       248       mov SBUF, a
0485 22         249   ret
0486            250   
0486            251   ;-------------------------------------------------------------------------------------------------------------------------------
0486            252   ;***FXNS to CHECK BUTTONS
0486            253   
0486            254   CHECK_STIME:
0486            255   
0486            256       ;jb STIME_BUTTON, CHECK_STIME_END ; if button not pressed, stop checking
0486            257            ;Wait_Milli_Seconds(#50) ; debounce time
0486            258            ;jb STIME_BUTTON, CHECK_STIME_END ; if button not pressed, stop checking
0486            259            ;jnb STIME_BUTTON, $ ; loop while the button is pressed
0486            260       
0486            261       ;inc Time_soak
0486            262   
0486            263       ;mov a, Time_soak ;increment STime by 1
0486            264       ;add a, #0x01
0486            265       ;da a
0486            266       ;mov Time_soak, a
0486            267       ;cjne a, #0x5B, CHECK_STIME_END
0486            268       ;mov Time_soak, #0x3C
0486            269       ;lcall Save_Configuration
0486            270   
0486 208218     271       jb STIME_BUTTON, CHECK_STIME_END
0489 C002       271            push AR2
048B 7A32       271            mov R2, #50
048D 120039     271            lcall ?Wait_Milli_Seconds
0490 D002       271            pop AR2 ; de-bounce
0492 20820C     271       jb STIME_BUTTON, CHECK_STIME_END
0495 3082FD     271       jnb STIME_BUTTON, $
0498 208004     271       jb SHIFT_BUTTON, skip16b
049B 1535       271       dec Time_soak
049D 8002       271       sjmp skip16a
049F            271       skip16b:
049F 0535       271       inc Time_soak
04A1            271       skip16a:
04A1            272       ;mov a, Time_soak
04A1            273       ;lcall SendToLCD
04A1            274       ;lcall Save_Configuration
04A1            275            
04A1            276   CHECK_STIME_END:
04A1 22         277   ret
04A2            278   
04A2            279   CHECK_STEMP:
04A2            280   
04A2            281       ;jb STEMP_BUTTON, CHECK_STEMP_END ; if button not pressed, stop checking
04A2            282            ;Wait_Milli_Seconds(#50) ; debounce time
04A2            283            ;jb STEMP_BUTTON, CHECK_STEMP_END ; if button not pressed, stop checking
04A2            284            ;jnb STEMP_BUTTON, $ ; loop while the button is pressed
04A2            285       
04A2            286       ;mov a, Temp_soak ;increment STEMP by 5
04A2            287       ;add a, #5
04A2            288       ;da a
04A2            289       ;mov Temp_soak, a
04A2            290       ;cjne a, #175, CHECK_STEMP_END
04A2            291       ;mov Temp_soak, #130
04A2            292   
04A2 208318     293       jb STEMP_BUTTON, CHECK_STEMP_END
04A5 C002       293            push AR2
04A7 7A32       293            mov R2, #50
04A9 120039     293            lcall ?Wait_Milli_Seconds
04AC D002       293            pop AR2 ; de-bounce
04AE 20830C     293       jb STEMP_BUTTON, CHECK_STEMP_END
04B1 3083FD     293       jnb STEMP_BUTTON, $
04B4 208004     293       jb SHIFT_BUTTON, skip18b
04B7 1534       293       dec Temp_soak
04B9 8002       293       sjmp skip18a
04BB            293       skip18b:
04BB 0534       293       inc Temp_soak
04BD            293       skip18a:
04BD            294       ;lcall Save_Configuration
04BD            295            
04BD            296   CHECK_STEMP_END:
04BD 22         297   ret
04BE            298   
04BE            299   CHECK_RTIME:
04BE            300   
04BE            301       ;jb RTIME_BUTTON, CHECK_RTIME_END ; if button not pressed, stop checking
04BE            302            ;Wait_Milli_Seconds(#50) ; debounce time
04BE            303            ;jb RTIME_BUTTON, CHECK_RTIME_END ; if button not pressed, stop checking
04BE            304            ;jnb RTIME_BUTTON, $ ; loop while the button is pressed
04BE            305       
04BE            306       ;mov a, Time_refl ;increment RTime by 1
04BE            307       ;add a, #0x01
04BE            308       ;da a
04BE            309       ;mov Time_refl, a
04BE            310       ;cjne a, #0x3D, CHECK_RTIME_END
04BE            311       ;mov Time_refl, #0x1E
04BE            312       ;lcall Save_Configuration
04BE 208418     313       jb RTIME_BUTTON, CHECK_RTIME_END
04C1 C002       313            push AR2
04C3 7A32       313            mov R2, #50
04C5 120039     313            lcall ?Wait_Milli_Seconds
04C8 D002       313            pop AR2 ; de-bounce
04CA 20840C     313       jb RTIME_BUTTON, CHECK_RTIME_END
04CD 3084FD     313       jnb RTIME_BUTTON, $
04D0 208004     313       jb SHIFT_BUTTON, skip20b
04D3 1537       313       dec Time_refl
04D5 8002       313       sjmp skip20a
04D7            313       skip20b:
04D7 0537       313       inc Time_refl
04D9            313       skip20a:
04D9            314   
04D9            315   CHECK_RTIME_END:
04D9 22         316   ret
04DA            317   
04DA            318   CHECK_RTEMP:
04DA            319   
04DA            320       ;jb RTEMP_BUTTON, CHECK_RTEMP_END ; if button not pressed, stop checking
04DA            321            ;Wait_Milli_Seconds(#50) ; debounce time
04DA            322            ;jb RTEMP_BUTTON, CHECK_RTEMP_END ; if button not pressed, stop checking
04DA            323            ;jnb RTEMP_BUTTON, $ ; loop while the button is pressed
04DA            324       
04DA            325       ;mov a, Temp_refl ;increment RTemp by 5
04DA            326       ;add a, #5
04DA            327       ;da a
04DA            328       ;mov Temp_refl, a
04DA            329       ;cjne a, #255, CHECK_RTEMP_END
04DA            330       ;mov Temp_refl, #220
04DA            331       ;lcall Save_Configuration
04DA            332   
04DA 208618     333       jb RTEMP_BUTTON, CHECK_RTEMP_END
04DD C002       333            push AR2
04DF 7A32       333            mov R2, #50
04E1 120039     333            lcall ?Wait_Milli_Seconds
04E4 D002       333            pop AR2 ; de-bounce
04E6 20860C     333       jb RTEMP_BUTTON, CHECK_RTEMP_END
04E9 3086FD     333       jnb RTEMP_BUTTON, $
04EC 208004     333       jb SHIFT_BUTTON, skip22b
04EF 1536       333       dec Temp_refl
04F1 8002       333       sjmp skip22a
04F3            333       skip22b:
04F3 0536       333       inc Temp_refl
04F5            333       skip22a:
04F5            334            
04F5            335   CHECK_RTEMP_END:
04F5 22         336   ret
04F6            337   
04F6            338   CHECK_POWER:
04F6            339   
04F6 20C512     340       jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
04F9 C002       341            push AR2
04FB 7A32       341            mov R2, #50
04FD 120039     341            lcall ?Wait_Milli_Seconds
0500 D002       341            pop AR2 ; debounce time
0502 20C506     342            jb POWER_BUTTON, CHECK_POWER_END ; if button not pressed, stop checking
0505 30C5FD     343            jnb POWER_BUTTON, $ ; loop while the button is pressed
0508 120712     344       lcall OFF_STATE
050B            345   
050B            346   CHECK_POWER_END:
050B 22         347   ret
050C            348   
050C            349   ;SOUND_FSM:
050C            350   ;state_0_sound:
050C            351   ; check if 5 seconds has passed, if yes go to state 1
050C            352   ;cjne Run_time_seconds, #5, state_0_sound
050C            353   ;lcall state_1_sound
050C            354   
050C            355   ;state_1_sound:
050C            356   ; check if temp is greater than 100, if yes go to state 2
050C            357   ; check if temp is less than 100, if yes go to state 5
050C            358   ; mov a, Temp_oven
050C            359   ; subb a, #100
050C            360   ; jnc state_2_sound
050C            361   ; jc state_5_sound
050C            362   
050C            363   ;state_2_sound:
050C            364   ; divide temp by 100, if it is 1 play sound: "100", if it is 2 play sound: "200"
050C            365   ; go to state_3_sound
050C            366   ; mov a, Temp_oven
050C            367   ; load_X(a)
050C            368   ; load_y(#100)
050C            369   ; lcall div32
050C            370   ; subb a, #1
050C            371   ; jz "play sound 100"
050C            372   ; subb a, #2
050C            373   ; jz "play sound 200"
050C            374   ; lcall state_3_sound
050C            375   
050C            376   ;state_3_sound:
050C            377   ; check remainder of temp, if it is 0, go back to state_0_sound
050C            378       ; ***how to get remainder of 23/4***
050C            379       ; integer division of 23 and 4 = 5
050C            380       ; multiply 5 by 4 = 20
050C            381       ; subtract 23 by 20 = 3 <--- remainder
050C            382   ; if not 0, go to state_4_sound
050C            383   
050C            384   ; mov a, Temp_oven 
050C            385   ; load_X(a)
050C            386   ; load_y(#100)
050C            387   ; lcall div32
050C            388   ; load_X(a)
050C            389   ; load_y(#100)
050C            390   ; lcall mul32
050C            391   ; mov r0, a 
050C            392   ; mov a, Temp_oven
050C            393   ; subb a, r0
050C            394   ; jz state_0_sound
050C            395   ; jnz state_4_sound
050C            396   
050C            397   ; state_4_sound;
050C            398   ; check if the remainder of temp divided by 100 is greater or equal to than 20, if yes go to state_7_sound
050C            399   ; if not go to state_5_sound
050C            400   
050C            401   ; load_X(a)
050C            402   ; load_y(#100)
050C            403   ; subb a, #20
050C            404   ; jnc state_7_sound
050C            405   ; jz state_7_sound
050C            406   ; jc state_5_sound
050C            407   
050C            408   ; state_5_sound;
050C            409   ; play number from 1 to 19, based off remainder from temp divided by 100
050C            410   ; go to state_6_sound
050C            411   
050C            412   ; state_6_sound; 
050C            413   ; go to state_0_sound
050C            414   
050C            415   ; lcall state_0_sound
050C            416   
050C            417   ; state_7_sound;
050C            418   ; play tenths number, by dividing temp by 100 finding the remainder, then dividing the remainder by 10, and correponding the value to the correct 20 - 90 value
050C            419   ; go to state_8_sound
050C            420   
050C            421   ; state_8_sound;
050C            422   ; check if there is a ones remainder, if yes go to state_9_sound
050C            423   ; if not go to state_0_sound
050C            424   
050C            425   ; state_9_sound
050C            426   ; play ones remainder
050C            427   
050C            428   
050C            429   ;PLAYBACK_TEMP MAC
050C            430   ;    mov r0, %0
050C            431   ; ****INITIALIZATION****
050C            432   ; Configure SPI pins and turn off speaker
050C            433   ;        anl P2M0, #0b_1100_1110
050C            434   ;        orl P2M1, #0b_0011_0001
050C            435   ;        setb MY_MISO  ; Configured as input
050C            436   ;        setb FLASH_CE ; CS=1 for SPI flash memory
050C            437   ;        clr MY_SCLK   ; Rest state of SCLK=0
050C            438   ;        clr SPEAKER   ; Turn off speaker.
050C            439            
050C            440            ; Configure timer 1
050C            441   ;        anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
050C            442   ;        orl     TMOD, #0x10 ; Set timer 1 in 16-bit timer mode.  Don't change the bits of timer 0
050C            443   ;        mov TH1, #high(TIMER1_RELOAD)
050C            444   ;        mov TL1, #low(TIMER1_RELOAD)
050C            445            ; Set autoreload value
050C            446   ;        mov RH1, #high(TIMER1_RELOAD)
050C            447   ;        mov RL1, #low(TIMER1_RELOAD)
050C            448   
050C            449            ; Enable the timer and interrupts
050C            450   ;    setb ET1  ; Enable timer 1 interrupt
050C            451            ; setb TR1 ; Timer 1 is only enabled to play stored sound
050C            452   
050C            453            ; Configure the DAC.  The DAC output we are using is P2.3, but P2.2 is also reserved.
050C            454   ;        mov DADI, #0b_1010_0000 ; ACON=1
050C            455   ;        mov DADC, #0b_0011_1010 ; Enabled, DAC mode, Left adjusted, CLK/4
050C            456   ;        mov DADH, #0x80 ; Middle of scale
050C            457   ;        mov DADL, #0
050C            458   ;        ;orl DADC, #0b_0100_0000 ; Start DAC by GO/BSY=1
050C            459   
050C            460       ; ***play audio***
050C            461       ;clr TR1 ; Stop Timer 1 ISR from playing previous request
050C            462       ;setb FLASH_CE 
050C            463       ;clr SPEAKER ; Turn off speaker
050C            464   
050C            465       ;clr FLASH_CE ; Enable SPI Flash
050C            466       ;mov READ_BYTES, #3
050C            467       ;mov a, #READ_BYTES
050C            468       ;lcall Send_SPI
050C            469       ; Set the initial position in memory where to start playing
050C            470       
050C            471      ; mov a, %0 ; change initial position
050C            472     ;  lcall Send_SPI
050C            473    ;   mov a, %0+1 ; next memory position
050C            474   ;    lcall Send_SPI 
050C            475   ;    mov a, %0+2 ; next memory position
050C            476   ;    lcall Send_SPI
050C            477   ;    mov a, %0+3 ; next memory position
050C            478   ;    lcall Send_SPI 
050C            479   ;    mov a, %0+4
050C            480   ;    lcall Send_SPI
050C            481   ;    mov a, %0+5
050C            482   ;    lcall Send_SPI
050C            483   ;    mov a, %0+6
050C            484   ;    lcall Send_SPI
050C            485   ;    mov a, %0+7
050C            486   ;    lcall Send_SPI
050C            487   ;    mov a, %0 ; request first byte to send to DAC
050C            488   ;    lcall Send_SPI
050C            489   
050C            490       ; How many bytes to play?
050C            491       ;mov w+2, #0x3f //63
050C            492       ;mov w+1, #0xff //255
050C            493       ;mov w+0, #0xff 
050C            494    
050C            495       ;setb SPEAKER ;Turn on speaker
050C            496       ;setb TR1 ;Start playback by enabling Timer1  
050C            497       
050C            498   ;-------------------------------------------------------------------------------------------------------------------------------
050C            499   ;***LCD FXNS
050C            500   
                501   Display_lower_BCD mac
                502       push ar0
                503       mov r0, %0
                504       lcall ?Display_lower_BCD
                505       pop ar0
                506   endmac
050C            507   
050C            508   ?Display_lower_BCD:
050C C0E0       509       push acc
050E            510       ; write least significant digit
050E E8         511       mov a, r0
050F 540F       512       anl a, #0fh
0511 4430       513       orl a, #30h
0513 12007E     514       lcall ?WriteData
0516 D0E0       515       pop acc
0518 22         516   ret
0519            517   
0519            518   
0519            519   SendToLCD:
0519 75F064     520       mov b, #100
051C 84         521       div ab
051D 4430       522       orl a, #0x30h ; Convert hundreds to ASCII
051F 12007E     523       lcall ?WriteData ; Send to LCD
0522 E5F0       524       mov a, b    ; Remainder is in register b
0524 75F00A     525       mov b, #10
0527 84         526       div ab
0528 4430       527       orl a, #0x30h ; Convert tens to ASCII
052A 12007E     528       lcall ?WriteData; Send to LCD
052D E5F0       529       mov a, b
052F 4430       530       orl a, #0x30h ; Convert units to ASCII
0531 12007E     531       lcall ?WriteData; Send to LCD
0534 22         532   ret
0535            533   
0535            534   Initialize_State_Display:
0535            535   
0535            536       ;***clear the screen and set new display***
0535 7401       537            mov a, #0x01
0537 120083     537            lcall ?WriteCommand
053A C002       538            push AR2
053C 7A02       538            mov R2, #2
053E 120039     538            lcall ?Wait_Milli_Seconds
0541 D002       538            pop AR2
0543            539       
0543 C0E0       540            push acc
0545 7401       540            mov a, #1
0547 14         540            dec a
0548 1200BF     540            lcall ?Set_Cursor_1 ; Select column and row
054B D0E0       540            pop acc
054D C083       541            push dph
054F C082       541            push dpl
0551 C0E0       541            push acc
0553 90037D     541            mov dptr, #time
0556 1200B2     541            lcall ?Send_Constant_String
0559 D0E0       541            pop acc
055B D082       541            pop dpl
055D D083       541            pop dph
055F            542            
055F C0E0       543            push acc
0561 7406       543            mov a, #6
0563 14         543            dec a
0564 1200BF     543            lcall ?Set_Cursor_1 ; Select column and row
0567 D0E0       543            pop acc
0569 C083       544            push dph
056B C082       544            push dpl
056D C0E0       544            push acc
056F 900382     544            mov dptr, #colon
0572 1200B2     544            lcall ?Send_Constant_String
0575 D0E0       544            pop acc
0577 D082       544            pop dpl
0579 D083       544            pop dph
057B            545      
057B C0E0       546            push acc
057D 740A       546            mov a, #10
057F 14         546            dec a
0580 1200BF     546            lcall ?Set_Cursor_1 ; Select column and row
0583 D0E0       546            pop acc
0585 C083       547            push dph
0587 C082       547            push dpl
0589 C0E0       547            push acc
058B 900384     547            mov dptr, #temp
058E 1200B2     547            lcall ?Send_Constant_String
0591 D0E0       547            pop acc
0593 D082       547            pop dpl
0595 D083       547            pop dph
0597            548       
0597 C0E0       549            push acc
0599 7401       549            mov a, #1
059B 14         549            dec a
059C 1200BD     549            lcall ?Set_Cursor_2 ; Select column and row
059F D0E0       549            pop acc
05A1 C083       550            push dph
05A3 C082       550            push dpl
05A5 C0E0       550            push acc
05A7 900376     550            mov dptr, #state
05AA 1200B2     550            lcall ?Send_Constant_String
05AD D0E0       550            pop acc
05AF D082       550            pop dpl
05B1 D083       550            pop dph
05B3 22         551   ret
05B4            552   
05B4            553   Update_Display:
05B4 C0E0       554            push acc
05B6 7405       554            mov a, #5
05B8 14         554            dec a
05B9 1200BF     554            lcall ?Set_Cursor_1 ; Select column and row
05BC D0E0       554            pop acc
05BE C000       555       push ar0
05C0 A839       555       mov r0, Run_time_minutes
05C2 12050C     555       lcall ?Display_lower_BCD
05C5 D000       555       pop ar0
05C7 C0E0       556            push acc
05C9 7407       556            mov a, #7
05CB 14         556            dec a
05CC 1200BF     556            lcall ?Set_Cursor_1 ; Select column and row
05CF D0E0       556            pop acc
05D1 C000       557            push ar0
05D3 A838       557            mov r0, Run_time_seconds
05D5 1200C4     557            lcall ?Display_BCD
05D8 D000       557            pop ar0
05DA            558       ;Set_Cursor(1,14)
05DA            559       ;mov a, Temp_oven
05DA            560       ;SendToLCD(Temp_oven)
05DA 22         561   ret
05DB            562   
05DB            563   State0_display:
05DB C0E0       564            push acc
05DD 7401       564            mov a, #1
05DF 14         564            dec a
05E0 1200BF     564            lcall ?Set_Cursor_1 ; Select column and row
05E3 D0E0       564            pop acc
05E5 C083       565            push dph
05E7 C082       565            push dpl
05E9 C0E0       565            push acc
05EB 900360     565            mov dptr, #STemp
05EE 1200B2     565            lcall ?Send_Constant_String
05F1 D0E0       565            pop acc
05F3 D082       565            pop dpl
05F5 D083       565            pop dph
05F7 C0E0       566            push acc
05F9 7406       566            mov a, #6
05FB 14         566            dec a
05FC 1200BF     566            lcall ?Set_Cursor_1 ; Select column and row
05FF D0E0       566            pop acc
0601 E534       567       mov a, Temp_soak
0603 120519     568       lcall SendToLCD
0606            569       
0606 C0E0       570            push acc
0608 740A       570            mov a, #10
060A 14         570            dec a
060B 1200BF     570            lcall ?Set_Cursor_1 ; Select column and row
060E D0E0       570            pop acc
0610 C083       571            push dph
0612 C082       571            push dpl
0614 C0E0       571            push acc
0616 900366     571            mov dptr, #STime
0619 1200B2     571            lcall ?Send_Constant_String
061C D0E0       571            pop acc
061E D082       571            pop dpl
0620 D083       571            pop dph
0622 C0E0       572            push acc
0624 740E       572            mov a, #14
0626 14         572            dec a
0627 1200BF     572            lcall ?Set_Cursor_1 ; Select column and row
062A D0E0       572            pop acc
062C E535       573       mov a, Time_soak
062E 120519     574            lcall SendToLCD
0631            575       ;Display_BCD(Time_soak)
0631            576   
0631            577       ;Displays Reflow Temp and Time
0631 C0E0       578            push acc
0633 7401       578            mov a, #1
0635 14         578            dec a
0636 1200BD     578            lcall ?Set_Cursor_2 ; Select column and row
0639 D0E0       578            pop acc
063B C083       579            push dph
063D C082       579            push dpl
063F C0E0       579            push acc
0641 90036B     579            mov dptr, #RTemp
0644 1200B2     579            lcall ?Send_Constant_String
0647 D0E0       579            pop acc
0649 D082       579            pop dpl
064B D083       579            pop dph
064D C0E0       580            push acc
064F 7406       580            mov a, #6
0651 14         580            dec a
0652 1200BD     580            lcall ?Set_Cursor_2 ; Select column and row
0655 D0E0       580            pop acc
0657 E536       581       mov a, Temp_refl
0659 120519     582       lcall SendToLCD
065C            583       
065C C0E0       584            push acc
065E 740A       584            mov a, #10
0660 14         584            dec a
0661 1200BD     584            lcall ?Set_Cursor_2 ; Select column and row
0664 D0E0       584            pop acc
0666 C083       585            push dph
0668 C082       585            push dpl
066A C0E0       585            push acc
066C 900371     585            mov dptr, #RTime
066F 1200B2     585            lcall ?Send_Constant_String
0672 D0E0       585            pop acc
0674 D082       585            pop dpl
0676 D083       585            pop dph
0678 C0E0       586            push acc
067A 740E       586            mov a, #14
067C 14         586            dec a
067D 1200BD     586            lcall ?Set_Cursor_2 ; Select column and row
0680 D0E0       586            pop acc
0682 E537       587       mov a, Time_refl
0684 120519     588            lcall SendToLCD
0687 22         589   ret
0688            590   
0688            591   Display_3_digit_BCD:
0688 C0E0       592            push acc
068A 740E       592            mov a, #14
068C 14         592            dec a
068D 1200BF     592            lcall ?Set_Cursor_1 ; Select column and row
0690 D0E0       592            pop acc
0692 C000       593       push ar0
0694 A845       593       mov r0, bcd+1
0696 12050C     593       lcall ?Display_lower_BCD
0699 D000       593       pop ar0
069B C000       594            push ar0
069D A844       594            mov r0, bcd+0
069F 1200C4     594            lcall ?Display_BCD
06A2 D000       594            pop ar0
06A4 22         595   ret
06A5            596   
06A5            597   
06A5            598   
06A5            599   ;The following functions store and restore the values--------------------------------------------------------------------------
                600   loadbyte mac
                601       mov a, %0
                602       movx @dptr, a
                603       inc dptr
                604   endmac
06A5            605   
06A5            606   Save_Configuration:
06A5 C0A8       607       push IE ; Save the current state of bit EA in the stack
06A7 C2AF       608       clr EA ; Disable interrupts
06A9 75D108     609       mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
06AC 907F80     610       mov dptr, #0x7f80 ; Last page of flash memory
06AF            611       ; Save variables
06AF E534       612       mov a, temp_soak
06B1 F0         612       movx @dptr, a
06B2 A3         612       inc dptr ; @0x7f80
06B3 E535       613       mov a, time_soak
06B5 F0         613       movx @dptr, a
06B6 A3         613       inc dptr ; @0x7f81
06B7 E536       614       mov a, temp_refl
06B9 F0         614       movx @dptr, a
06BA A3         614       inc dptr ; @0x7f82
06BB E537       615       mov a, time_refl
06BD F0         615       movx @dptr, a
06BE A3         615       inc dptr ; @0x7f83
06BF 7455       616       mov a, #0x55
06C1 F0         616       movx @dptr, a
06C2 A3         616       inc dptr ; First key value @0x7f84
06C3 74AA       617       mov a, #0xAA
06C5 F0         617       movx @dptr, a
06C6 A3         617       inc dptr ; Second key value @0x7f85
06C7 75D100     618       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0) 
06CA 43D240     619       orl EECON, #0b01000000 ; Enable auto-erase on next write sequence  
06CD 75D150     620       mov FCON, #0x50 ; Write trigger first byte
06D0 75D1A0     621       mov FCON, #0xA0 ; Write trigger second byte
06D3            622       ; CPU idles until writing of flash completes.
06D3 75D100     623       mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
06D6 53D2BF     624       anl EECON, #0b10111111 ; Disable auto-erase
06D9 D0A8       625       pop IE ; Restore the state of bit EA from the stack
06DB 22         626   ret
06DC            627   
                628   getbyte mac
                629       clr a
                630       movc a, @a+dptr
                631       mov %0, a
                632       inc dptr
                633   endmac
06DC            634   
06DC            635   Load_Configuration:
06DC 907F84     636       mov dptr, #0x7f84 ; First key value location.
06DF E4         637       clr a
06E0 93         637       movc a, @a+dptr
06E1 F8         637       mov R0, a
06E2 A3         637       inc dptr ; 0x7f84 should contain 0x55
06E3 B8551F     638       cjne R0, #0x55, Load_Defaults
06E6 E4         639       clr a
06E7 93         639       movc a, @a+dptr
06E8 F8         639       mov R0, a
06E9 A3         639       inc dptr ; 0x7f85 should contain 0xAA
06EA B8AA18     640       cjne R0, #0xAA, Load_Defaults
06ED            641   ; Keys are good.  Get stored values.
06ED 907F80     642       mov dptr, #0x7f80
06F0 E4         643       clr a
06F1 93         643       movc a, @a+dptr
06F2 F534       643       mov Temp_soak, a
06F4 A3         643       inc dptr ; 0x7f80
06F5 E4         644       clr a
06F6 93         644       movc a, @a+dptr
06F7 F535       644       mov Time_soak, a
06F9 A3         644       inc dptr ; 0x7f81
06FA E4         645       clr a
06FB 93         645       movc a, @a+dptr
06FC F536       645       mov Temp_refl, a
06FE A3         645       inc dptr ; 0x7f82
06FF E4         646       clr a
0700 93         646       movc a, @a+dptr
0701 F537       646       mov Time_refl, a
0703 A3         646       inc dptr ; 0x7f83
0704 22         647   ret
0705            648   
0705            649   Load_Defaults:
0705 753482     650       mov Temp_soak, #130 ; Soak Tmp Range is 130-170
0708 75353C     651       mov Time_soak, #0x3C ; Range 60-90 seconds
070B 7536DC     652       mov Temp_refl, #220 ; Range 220-240
070E 75371E     653       mov Time_refl, #0x1E ; Range 30-45 seconds
0711 22         654       ret 
0712            655   ;-------------------------------------------------------------------------------------------------------------------------------
0712            656   ;off state
0712            657   
0712            658   OFF_STATE:
0712            659       ;**CLEAR SCREEN**
0712 7401       660            mov a, #0x01
0714 120083     660            lcall ?WriteCommand
0717            661       ;**TURN OFF OVEN
0717 C287       662       clr OVEN_POWER
0719            663       ;OFF_STATE1:
0719            664       
0719 20C5FD     665       jb POWER_BUTTON, $ ; loop while the button is not pressed
071C C002       666            push AR2
071E 7A32       666            mov R2, #50
0720 120039     666            lcall ?Wait_Milli_Seconds
0723 D002       666            pop AR2 ; debounce time
0725 20C5EA     667            jb POWER_BUTTON, OFF_STATE ; it was a bounce, try again
0728 30C5FD     668            jnb POWER_BUTTON, $ ; loop while the button is pressed
072B 020877     669       ljmp main
072E 22         670   ret
072F            671   ;-------------------------------------------------------------------------------------------------------------------------------
072F            672   
072F            673   ;***CHECK TEMPERATURE BY READING VOLTAGE AND CONVERTING
072F            674   Check_Temp:
072F            675       
072F 30006E     676       jnb one_seconds_flag, Check_Temp_done
0732 C200       677       clr one_seconds_flag
0734            678       
0734 C297       679       clr CE_ADC
0736 7801       680            mov R0, #00000001B ; Start bit:1
0738 1203F4     681            lcall DO_SPI_G
073B 7880       682            mov R0, #10000000B ; Single ended, read channel 0
073D 1203F4     683            lcall DO_SPI_G
0740 E9         684            mov a, R1          ; R1 contains bits 8 and 9
0741 5403       685            anl a, #00000011B  ; We need only the two least significant bits
0743 F54A       686            mov Result+1, a    ; Save result high.
0745 7855       687            mov R0, #55H ; It doesn't matter what we transmit...
0747 1203F4     688            lcall DO_SPI_G
074A 8949       689            mov Result, R1     ; R1 contains bits 0 to 7.  Save result low.
074C D297       690            setb CE_ADC
074E            691   
074E C002       692            push AR2
0750 7A0A       692            mov R2, #10
0752 120039     692            lcall ?Wait_Milli_Seconds
0755 D002       692            pop AR2
0757            693       ; Copy the 10-bits of the ADC conversion into the 32-bits of 'x'
0757 85493C     694            mov x+0, result+0
075A 854A3D     695            mov x+1, result+1
075D 753E00     696            mov x+2, #0
0760 753F00     697            mov x+3, #0
0763            698            
0763            699   ;Check_Temp_done_2:
0763            700       ;jnb one_seconds_flag, Check_Temp_done
0763            701       ;mov a, result+1
0763            702       ;Set_Cursor(1,14)
0763            703       ;lcall SendToLCD 
0763            704       ;Set_Cursor(1,14)
0763            705       ;mov a, x+0
0763            706       ;lcall SendToLCD
0763            707       ;mov Temp_oven, a
0763            708       
0763            709       ;mov a, States
0763            710       ;cjne a, #0, Display_Temp_BCD
0763            711       ;sjmp Send_Temp_Port
0763            712            
0763            713       ; The 4-bytes of x have the temperature in binary
0763            714   Display_Temp_BCD:
0763 1200F0     715            lcall hex2bcd ; converts binary in x to BCD in BCD
0766            716   
0766 120688     717       lcall Display_3_digit_BCD
0769            718   
0769            719   Send_Temp_Port:
0769 C000       720       push ar0
076B A848       720       mov r0, bcd+4
076D 1200DA     720       lcall ?Send_BCD
0770 D000       720       pop ar0
0772            720   
0772 C000       721       push ar0
0774 A847       721       mov r0, bcd+3
0776 1200DA     721       lcall ?Send_BCD
0779 D000       721       pop ar0
077B            721   
077B C000       722       push ar0
077D A846       722       mov r0, bcd+2
077F 1200DA     722       lcall ?Send_BCD
0782 D000       722       pop ar0
0784            722   
0784 C000       723       push ar0
0786 A845       723       mov r0, bcd+1
0788 1200DA     723       lcall ?Send_BCD
078B D000       723       pop ar0
078D            723   
078D C000       724       push ar0
078F A844       724       mov r0, bcd+0
0791 1200DA     724       lcall ?Send_BCD
0794 D000       724       pop ar0
0796            724   
0796 740D       725            mov a, #'\r'
0798 12047E     726            lcall putchar
079B 740A       727            mov a, #'\n'
079D 12047E     728            lcall putchar
07A0            729   Check_Temp_done:
07A0 22         730       ret
07A1            731       
07A1            732   
07A1            733   ;-------------------------------------------------------------------------------------------------------------------------------
07A1            734   
07A1            735   ;Time wait
07A1            736   
07A1            737   Wait_One_Second:
07A1 C002       738            push AR2
07A3 7AFA       738            mov R2, #250
07A5 120039     738            lcall ?Wait_Milli_Seconds
07A8 D002       738            pop AR2
07AA C002       739            push AR2
07AC 7AFA       739            mov R2, #250
07AE 120039     739            lcall ?Wait_Milli_Seconds
07B1 D002       739            pop AR2
07B3 C002       740            push AR2
07B5 7AFA       740            mov R2, #250
07B7 120039     740            lcall ?Wait_Milli_Seconds
07BA D002       740            pop AR2
07BC C002       741            push AR2
07BE 7AFA       741            mov R2, #250
07C0 120039     741            lcall ?Wait_Milli_Seconds
07C3 D002       741            pop AR2
07C5 22         742   ret
07C6            743   
07C6            744   ; ==================================================================================================
07C6            745   
07C6            746   ;-------------------------------------;
07C6            747   ; ISR for Timer 1.  Used to playback  ;
07C6            748   ; the WAV file stored in the SPI      ;
07C6            749   ; flash memory.                       ;
07C6            750   ;-------------------------------------;
07C6            751   Timer1_ISR:
07C6            752            ; The registers used in the ISR must be saved in the stack
07C6 C0E0       753            push acc
07C8 C0D0       754            push psw
07CA            755            
07CA            756            ; Check if the play counter is zero.  If so, stop playing sound.
07CA E54B       757            mov a, w+0
07CC 454C       758            orl a, w+1
07CE 454D       759            orl a, w+2
07D0 601E       760            jz stop_playing
07D2            761            
07D2            762            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
07D2 74FF       763            mov a, #0xff
07D4 154B       764            dec w+0
07D6 B54B07     765            cjne a, w+0, keep_playing
07D9 154C       766            dec w+1
07DB B54C02     767            cjne a, w+1, keep_playing
07DE 154D       768            dec w+2
07E0            769            
07E0            770   keep_playing:
07E0 D2A6       771            setb SPEAKER
07E2 12040D     772            lcall Send_SPI ; Read the next byte from the SPI Flash...
07E5 F580       773            mov P0, a ; WARNING: Remove this if not using an external DAC to use the pins of P0 as GPIO
07E7 2480       774            add a, #0x80
07E9 F5AD       775            mov DADH, a ; Output to DAC. DAC output is pin P2.3
07EB 43A440     776            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
07EE 800A       777            sjmp Timer1_ISR_Done
07F0            778   
07F0            779   stop_playing:
07F0 C28E       780            clr TR1 ; Stop timer 1
07F2            781            ;setb FLASH_CE  ; Disable SPI Flash
07F2 C2A6       782            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
07F4 75AD80     783            mov DADH, #0x80 ; middle of range
07F7 43A440     784            orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
07FA            785   
07FA            786   Timer1_ISR_Done:         
07FA D0D0       787            pop psw
07FC D0E0       788            pop acc
07FE 32         789            reti
07FF            790   ; ==================================================================================================
07FF            791   
07FF            792   ;---------------------------------;
07FF            793   ; Routine to initialize the ISR   ;
07FF            794   ; for timer 2                     ;
07FF            795   ;---------------------------------;
07FF            796   Timer2_init:
07FF 75C800     797       mov T2CON, #0
0802 75CDA9     798       mov TH2, #high(TIMER2_RELOAD)
0805 75CC9A     799       mov TL2, #low(TIMER2_RELOAD)
0808            800   
0808 75CBA9     801       mov RCAP2H, #high(TIMER2_RELOAD)
080B 75CA9A     802       mov RCAP2L, #low(TIMER2_RELOAD)
080E            803   
080E E4         804       clr a
080F F530       805       mov Count1ms+0, a
0811 F531       806       mov Count1ms+1, a
0813 F532       807       mov Count5sec , a
0815 D2AD       808       setb ET2
0817 D2CA       809       setb TR2
0819 C202       810       clr enable_clk
081B 22         811       ret
081C            812   
081C            813   ;---------------------------------;
081C            814   ; ISR for timer 2                 ;
081C            815   ;---------------------------------;
081C            816   Timer2_ISR:
081C C2CF       817       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
081E B290       818       cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0820            819            
0820            820            ; The two registers used in the ISR must be saved in the stack
0820 C0E0       821       push acc
0822 C0D0       822       push psw
0824            823            
0824            824            ; Increment the 16-bit one mili second counter
0824 0530       825            inc Count1ms+0    ; Increment the low 8-bits first
0826 E530       826            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0828 7002       827            jnz Inc_Done
082A 0531       828            inc Count1ms+1
082C            829   
082C            830   Inc_Done:
082C            831   
082C            832   ;**Oven Power Output-------------------
082C            833       ; Do the PWM thing
082C            834            ; Check if Count1ms > pwm_ratio (this is a 16-bit compare)
082C C3         835            clr c
082D E54E       836            mov a, pwm_ratio+0
082F 9530       837            subb a, Count1ms+0
0831 E54F       838            mov a, pwm_ratio+1
0833 9531       839            subb a, Count1ms+1
0835            840            ; if Count1ms > pwm_ratio  the carry is set.  Just copy the carry to the pwm output pin:
0835 9290       841            mov PWM_OUTPUT, c
0837            842   ;**----------------------------------
0837            843            ; Check if one second has passed
0837 E530       844            mov a, Count1ms+0
0839 B4E836     845            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
083C E531       846            mov a, Count1ms+1
083E B40331     847            cjne a, #high(1000), Timer2_ISR_done
0841            848            
0841            849            ; 1000 milliseconds have passed.  Set a flag so the main program knows
0841 D200       850            setb one_seconds_flag ; Let the main program know one second had passed
0843            851       
0843 0532       852       inc Count5sec
0845 E532       853       mov a, Count5sec
0847 B40505     854       cjne a, #5, Set_5sec_flag_done
084A D201       855       setb five_seconds_flag
084C E4         856       clr a
084D F532       857       mov Count5sec, a
084F            858       
084F            859   Set_5sec_flag_done:
084F E4         860            clr a
0850 F530       861            mov Count1ms+0, a
0852 F531       862            mov Count1ms+1, a
0854            863   
0854 30021B     864       jnb enable_clk, Timer2_ISR_done ;if the clk is enabled, increment the second. Otherwise skip
0857            865   ; Increment the run time counter and state time counter
0857 E538       866            mov a, Run_time_seconds
0859 2401       867            add a, #0x01
085B D4         868            da a
085C F538       869       mov Run_time_seconds, a
085E            870       ;check sec overflow
085E B4600A     871       cjne a, #0x60, Check_sec_overflow_done
0861 753800     872       mov Run_time_seconds, #0x00
0864 E539       873       mov a, Run_time_minutes ;inc min
0866 2401       874       add a, #1
0868 D4         875       da a
0869 F539       876       mov Run_time_minutes, a
086B            877   Check_sec_overflow_done:
086B E53A       878            mov a, State_time
086D 2401       879            add a, #0x01
086F D4         880            da a
0870 F53A       881            mov State_time, a
0872            882   Timer2_ISR_done:
0872 D0D0       883            pop psw
0874 D0E0       884            pop acc
0876 32         885            reti
0877            886   
0877            887   
0877            888   ; ==================================================================================================
0877            889   
0877            890   main:
0877 75817F     891       mov SP, #0x7F
087A 1207FF     892       lcall Timer2_Init
087D 1203EF     893       lcall INI_SPI
0880 120088     894       lcall LCD_4BIT
0883 120466     895       lcall InitSerialPort
0886            896       ; In case you decide to use the pins of P0, configure the port in bidirectional mode. Can be ignored
0886 75E600     897       mov P0M0, #0
0889 75E700     898       mov P0M1, #0
088C D2AF       899       setb EA   ;Enable global enterupt
088E            900   
088E 1206DC     901       lcall Load_Configuration
0891            902   
0891            903       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
0891 754E00     904            mov pwm_ratio+0, #low(0)
0894 754F00     905            mov pwm_ratio+1, #high(0)
0897 753300     906       mov States, #0
089A            907       
089A            908   state0: ; idle
089A            909   
089A            910       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
089A 754E00     911            mov pwm_ratio+0, #low(0)
089D 754F00     912            mov pwm_ratio+1, #high(0)
08A0            913       ;mov States, #0
08A0            914   
08A0            915   ;***initial parameters displayed***
08A0            916       
08A0            917       ;Displays Soak Temp and Time
08A0 1205DB     918       lcall State0_display
08A3            919       ;check power on
08A3 1204F6     920       lcall CHECK_POWER
08A6            921       ; check the parameters being pressed
08A6 120486     922       lcall CHECK_STIME
08A9 1204A2     923       lcall CHECK_STEMP
08AC 1204BE     924       lcall CHECK_RTIME
08AF 1204DA     925       lcall CHECK_RTEMP
08B2 1206A5     926       lcall Save_Configuration
08B5            927       
08B5            928       ;lcall Check_Temp
08B5            929   
08B5 2085E2     930       jb NEXT_STATE_BUTTON, state0
08B8 C002       931            push AR2
08BA 7A32       931            mov R2, #50
08BC 120039     931            lcall ?Wait_Milli_Seconds
08BF D002       931            pop AR2 ; debounce time
08C1 2085D6     932            jb NEXT_STATE_BUTTON, state0 ; if button not pressed, loop
08C4 3085FD     933            jnb NEXT_STATE_BUTTON, $ 
08C7            934   state0_done:
08C7 753301     935       mov States, #1
08CA 753A00     936       mov State_time, #0
08CD D202       937       setb enable_clk
08CF            938      
08CF            939        
08CF            940   
08CF            941   state1_beginning:
08CF            942       
08CF            943       ;Start Run Time
08CF 753800     944       mov Run_time_seconds, #0 ; time starts at 0:00
08D2 753900     945       mov Run_time_minutes, #0
08D5            946   
08D5            947       ;***clear the screen and set new display***
08D5 120535     948       lcall Initialize_State_Display
08D8 C0E0       949            push acc
08DA 7407       949            mov a, #7
08DC 14         949            dec a
08DD 1200BD     949            lcall ?Set_Cursor_2 ; Select column and row
08E0 D0E0       949            pop acc
08E2 C083       950            push dph
08E4 C082       950            push dpl
08E6 C0E0       950            push acc
08E8 9003C7     950            mov dptr, #Ramp2Soak
08EB 1200B2     950            lcall ?Send_Constant_String
08EE D0E0       950            pop acc
08F0 D082       950            pop dpl
08F2 D083       950            pop dph
08F4            950   ; displays current state
08F4            951   
08F4            952       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
08F4 754EE8     953            mov pwm_ratio+0, #low(1000)
08F7 754F03     954            mov pwm_ratio+1, #high(1000)
08FA            955       
08FA            956   
08FA            957   state1: ; ramp to soak
08FA            958       
08FA            959       
08FA            960       ;check power on
08FA 1204F6     961       lcall CHECK_POWER
08FD            962       ;Update Time and Temp
08FD 1205B4     963       lcall Update_Display
0900 12072F     964       lcall Check_Temp
0903            965   
0903            966       ; check if temp is below 150 
0903            967       ;MOV A, Temp_soak           
0903            968       ;SUBB A, Temp_soak       
0903            969       ;JNC state1_done    ; if greater, jump to state 2
0903            970       ;JZ state1_done ; if equal to, jump to state 2
0903            971       ;JC state1 ; if less than, go back to state1
0903            972   
0903            973   ;*Checking moving to states with buttons---- 
0903            974   ;*Will remove after proper temperature reading----
0903            975   
0903 2085F4     976       jb NEXT_STATE_BUTTON, state1
0906 C002       977            push AR2
0908 7A32       977            mov R2, #50
090A 120039     977            lcall ?Wait_Milli_Seconds
090D D002       977            pop AR2 ; debounce time
090F 2085E8     978            jb NEXT_STATE_BUTTON, state1 ; if button not pressed, loop
0912 3085FD     979            jnb NEXT_STATE_BUTTON, $ 
0915            980   
0915            981   state1_done:
0915 753302     982       mov States, #2
0918            983       ;set State_time = 0
0918 8000       984       sjmp state2_beginning
091A            985   
091A            986   ;OFF_STATE2:
091A            987       ;ljmp OFF_STATE
091A            988   
091A            989   ; preheat/soak
091A            990   state2_beginning: 
091A 753A00     991       mov State_time, #0x00 ;clear the state time
091D            992       ;***clear the screen and set new display***
091D 120535     993       lcall Initialize_State_Display
0920 C0E0       994            push acc
0922 7407       994            mov a, #7
0924 14         994            dec a
0925 1200BD     994            lcall ?Set_Cursor_2 ; Select column and row
0928 D0E0       994            pop acc
092A C083       995            push dph
092C C082       995            push dpl
092E C0E0       995            push acc
0930 9003D1     995            mov dptr, #Soak
0933 1200B2     995            lcall ?Send_Constant_String
0936 D0E0       995            pop acc
0938 D082       995            pop dpl
093A D083       995            pop dph ;displays current state
093C            996   
093C            997       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
093C 754EC8     998            mov pwm_ratio+0, #low(200)
093F 754F00     999            mov pwm_ratio+1, #high(000)
0942           1000   
0942           1001   state2:
0942           1002       ;check power on
0942 1204F6    1003       lcall CHECK_POWER
0945           1004       
0945           1005       ;Update Time and Temp
0945 1205B4    1006       lcall Update_Display
0948           1007   
0948           1008       ;Set_Cursor(1,14)
0948           1009       ;mov a, Temp_oven
0948           1010       ;lcall SendToLCD
0948           1011   
0948           1012       ;on
0948           1013       ;setb OVEN_POWER
0948           1014       ;lcall Wait_One_Second
0948           1015       ;off
0948           1016       ;clr OVEN_POWER
0948           1017       ;mov r5, #0
0948           1018   ;four_sec_loop:
0948           1019       ; loop back to state2 if run time is less than soak time
0948           1020    ;   mov a, Time_soak
0948           1021     ;  subb a, State_time
0948           1022      ; cjne a, #0, state2
0948           1023       ;Set_Cursor(1,5)
0948           1024            ;Display_BCD(Run_time_minutes)
0948           1025       ;Set_Cursor(1,7)
0948           1026       ;Send_Constant_String(#colon)
0948           1027       ;Set_Cursor(1,8)
0948           1028       ;Display_BCD(Run_time_seconds)
0948           1029       ;Wait_Milli_Seconds(#250)
0948           1030       ;inc r5
0948           1031       ;cjne r5, #16, four_sec_loop
0948           1032           
0948           1033       
0948           1034       ; loop back to state2 if run time is less than soak time
0948           1035       ;mov a, Time_soak
0948           1036       ;subb a, State_time
0948           1037       ;cjne a, #0, state2
0948           1038   
0948           1039   ;*Checking moving to states with buttons---- 
0948           1040   ;*Will remove after proper temperature reading----
0948           1041   
0948 2085F7    1042       jb NEXT_STATE_BUTTON, state2
094B C002      1043            push AR2
094D 7A32      1043            mov R2, #50
094F 120039    1043            lcall ?Wait_Milli_Seconds
0952 D002      1043            pop AR2 ; debounce time
0954 2085EB    1044            jb NEXT_STATE_BUTTON, state2 ; if button not pressed, loop
0957 3085FD    1045            jnb NEXT_STATE_BUTTON, $ 
095A           1046       
095A           1047   state2_done:
095A 753A00    1048       mov State_time, #0
095D 020960    1049       ljmp state3_beginning
0960           1050   
0960           1051   ; ramp to peak
0960           1052   state3_beginning:
0960 D287      1053       setb OVEN_POWER ;turn power on 100%
0962           1054   
0962           1055       ;***clear the screen and set new display***
0962 120535    1056       lcall Initialize_State_Display
0965 C0E0      1057            push acc
0967 7407      1057            mov a, #7
0969 14        1057            dec a
096A 1200BD    1057            lcall ?Set_Cursor_2 ; Select column and row
096D D0E0      1057            pop acc
096F C083      1058            push dph
0971 C082      1058            push dpl
0973 C0E0      1058            push acc
0975 9003D6    1058            mov dptr, #Ramp2Peak
0978 1200B2    1058            lcall ?Send_Constant_String
097B D0E0      1058            pop acc
097D D082      1058            pop dpl
097F D083      1058            pop dph
0981           1059   
0981           1060       ;Set the default pwm output ratio to 100%.  That is 1000ms of every second:
0981 754EE8    1061            mov pwm_ratio+0, #low(1000)
0984 754F03    1062            mov pwm_ratio+1, #high(1000)
0987           1063   
0987           1064   state3: 
0987           1065       ;check power on
0987 1204F6    1066       lcall CHECK_POWER
098A           1067       
098A           1068       
098A           1069       ;Update Time and Temp
098A 1205B4    1070       lcall Update_Display
098D           1071       
098D           1072       ;mov a, Temp_oven
098D           1073       ;subb a, Temp_refl 
098D           1074       ;JNC state3_done    ; if greater, jump to state 4
098D           1075       ;JZ state3_done ; if equal to, jump to state 4
098D           1076       ;JC state3 ; if less than, go back to state3
098D           1077       
098D 2085F7    1078   jb NEXT_STATE_BUTTON, state3
0990 C002      1079            push AR2
0992 7A32      1079            mov R2, #50
0994 120039    1079            lcall ?Wait_Milli_Seconds
0997 D002      1079            pop AR2 ; debounce time
0999 2085EB    1080            jb NEXT_STATE_BUTTON, state3 ; if button not pressed, loop
099C 3085FD    1081            jnb NEXT_STATE_BUTTON, $
099F           1082   
099F           1083   state3_done:
099F 753A00    1084       mov State_time, #0
09A2 0209A5    1085       ljmp state4_beginning
09A5           1086   
09A5           1087   
09A5           1088   ; reflow 
09A5           1089   state4_beginning:
09A5           1090       ;***clear the screen and set new display***
09A5 120535    1091       lcall Initialize_State_Display
09A8 C0E0      1092            push acc
09AA 7407      1092            mov a, #7
09AC 14        1092            dec a
09AD 1200BD    1092            lcall ?Set_Cursor_2 ; Select column and row
09B0 D0E0      1092            pop acc
09B2 C083      1093            push dph
09B4 C082      1093            push dpl
09B6 C0E0      1093            push acc
09B8 9003E0    1093            mov dptr, #Reflow
09BB 1200B2    1093            lcall ?Send_Constant_String
09BE D0E0      1093            pop acc
09C0 D082      1093            pop dpl
09C2 D083      1093            pop dph
09C4           1094   
09C4           1095       ;Set the default pwm output ratio to 20%.  That is 200ms of every second:
09C4 754EC8    1096            mov pwm_ratio+0, #low(200)
09C7 754F00    1097            mov pwm_ratio+1, #high(000)
09CA           1098   
09CA           1099   
09CA           1100   state4:
09CA           1101       ;check power on
09CA 1204F6    1102       lcall CHECK_POWER
09CD           1103       ;Update Time and Temp
09CD 1205B4    1104       lcall Update_Display
09D0           1105   
09D0           1106       ;on
09D0           1107       ;setb OVEN_POWER
09D0           1108       ;lcall Wait_One_Second
09D0           1109       ;off
09D0           1110       ;clr OVEN_POWER
09D0           1111       ;mov r5, #0
09D0           1112       ;four_sec_loop2:
09D0           1113           ; loop back to state2 if run time is less than soak time
09D0           1114       ;    mov a, Time_refl
09D0           1115       ;    subb a, State_time
09D0           1116       ;   cjne a, #0, state4
09D0           1117       ;    Set_Cursor(1, 5)
09D0           1118            ;    Display_BCD(Run_time_minutes)
09D0           1119       ;    Set_Cursor(1,7)
09D0           1120       ;    Display_BCD(Run_time_seconds)
09D0           1121       ;    Wait_Milli_Seconds(#250)
09D0           1122   
09D0           1123       ;    inc r5
09D0           1124       ;    cjne r5, #16, four_sec_loop2
09D0           1125           
09D0           1126       
09D0           1127       ; loop back to state2 if run time is less than soak time
09D0           1128       ;mov a, Time_refl
09D0           1129       ;subb a, State_time
09D0           1130       ;cjne a, #0, state4
09D0           1131   
09D0           1132       ;*Checking moving to states with buttons---- 
09D0           1133   ;*Will remove after proper temperature reading----
09D0           1134   
09D0 2085F7    1135       jb NEXT_STATE_BUTTON, state4
09D3 C002      1136            push AR2
09D5 7A32      1136            mov R2, #50
09D7 120039    1136            lcall ?Wait_Milli_Seconds
09DA D002      1136            pop AR2 ; debounce time
09DC 2085EB    1137            jb NEXT_STATE_BUTTON, state4 ; if button not pressed, loop
09DF 3085FD    1138            jnb NEXT_STATE_BUTTON, $ 
09E2           1139   
09E2           1140   state4_done: 
09E2 753A00    1141       mov State_time, #0
09E5 0209E8    1142       ljmp state5_beginning 
09E8           1143   
09E8           1144   
09E8           1145   ; cooling
09E8           1146   state5_beginning: ; turn oven off
09E8 C287      1147       clr OVEN_POWER
09EA           1148   
09EA           1149   ;***clear the screen and set new display***
09EA 120535    1150       lcall Initialize_State_Display
09ED C083      1151            push dph
09EF C082      1151            push dpl
09F1 C0E0      1151            push acc
09F3 9003E7    1151            mov dptr, #Cooling
09F6 1200B2    1151            lcall ?Send_Constant_String
09F9 D0E0      1151            pop acc
09FB D082      1151            pop dpl
09FD D083      1151            pop dph
09FF           1152   
09FF           1153       ;Set the default pwm output ratio to 0%.  That is 0ms of every second:
09FF 754E00    1154            mov pwm_ratio+0, #low(0)
0A02 754F00    1155            mov pwm_ratio+1, #high(0)
0A05           1156   
0A05           1157   state5:
0A05           1158       ;check power on
0A05 1204F6    1159       lcall CHECK_POWER
0A08           1160       
0A08           1161       ; update display
0A08 1205B4    1162       lcall Update_Display
0A0B           1163   
0A0B           1164       ;mov a, Temp_oven
0A0B           1165       ;subb a, #60
0A0B           1166       ;JNC state5    ; if greater, jump back to state 5
0A0B           1167       ;JZ state5 ; if equal to, go back to state5
0A0B           1168       ;JC state5_done ; if less than, go back to state 0
0A0B           1169   
0A0B           1170       ;*Checking moving to states with buttons---- 
0A0B           1171   ;*Will remove after proper temperature reading----
0A0B           1172   
0A0B 2085F7    1173       jb NEXT_STATE_BUTTON, state5
0A0E C002      1174            push AR2
0A10 7A32      1174            mov R2, #50
0A12 120039    1174            lcall ?Wait_Milli_Seconds
0A15 D002      1174            pop AR2 ; debounce time
0A17 2085EB    1175            jb NEXT_STATE_BUTTON, state5 ; if button not pressed, loop
0A1A 3085FD    1176            jnb NEXT_STATE_BUTTON, $ 
0A1D           1177   
0A1D           1178   state5_done:
0A1D 753A00    1179       mov State_time, #0
0A20 753300    1180       mov States, #0
0A23 020877    1181       ljmp main
0A26           1182   
0A26           1183   EN
